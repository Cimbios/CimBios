using CimBios.Core.CimModel.CimDatatypeLib;
/**
 * Annotated C# for Profile
 * Generated by CIMTool http://cimtool.org
 */
namespace Profile
{
    /// <summary>
    /// A DC electrical connection point at the AC/DC converter. The AC/DC converter
    /// is electrically connected also to the AC side. The AC connection is inherited
    /// from the AC conducting equipment in the same way as any other AC equipment.
    /// The AC/DC converter DC terminal is separate from generic DC terminal to
    /// restrict the connection with the AC side to AC/DC converter and so that
    /// no other DC conducting equipment can be connected to the AC side.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ACDCConverterDCTerminal")]
    public partial class ACDCConverterDCTerminal : DCBaseTerminal, IModelObject
    {
        public ACDCConverterDCTerminal(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// An electrical connection point (AC or DC) to a piece of conducting equipment.
    /// Terminals are connected at physical connection points called connectivity
    /// nodes.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ACDCTerminal")]
    public partial class ACDCTerminal : IdentifiedObject, IModelObject
    {
        public ACDCTerminal(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The orientation of the terminal connections for a multiple terminal conducting
        /// equipment. The sequence numbering starts with 1 and additional terminals
        /// should follow in increasing order. The first terminal is the "starting
        /// point" for a two terminal branch.
        /// </summary>
        public int sequenceNumber
        {
            get => ObjectData.GetAttribute<int>(nameof(sequenceNumber));
            set => ObjectData.SetAttribute<int>(nameof(sequenceNumber), value);
        }
         
        /// <summary>
        /// Measurements associated with this terminal defining where the measurement
        /// is placed in the network topology. It may be used, for instance, to capture
        /// the sensor position, such as a voltage transformer (PT) at a busbar or
        /// a current transformer (CT) at the bar between a breaker and an isolator.
        /// </summary>
        public Measurement[]? Measurements
        {
            get => ObjectData.GetAssoc1ToM<Measurement>(nameof(Measurements));
        }
         
        public void AddToMeasurements(Measurement value)
        {
            ObjectData.AddAssoc1ToM(nameof(Measurements), value);
        }
         
        public void RemoveFromMeasurements(Measurement value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Measurements), value);
        }
         
        public void RemoveAllFromMeasurements()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Measurements));
        }
         
    }
     
    /// <summary>
    /// A wire or combination of wires, with consistent electrical characteristics,
    /// building a single electrical system, used to carry alternating current
    /// between points in the power system.
    /// For symmetrical, transposed three phase lines, it is sufficient to use
    /// attributes of the line segment, which describe impedances and admittances
    /// for the entire length of the segment. Additionally impedances can be computed
    /// by using length and associated per length impedances.
    /// The BaseVoltage at the two ends of ACLineSegments in a Line shall have
    /// the same BaseVoltage.nominalVoltage. However, boundary lines may have slightly
    /// different BaseVoltage.nominalVoltages and variation is allowed. Larger
    /// voltage difference in general requires use of an equivalent branch.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ACLineSegment")]
    public partial class ACLineSegment : Conductor, IModelObject
    {
        public ACLineSegment(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Formal agreement between two parties defining the terms and conditions
    /// for a set of services. The specifics of the services are, in turn, defined
    /// via one or more service agreements.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Agreement")]
    public partial class Agreement : Document, IModelObject
    {
        public Agreement(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Analog represents an analog Measurement.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Analog")]
    public partial class Analog : Measurement, IModelObject
    {
        public Analog(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Normal value range maximum for any of the MeasurementValue.values. Used
        /// for scaling, e.g. in bar graphs or of telemetered raw values.
        /// </summary>
        public float maxValue
        {
            get => ObjectData.GetAttribute<float>(nameof(maxValue));
            set => ObjectData.SetAttribute<float>(nameof(maxValue), value);
        }
         
        /// <summary>
        /// Normal value range minimum for any of the MeasurementValue.values. Used
        /// for scaling, e.g. in bar graphs or of telemetered raw values.
        /// </summary>
        public float minValue
        {
            get => ObjectData.GetAttribute<float>(nameof(minValue));
            set => ObjectData.SetAttribute<float>(nameof(minValue), value);
        }
         
        /// <summary>
        /// Normal measurement value, e.g., used for percentage calculations.
        /// </summary>
        public float normalValue
        {
            get => ObjectData.GetAttribute<float>(nameof(normalValue));
            set => ObjectData.SetAttribute<float>(nameof(normalValue), value);
        }
         
        /// <summary>
        /// If true then this measurement is an active power, reactive power or current
        /// with the convention that a positive value measured at the Terminal means
        /// power is flowing into the related PowerSystemResource.
        /// </summary>
        public bool positiveFlowIn
        {
            get => ObjectData.GetAttribute<bool>(nameof(positiveFlowIn));
            set => ObjectData.SetAttribute<bool>(nameof(positiveFlowIn), value);
        }
         
        /// <summary>
        /// The values connected to this measurement.
        /// </summary>
        public AnalogValue[]? AnalogValues
        {
            get => ObjectData.GetAssoc1ToM<AnalogValue>(nameof(AnalogValues));
        }
         
        public void AddToAnalogValues(AnalogValue value)
        {
            ObjectData.AddAssoc1ToM(nameof(AnalogValues), value);
        }
         
        public void RemoveFromAnalogValues(AnalogValue value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AnalogValues), value);
        }
         
        public void RemoveAllFromAnalogValues()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AnalogValues));
        }
         
    }
     
    /// <summary>
    /// AnalogValue represents an analog MeasurementValue.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AnalogValue")]
    public partial class AnalogValue : MeasurementValue, IModelObject
    {
        public AnalogValue(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The value to supervise.
        /// </summary>
        public float value
        {
            get => ObjectData.GetAttribute<float>(nameof(value));
            set => ObjectData.SetAttribute<float>(nameof(value), value);
        }
         
        /// <summary>
        /// Measurement to which this value is connected.
        /// </summary>
        public Analog? Analog
        {
            get => ObjectData.GetAssoc1To1<Analog>(nameof(Analog));
            set => ObjectData.SetAssoc1To1(nameof(Analog), value);
        }
         
    }
     
    /// <summary>
    /// Tangible resource of the utility, including power system equipment, various
    /// end devices, cabinets, buildings, etc. For electrical network equipment,
    /// the role of the asset is defined through PowerSystemResource and its subclasses,
    /// defined mainly in the Wires model (refer to IEC61970-301 and model package
    /// IEC61970::Wires). Asset description places emphasis on the physical characteristics
    /// of the equipment fulfilling that role.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Asset")]
    public partial class Asset : IdentifiedObject, IModelObject
    {
        public Asset(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Container of this asset.
        /// </summary>
        public AssetContainer? AssetContainer
        {
            get => ObjectData.GetAssoc1To1<AssetContainer>(nameof(AssetContainer));
            set => ObjectData.SetAssoc1To1(nameof(AssetContainer), value);
        }
         
        /// <summary>
        /// Location of this asset.
        /// </summary>
        public Location? Location
        {
            get => ObjectData.GetAssoc1To1<Location>(nameof(Location));
            set => ObjectData.SetAssoc1To1(nameof(Location), value);
        }
         
        /// <summary>
        /// All power system resources used to electrically model this asset. For example,
        /// transformer asset is electrically modelled with a transformer and its windings
        /// and tap changer.
        /// </summary>
        public PowerSystemResource[]? PowerSystemResources
        {
            get => ObjectData.GetAssoc1ToM<PowerSystemResource>(nameof(PowerSystemResources));
        }
         
        public void AddToPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveFromPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveAllFromPowerSystemResources()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerSystemResources));
        }
         
    }
     
    /// <summary>
    /// Asset that is aggregation of other assets such as conductors, transformers,
    /// switchgear, land, fences, buildings, equipment, vehicles, etc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AssetContainer")]
    public partial class AssetContainer : Asset, IModelObject
    {
        public AssetContainer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All assets within this container asset.
        /// </summary>
        public Asset[]? Assets
        {
            get => ObjectData.GetAssoc1ToM<Asset>(nameof(Assets));
        }
         
        public void AddToAssets(Asset value)
        {
            ObjectData.AddAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveFromAssets(Asset value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveAllFromAssets()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Assets));
        }
         
    }
     
    /// <summary>
    /// A rotating machine whose shaft rotates asynchronously with the electrical
    /// field. Also known as an induction machine with no external connection to
    /// the rotor windings, e.g. squirrel-cage induction machine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AsynchronousMachine")]
    public partial class AsynchronousMachine : RotatingMachine, IModelObject
    {
        public AsynchronousMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public PrimeMover? PrimeMover
        {
            get => ObjectData.GetAssoc1To1<PrimeMover>(nameof(PrimeMover));
            set => ObjectData.SetAssoc1To1(nameof(PrimeMover), value);
        }
         
    }
     
    /// <summary>
    /// AuxiliaryEquipment describe equipment that is not performing any primary
    /// functions but support for the equipment performing the primary function.
    /// AuxiliaryEquipment is attached to primary equipment via an association
    /// with Terminal.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#AuxiliaryEquipment")]
    public partial class AuxiliaryEquipment : Equipment, IModelObject
    {
        public AuxiliaryEquipment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The Terminal at the equipment where the AuxiliaryEquipment is attached.
        /// </summary>
        public Terminal? Terminal
        {
            get => ObjectData.GetAssoc1To1<Terminal>(nameof(Terminal));
            set => ObjectData.SetAssoc1To1(nameof(Terminal), value);
        }
         
    }
     
    /// <summary>
    /// Boiling water reactor used as a steam supply to a steam turbine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#BWRSteamSupply")]
    public partial class BWRSteamSupply : SteamSupply, IModelObject
    {
        public BWRSteamSupply(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Defines a system base voltage which is referenced.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#BaseVoltage")]
    public partial class BaseVoltage : IdentifiedObject, IModelObject
    {
        public BaseVoltage(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public bool isDC
        {
            get => ObjectData.GetAttribute<bool>(nameof(isDC));
            set => ObjectData.SetAttribute<bool>(nameof(isDC), value);
        }
         
        /// <summary>
        /// The power system resource's base voltage. Shall be a positive value and
        /// not zero.
        /// </summary>
        public float nominalVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalVoltage));
            set => ObjectData.SetAttribute<float>(nameof(nominalVoltage), value);
        }
         
        /// <summary>
        /// All conducting equipment with this base voltage. Use only when there is
        /// no voltage level container used and only one base voltage applies. For
        /// example, not used for transformers.
        /// </summary>
        public ConductingEquipment[]? ConductingEquipment
        {
            get => ObjectData.GetAssoc1ToM<ConductingEquipment>(nameof(ConductingEquipment));
        }
         
        public void AddToConductingEquipment(ConductingEquipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConductingEquipment), value);
        }
         
        public void RemoveFromConductingEquipment(ConductingEquipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConductingEquipment), value);
        }
         
        public void RemoveAllFromConductingEquipment()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConductingEquipment));
        }
         
        /// <summary>
        /// Transformer ends at the base voltage. This is essential for PU calculation.
        /// </summary>
        public TransformerEnd[]? TransformerEnds
        {
            get => ObjectData.GetAssoc1ToM<TransformerEnd>(nameof(TransformerEnds));
        }
         
        public void AddToTransformerEnds(TransformerEnd value)
        {
            ObjectData.AddAssoc1ToM(nameof(TransformerEnds), value);
        }
         
        public void RemoveFromTransformerEnds(TransformerEnd value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(TransformerEnds), value);
        }
         
        public void RemoveAllFromTransformerEnds()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(TransformerEnds));
        }
         
        /// <summary>
        /// The voltage levels having this base voltage.
        /// </summary>
        public VoltageLevel[]? VoltageLevel
        {
            get => ObjectData.GetAssoc1ToM<VoltageLevel>(nameof(VoltageLevel));
        }
         
        public void AddToVoltageLevel(VoltageLevel value)
        {
            ObjectData.AddAssoc1ToM(nameof(VoltageLevel), value);
        }
         
        public void RemoveFromVoltageLevel(VoltageLevel value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(VoltageLevel), value);
        }
         
        public void RemoveAllFromVoltageLevel()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(VoltageLevel));
        }
         
    }
     
    /// <summary>
    /// A collection of power system resources (within a given substation) including
    /// conducting equipment, protection relays, measurements, and telemetry. A
    /// bay typically represents a physical grouping related to modularization
    /// of equipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Bay")]
    public partial class Bay : EquipmentContainer, IModelObject
    {
        public Bay(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The voltage level containing this bay.
        /// </summary>
        public VoltageLevel? VoltageLevel
        {
            get => ObjectData.GetAssoc1To1<VoltageLevel>(nameof(VoltageLevel));
            set => ObjectData.SetAssoc1To1(nameof(VoltageLevel), value);
        }
         
    }
     
    /// <summary>
    /// A mechanical switching device capable of making, carrying, and breaking
    /// currents under normal circuit conditions and also making, carrying for
    /// a specified time, and breaking currents under specified abnormal circuit
    /// conditions e.g. those of short circuit.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Breaker")]
    public partial class Breaker : ProtectedSwitch, IModelObject
    {
        public Breaker(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// </summary>
    [CimClass("http://gost.ru/2019/schema-cim01#BusArrangement")]
    public partial class BusArrangement : AuxiliaryEquipment, IModelObject
    {
        public BusArrangement(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A conductor, or group of conductors, with negligible impedance, that serve
    /// to connect other conducting equipment within a single substation.
    /// Voltage measurements are typically obtained from voltage transformers that
    /// are connected to busbar sections. A bus bar section may have many physical
    /// terminals but for analysis is modelled with exactly one logical terminal.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#BusbarSection")]
    public partial class BusbarSection : Connector, IModelObject
    {
        public BusbarSection(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A prime mover that is typically fuelled by gas or light oil.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CombustionTurbine")]
    public partial class CombustionTurbine : PrimeMover, IModelObject
    {
        public CombustionTurbine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// A combustion turbine may have a heat recovery boiler for making steam.
        /// </summary>
        public HeatRecoveryBoiler? HeatRecoveryBoiler
        {
            get => ObjectData.GetAssoc1To1<HeatRecoveryBoiler>(nameof(HeatRecoveryBoiler));
            set => ObjectData.SetAssoc1To1(nameof(HeatRecoveryBoiler), value);
        }
         
    }
     
    /// <summary>
    /// The parts of the AC power system that are designed to carry current or
    /// that are conductively connected through terminals.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ConductingEquipment")]
    public partial class ConductingEquipment : Equipment, IModelObject
    {
        public ConductingEquipment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Base voltage of this conducting equipment. Use only when there is no voltage
        /// level container used and only one base voltage applies. For example, not
        /// used for transformers.
        /// </summary>
        public BaseVoltage? BaseVoltage
        {
            get => ObjectData.GetAssoc1To1<BaseVoltage>(nameof(BaseVoltage));
            set => ObjectData.SetAssoc1To1(nameof(BaseVoltage), value);
        }
         
        /// <summary>
        /// Conducting equipment have terminals that may be connected to other conducting
        /// equipment terminals via connectivity nodes or topological nodes.
        /// </summary>
        public Terminal[]? Terminals
        {
            get => ObjectData.GetAssoc1ToM<Terminal>(nameof(Terminals));
        }
         
        public void AddToTerminals(Terminal value)
        {
            ObjectData.AddAssoc1ToM(nameof(Terminals), value);
        }
         
        public void RemoveFromTerminals(Terminal value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Terminals), value);
        }
         
        public void RemoveAllFromTerminals()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Terminals));
        }
         
    }
     
    /// <summary>
    /// Combination of conducting material with consistent electrical characteristics,
    /// building a single electrical system, used to carry current between points
    /// in the power system.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Conductor")]
    public partial class Conductor : ConductingEquipment, IModelObject
    {
        public Conductor(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Connectivity nodes are points where terminals of AC conducting equipment
    /// are connected together with zero impedance.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ConnectivityNode")]
    public partial class ConnectivityNode : IdentifiedObject, IModelObject
    {
        public ConnectivityNode(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Container of this connectivity node.
        /// </summary>
        public ConnectivityNodeContainer? ConnectivityNodeContainer
        {
            get => ObjectData.GetAssoc1To1<ConnectivityNodeContainer>(nameof(ConnectivityNodeContainer));
            set => ObjectData.SetAssoc1To1(nameof(ConnectivityNodeContainer), value);
        }
         
        /// <summary>
        /// Terminals interconnected with zero impedance at a this connectivity node.
        /// </summary>
        public Terminal[]? Terminals
        {
            get => ObjectData.GetAssoc1ToM<Terminal>(nameof(Terminals));
        }
         
        public void AddToTerminals(Terminal value)
        {
            ObjectData.AddAssoc1ToM(nameof(Terminals), value);
        }
         
        public void RemoveFromTerminals(Terminal value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Terminals), value);
        }
         
        public void RemoveAllFromTerminals()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Terminals));
        }
         
    }
     
    /// <summary>
    /// A base class for all objects that may contain connectivity nodes or topological
    /// nodes.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ConnectivityNodeContainer")]
    public partial class ConnectivityNodeContainer : PowerSystemResource, IModelObject
    {
        public ConnectivityNodeContainer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Connectivity nodes which belong to this connectivity node container.
        /// </summary>
        public ConnectivityNode[]? ConnectivityNodes
        {
            get => ObjectData.GetAssoc1ToM<ConnectivityNode>(nameof(ConnectivityNodes));
        }
         
        public void AddToConnectivityNodes(ConnectivityNode value)
        {
            ObjectData.AddAssoc1ToM(nameof(ConnectivityNodes), value);
        }
         
        public void RemoveFromConnectivityNodes(ConnectivityNode value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ConnectivityNodes), value);
        }
         
        public void RemoveAllFromConnectivityNodes()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ConnectivityNodes));
        }
         
    }
     
    /// <summary>
    /// A conductor, or group of conductors, with negligible impedance, that serve
    /// to connect other conducting equipment within a single substation and are
    /// modelled with a single logical terminal.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Connector")]
    public partial class Connector : ConductingEquipment, IModelObject
    {
        public Connector(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Coordinate reference system.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CoordinateSystem")]
    public partial class CoordinateSystem : IdentifiedObject, IModelObject
    {
        public CoordinateSystem(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All locations described with position points in this coordinate system.
        /// </summary>
        public Location[]? Locations
        {
            get => ObjectData.GetAssoc1ToM<Location>(nameof(Locations));
        }
         
        public void AddToLocations(Location value)
        {
            ObjectData.AddAssoc1ToM(nameof(Locations), value);
        }
         
        public void RemoveFromLocations(Location value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Locations), value);
        }
         
        public void RemoveAllFromLocations()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Locations));
        }
         
    }
     
    /// <summary>
    /// Instrument transformer used to measure electrical qualities of the circuit
    /// that is being protected and/or monitored. Typically used as current transducer
    /// for the purpose of metering or protection. A typical secondary current
    /// rating would be 5A.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CurrentTransformer")]
    public partial class CurrentTransformer : Sensor, IModelObject
    {
        public CurrentTransformer(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Organisation receiving services from service supplier.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Customer")]
    public partial class Customer : OrganisationRole, IModelObject
    {
        public Customer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All agreements of this customer.
        /// </summary>
        public CustomerAgreement[]? CustomerAgreements
        {
            get => ObjectData.GetAssoc1ToM<CustomerAgreement>(nameof(CustomerAgreements));
        }
         
        public void AddToCustomerAgreements(CustomerAgreement value)
        {
            ObjectData.AddAssoc1ToM(nameof(CustomerAgreements), value);
        }
         
        public void RemoveFromCustomerAgreements(CustomerAgreement value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(CustomerAgreements), value);
        }
         
        public void RemoveAllFromCustomerAgreements()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(CustomerAgreements));
        }
         
        /// <summary>
        /// All end devices of this customer.
        /// </summary>
        public EndDevice[]? EndDevices
        {
            get => ObjectData.GetAssoc1ToM<EndDevice>(nameof(EndDevices));
        }
         
        public void AddToEndDevices(EndDevice value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveFromEndDevices(EndDevice value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveAllFromEndDevices()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDevices));
        }
         
    }
     
    /// <summary>
    /// Agreement between the customer and the service supplier to pay for service
    /// at a specific service location. It records certain billing information
    /// about the type of service provided at the service location and is used
    /// during charge creation to determine the type of service.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#CustomerAgreement")]
    public partial class CustomerAgreement : Agreement, IModelObject
    {
        public CustomerAgreement(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Customer for this agreement.
        /// </summary>
        public Customer? Customer
        {
            get => ObjectData.GetAssoc1To1<Customer>(nameof(Customer));
            set => ObjectData.SetAssoc1To1(nameof(Customer), value);
        }
         
        /// <summary>
        /// All service delivery points regulated by this customer agreement.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// An electrical connection point at a piece of DC conducting equipment. DC
    /// terminals are connected at one physical DC node that may have multiple
    /// DC terminals connected. A DC node is similar to an AC connectivity node.
    /// The model requires that DC connections are distinct from AC connections.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCBaseTerminal")]
    public partial class DCBaseTerminal : ACDCTerminal, IModelObject
    {
        public DCBaseTerminal(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The parts of the DC power system that are designed to carry current or
    /// that are conductively connected through DC terminals.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCConductingEquipment")]
    public partial class DCConductingEquipment : Equipment, IModelObject
    {
        public DCConductingEquipment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// A DC conducting equipment has DC terminals.
        /// </summary>
        public DCTerminal[]? DCTerminals
        {
            get => ObjectData.GetAssoc1ToM<DCTerminal>(nameof(DCTerminals));
        }
         
        public void AddToDCTerminals(DCTerminal value)
        {
            ObjectData.AddAssoc1ToM(nameof(DCTerminals), value);
        }
         
        public void RemoveFromDCTerminals(DCTerminal value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(DCTerminals), value);
        }
         
        public void RemoveAllFromDCTerminals()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(DCTerminals));
        }
         
    }
     
    /// <summary>
    /// A modelling construct to provide a root class for containment of DC as
    /// well as AC equipment. The class differ from the EquipmentContaner for AC
    /// in that it may also contain DCNode-s. Hence it can contain both AC and
    /// DC equipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCEquipmentContainer")]
    public partial class DCEquipmentContainer : EquipmentContainer, IModelObject
    {
        public DCEquipmentContainer(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Overhead lines and/or cables connecting two or more HVDC substations.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCLine")]
    public partial class DCLine : DCEquipmentContainer, IModelObject
    {
        public DCLine(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A wire or combination of wires not insulated from one another, with consistent
    /// electrical characteristics, used to carry direct current between points
    /// in the DC region of the power system.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCLineSegment")]
    public partial class DCLineSegment : DCConductingEquipment, IModelObject
    {
        public DCLineSegment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Capacitance of the DC line segment. Significant for cables only.
        /// </summary>
        public float capacitance
        {
            get => ObjectData.GetAttribute<float>(nameof(capacitance));
            set => ObjectData.SetAttribute<float>(nameof(capacitance), value);
        }
         
        /// <summary>
        /// Inductance of the DC line segment. Negligible compared with DCSeriesDevice
        /// used for smoothing.
        /// </summary>
        public float inductance
        {
            get => ObjectData.GetAttribute<float>(nameof(inductance));
            set => ObjectData.SetAttribute<float>(nameof(inductance), value);
        }
         
        /// <summary>
        /// Segment length for calculating line section capabilities.
        /// </summary>
        public float length
        {
            get => ObjectData.GetAttribute<float>(nameof(length));
            set => ObjectData.SetAttribute<float>(nameof(length), value);
        }
         
        /// <summary>
        /// Resistance of the DC line segment.
        /// </summary>
        public float resistance
        {
            get => ObjectData.GetAttribute<float>(nameof(resistance));
            set => ObjectData.SetAttribute<float>(nameof(resistance), value);
        }
         
    }
     
    /// <summary>
    /// An electrical connection point to generic DC conducting equipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DCTerminal")]
    public partial class DCTerminal : DCBaseTerminal, IModelObject
    {
        public DCTerminal(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// An DC terminal belong to a DC conducting equipment.
        /// </summary>
        public DCConductingEquipment? DCConductingEquipment
        {
            get => ObjectData.GetAssoc1To1<DCConductingEquipment>(nameof(DCConductingEquipment));
            set => ObjectData.SetAssoc1To1(nameof(DCConductingEquipment), value);
        }
         
    }
     
    /// <summary>
    /// A manually operated or motor operated mechanical switching device used
    /// for changing the connections in a circuit, or for isolating a circuit or
    /// equipment from a source of power. It is required to open or close circuits
    /// when negligible current is broken or made.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Disconnector")]
    public partial class Disconnector : Switch, IModelObject
    {
        public Disconnector(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Discrete represents a discrete Measurement, i.e. a Measurement representing
    /// discrete values, e.g. a Breaker position.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Discrete")]
    public partial class Discrete : Measurement, IModelObject
    {
        public Discrete(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Normal value range maximum for any of the MeasurementValue.values. Used
        /// for scaling, e.g. in bar graphs or of telemetered raw values.
        /// </summary>
        public int maxValue
        {
            get => ObjectData.GetAttribute<int>(nameof(maxValue));
            set => ObjectData.SetAttribute<int>(nameof(maxValue), value);
        }
         
        /// <summary>
        /// Normal value range minimum for any of the MeasurementValue.values. Used
        /// for scaling, e.g. in bar graphs or of telemetered raw values.
        /// </summary>
        public int minValue
        {
            get => ObjectData.GetAttribute<int>(nameof(minValue));
            set => ObjectData.SetAttribute<int>(nameof(minValue), value);
        }
         
        /// <summary>
        /// Normal measurement value, e.g., used for percentage calculations.
        /// </summary>
        public int normalValue
        {
            get => ObjectData.GetAttribute<int>(nameof(normalValue));
            set => ObjectData.SetAttribute<int>(nameof(normalValue), value);
        }
         
        /// <summary>
        /// The values connected to this measurement.
        /// </summary>
        public DiscreteValue[]? DiscreteValues
        {
            get => ObjectData.GetAssoc1ToM<DiscreteValue>(nameof(DiscreteValues));
        }
         
        public void AddToDiscreteValues(DiscreteValue value)
        {
            ObjectData.AddAssoc1ToM(nameof(DiscreteValues), value);
        }
         
        public void RemoveFromDiscreteValues(DiscreteValue value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(DiscreteValues), value);
        }
         
        public void RemoveAllFromDiscreteValues()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(DiscreteValues));
        }
         
    }
     
    /// <summary>
    /// DiscreteValue represents a discrete MeasurementValue.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DiscreteValue")]
    public partial class DiscreteValue : MeasurementValue, IModelObject
    {
        public DiscreteValue(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The value to supervise.
        /// </summary>
        public int value
        {
            get => ObjectData.GetAttribute<int>(nameof(value));
            set => ObjectData.SetAttribute<int>(nameof(value), value);
        }
         
        /// <summary>
        /// Measurement to which this value is connected.
        /// </summary>
        public Discrete? Discrete
        {
            get => ObjectData.GetAssoc1To1<Discrete>(nameof(Discrete));
            set => ObjectData.SetAssoc1To1(nameof(Discrete), value);
        }
         
    }
     
    /// <summary>
    /// Parent class for different groupings of information collected and managed
    /// as a part of a business process. It will frequently contain references
    /// to other objects, such as assets, people and power system resources.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Document")]
    public partial class Document : IdentifiedObject, IModelObject
    {
        public Document(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Date and time that this document was created.
        /// </summary>
        public object createdDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(createdDateTime));
            set => ObjectData.SetAttribute<object>(nameof(createdDateTime), value);
        }
         
        /// <summary>
        /// Date and time this document was last modified. Documents may potentially
        /// be modified many times during their lifetime.
        /// </summary>
        public object lastModifiedDateTime
        {
            get => ObjectData.GetAttribute<object>(nameof(lastModifiedDateTime));
            set => ObjectData.SetAttribute<object>(nameof(lastModifiedDateTime), value);
        }
         
        /// <summary>
        /// Electronic address.
        /// </summary>
        public ElectronicAddress electronicAddress
        {
            get => ObjectData.GetAttribute<ElectronicAddress>(nameof(electronicAddress));
            set => ObjectData.SetAttribute<ElectronicAddress>(nameof(electronicAddress), value);
        }
         
    }
     
    /// <summary>
    /// Drum boiler.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#DrumBoiler")]
    public partial class DrumBoiler : FossilSteamSupply, IModelObject
    {
        public DrumBoiler(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Electronic address information.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ElectronicAddress")]
    public partial class ElectronicAddress : ModelObject, IModelObject
    {
        public ElectronicAddress(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Primary email address.
        /// </summary>
        public string email1
        {
            get => ObjectData.GetAttribute<string>(nameof(email1));
            set => ObjectData.SetAttribute<string>(nameof(email1), value);
        }
         
        /// <summary>
        /// Alternate email address.
        /// </summary>
        public string email2
        {
            get => ObjectData.GetAttribute<string>(nameof(email2));
            set => ObjectData.SetAttribute<string>(nameof(email2), value);
        }
         
        /// <summary>
        /// Address on local area network.
        /// </summary>
        public string lan
        {
            get => ObjectData.GetAttribute<string>(nameof(lan));
            set => ObjectData.SetAttribute<string>(nameof(lan), value);
        }
         
        /// <summary>
        /// MAC (Media Access Control) address.
        /// </summary>
        public string mac
        {
            get => ObjectData.GetAttribute<string>(nameof(mac));
            set => ObjectData.SetAttribute<string>(nameof(mac), value);
        }
         
        /// <summary>
        /// Password needed to log in.
        /// </summary>
        public string password
        {
            get => ObjectData.GetAttribute<string>(nameof(password));
            set => ObjectData.SetAttribute<string>(nameof(password), value);
        }
         
        /// <summary>
        /// Radio address.
        /// </summary>
        public string radio
        {
            get => ObjectData.GetAttribute<string>(nameof(radio));
            set => ObjectData.SetAttribute<string>(nameof(radio), value);
        }
         
        /// <summary>
        /// User ID needed to log in, which can be for an individual person, an organisation,
        /// a location, etc.
        /// </summary>
        public string userID
        {
            get => ObjectData.GetAttribute<string>(nameof(userID));
            set => ObjectData.SetAttribute<string>(nameof(userID), value);
        }
         
        /// <summary>
        /// World wide web address.
        /// </summary>
        public string web
        {
            get => ObjectData.GetAttribute<string>(nameof(web));
            set => ObjectData.SetAttribute<string>(nameof(web), value);
        }
         
    }
     
    /// <summary>
    /// Asset container that performs one or more end device functions. One type
    /// of end device is a meter which can perform metering, load management, connect/disconnect,
    /// accounting functions, etc. Some end devices, such as ones monitoring and
    /// controlling air conditioners, refrigerators, pool pumps may be connected
    /// to a meter. All end devices may have communication capability defined by
    /// the associated communication function(s). An end device may be owned by
    /// a consumer, a service provider, utility or otherwise.
    /// There may be a related end device function that identifies a sensor or
    /// control point within a metering application or communications systems (e.g.,
    /// water, gas, electricity).
    /// Some devices may use an optical port that conforms to the ANSI C12.18 standard
    /// for communications.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EndDevice")]
    public partial class EndDevice : AssetContainer, IModelObject
    {
        public EndDevice(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Time zone offset relative to GMT for the location of this end device.
        /// </summary>
        public float timeZoneOffset
        {
            get => ObjectData.GetAttribute<float>(nameof(timeZoneOffset));
            set => ObjectData.SetAttribute<float>(nameof(timeZoneOffset), value);
        }
         
        /// <summary>
        /// Customer owning this end device.
        /// </summary>
        public Customer? Customer
        {
            get => ObjectData.GetAssoc1To1<Customer>(nameof(Customer));
            set => ObjectData.SetAssoc1To1(nameof(Customer), value);
        }
         
        /// <summary>
        /// Usage point to which this end device belongs.
        /// </summary>
        public UsagePoint? UsagePoint
        {
            get => ObjectData.GetAssoc1To1<UsagePoint>(nameof(UsagePoint));
            set => ObjectData.SetAssoc1To1(nameof(UsagePoint), value);
        }
         
    }
     
    /// <summary>
    /// Generic user of energy - a point of consumption on the power system model.
    /// EnergyConsumer.pfixed, .qfixed, .pfixedPct and .qfixedPct have meaning
    /// only if there is no LoadResponseCharacteristic associated with EnergyConsumer
    /// or if LoadResponseCharacteristic.exponentModel is set to False.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EnergyConsumer")]
    public partial class EnergyConsumer : ModelObject, IModelObject
    {
        public EnergyConsumer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Number of individual customers represented by this demand.
        /// </summary>
        public int customerCount
        {
            get => ObjectData.GetAttribute<int>(nameof(customerCount));
            set => ObjectData.SetAttribute<int>(nameof(customerCount), value);
        }
         
    }
     
    /// <summary>
    /// A generic equivalent for an energy supplier on a transmission or distribution
    /// voltage level.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EnergySource")]
    public partial class EnergySource : ModelObject, IModelObject
    {
        public EnergySource(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The parts of a power system that are physical devices, electronic or mechanical.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Equipment")]
    public partial class Equipment : PowerSystemResource, IModelObject
    {
        public Equipment(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Specifies the availability of the equipment under normal operating conditions.
        /// True means the equipment is available for topology processing, which determines
        /// if the equipment is energized or not. False means that the equipment is
        /// treated by network applications as if it is not in the model.
        /// </summary>
        public bool normallyInService
        {
            get => ObjectData.GetAttribute<bool>(nameof(normallyInService));
            set => ObjectData.SetAttribute<bool>(nameof(normallyInService), value);
        }
         
        /// <summary>
        /// Additional equipment container beyond the primary equipment container.
        /// The equipment is contained in another equipment container, but also grouped
        /// with this equipment container.
        /// </summary>
        public EquipmentContainer[]? AdditionalEquipmentContainer
        {
            get => ObjectData.GetAssoc1ToM<EquipmentContainer>(nameof(AdditionalEquipmentContainer));
        }
         
        public void AddToAdditionalEquipmentContainer(EquipmentContainer value)
        {
            ObjectData.AddAssoc1ToM(nameof(AdditionalEquipmentContainer), value);
        }
         
        public void RemoveFromAdditionalEquipmentContainer(EquipmentContainer value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AdditionalEquipmentContainer), value);
        }
         
        public void RemoveAllFromAdditionalEquipmentContainer()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AdditionalEquipmentContainer));
        }
         
        /// <summary>
        /// Container of this equipment.
        /// </summary>
        public EquipmentContainer? EquipmentContainer
        {
            get => ObjectData.GetAssoc1To1<EquipmentContainer>(nameof(EquipmentContainer));
            set => ObjectData.SetAssoc1To1(nameof(EquipmentContainer), value);
        }
         
        /// <summary>
        /// All usage points connected to the electrical grid through this equipment.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// A modelling construct to provide a root class for containing equipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#EquipmentContainer")]
    public partial class EquipmentContainer : ConnectivityNodeContainer, IModelObject
    {
        public EquipmentContainer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The additonal contained equipment. The equipment belong to the equipment
        /// container. The equipment is contained in another equipment container, but
        /// also grouped with this equipment container. Examples include when a switch
        /// contained in a substation is also desired to be grouped with a line contianer
        /// or when a switch is included in a secondary substation and also grouped
        /// in a feeder.
        /// </summary>
        public Equipment[]? AdditionalGroupedEquipment
        {
            get => ObjectData.GetAssoc1ToM<Equipment>(nameof(AdditionalGroupedEquipment));
        }
         
        public void AddToAdditionalGroupedEquipment(Equipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(AdditionalGroupedEquipment), value);
        }
         
        public void RemoveFromAdditionalGroupedEquipment(Equipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AdditionalGroupedEquipment), value);
        }
         
        public void RemoveAllFromAdditionalGroupedEquipment()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AdditionalGroupedEquipment));
        }
         
        /// <summary>
        /// Contained equipment.
        /// </summary>
        public Equipment[]? Equipments
        {
            get => ObjectData.GetAssoc1ToM<Equipment>(nameof(Equipments));
        }
         
        public void AddToEquipments(Equipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveFromEquipments(Equipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveAllFromEquipments()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Equipments));
        }
         
    }
     
    /// <summary>
    /// Fossil fuelled boiler (e.g., coal, oil, gas).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#FossilSteamSupply")]
    public partial class FossilSteamSupply : SteamSupply, IModelObject
    {
        public FossilSteamSupply(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// An overcurrent protective device with a circuit opening fusible part that
    /// is heated and severed by the passage of overcurrent through it. A fuse
    /// is considered a switching device because it breaks current.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Fuse")]
    public partial class Fuse : Switch, IModelObject
    {
        public Fuse(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A single or set of synchronous machines for converting mechanical power
    /// into alternating-current power. For example, individual machines within
    /// a set may be defined for scheduling purposes while a single control signal
    /// is derived for the set. In this case there would be a GeneratingUnit for
    /// each member of the set and an additional GeneratingUnit corresponding to
    /// the set.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#GeneratingUnit")]
    public partial class GeneratingUnit : Equipment, IModelObject
    {
        public GeneratingUnit(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// A synchronous machine may operate as a generator and as such becomes a
        /// member of a generating unit.
        /// </summary>
        public RotatingMachine[]? RotatingMachine
        {
            get => ObjectData.GetAssoc1ToM<RotatingMachine>(nameof(RotatingMachine));
        }
         
        public void AddToRotatingMachine(RotatingMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(RotatingMachine), value);
        }
         
        public void RemoveFromRotatingMachine(RotatingMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(RotatingMachine), value);
        }
         
        public void RemoveAllFromRotatingMachine()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(RotatingMachine));
        }
         
    }
     
    /// <summary>
    /// A geographical region of a power system network model.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#GeographicalRegion")]
    public partial class GeographicalRegion : IdentifiedObject, IModelObject
    {
        public GeographicalRegion(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All sub-geographical regions within this geographical region.
        /// </summary>
        public SubGeographicalRegion[]? Regions
        {
            get => ObjectData.GetAssoc1ToM<SubGeographicalRegion>(nameof(Regions));
        }
         
        public void AddToRegions(SubGeographicalRegion value)
        {
            ObjectData.AddAssoc1ToM(nameof(Regions), value);
        }
         
        public void RemoveFromRegions(SubGeographicalRegion value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Regions), value);
        }
         
        public void RemoveAllFromRegions()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Regions));
        }
         
    }
     
    /// <summary>
    /// A manually operated or motor operated mechanical switching device used
    /// for isolating a circuit or equipment from ground.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#GroundDisconnector")]
    public partial class GroundDisconnector : Switch, IModelObject
    {
        public GroundDisconnector(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The heat recovery system associated with combustion turbines in order to
    /// produce steam for combined cycle plants.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HeatRecoveryBoiler")]
    public partial class HeatRecoveryBoiler : FossilSteamSupply, IModelObject
    {
        public HeatRecoveryBoiler(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// A combustion turbine may have a heat recovery boiler for making steam.
        /// </summary>
        public CombustionTurbine[]? CombustionTurbines
        {
            get => ObjectData.GetAssoc1ToM<CombustionTurbine>(nameof(CombustionTurbines));
        }
         
        public void AddToCombustionTurbines(CombustionTurbine value)
        {
            ObjectData.AddAssoc1ToM(nameof(CombustionTurbines), value);
        }
         
        public void RemoveFromCombustionTurbines(CombustionTurbine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(CombustionTurbines), value);
        }
         
        public void RemoveAllFromCombustionTurbines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(CombustionTurbines));
        }
         
    }
     
    /// <summary>
    /// A generating unit whose prime mover is a hydraulic turbine (e.g., Francis,
    /// Pelton, Kaplan).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroGeneratingUnit")]
    public partial class HydroGeneratingUnit : GeneratingUnit, IModelObject
    {
        public HydroGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A water driven prime mover. Typical turbine types are: Francis, Kaplan,
    /// and Pelton.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#HydroTurbine")]
    public partial class HydroTurbine : PrimeMover, IModelObject
    {
        public HydroTurbine(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The class describe a measurement or control value. The purpose is to enable
    /// having attributes and associations common for measurement and control.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#IOPoint")]
    public partial class IOPoint : IdentifiedObject, IModelObject
    {
        public IOPoint(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// This is a root class to provide common identification for all classes needing
    /// identification and naming attributes.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#IdentifiedObject")]
    public partial class IdentifiedObject : ModelObject, IModelObject
    {
        public IdentifiedObject(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Master resource identifier issued by a model authority. The mRID is unique
        /// within an exchange context. Global uniqueness is easily achieved by using
        /// a UUID, as specified in RFC 4122, for the mRID. The use of UUID is strongly
        /// recommended.
        /// For CIMXML data files in RDF syntax conforming to IEC 61970-552, the mRID
        /// is mapped to rdf:ID or rdf:about attributes that identify CIM object elements.
        /// </summary>
        public string mRID
        {
            get => ObjectData.GetAttribute<string>(nameof(mRID));
            set => ObjectData.SetAttribute<string>(nameof(mRID), value);
        }
         
        /// <summary>
        /// The aliasName is free text human readable name of the object alternative
        /// to IdentifiedObject.name. It may be non unique and may not correlate to
        /// a naming hierarchy.
        /// The attribute aliasName is retained because of backwards compatibility
        /// between CIM relases. It is however recommended to replace aliasName with
        /// the Name class as aliasName is planned for retirement at a future time.
        /// </summary>
        public string aliasName
        {
            get => ObjectData.GetAttribute<string>(nameof(aliasName));
            set => ObjectData.SetAttribute<string>(nameof(aliasName), value);
        }
         
        /// <summary>
        /// The description is a free human readable text describing or naming the
        /// object. It may be non unique and may not correlate to a naming hierarchy.
        /// </summary>
        public string description
        {
            get => ObjectData.GetAttribute<string>(nameof(description));
            set => ObjectData.SetAttribute<string>(nameof(description), value);
        }
         
        /// <summary>
        /// The name is any free human readable and possibly non unique text naming
        /// the object.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// All names of this identified object.
        /// </summary>
        public Name[]? Names
        {
            get => ObjectData.GetAssoc1ToM<Name>(nameof(Names));
        }
         
        public void AddToNames(Name value)
        {
            ObjectData.AddAssoc1ToM(nameof(Names), value);
        }
         
        public void RemoveFromNames(Name value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Names), value);
        }
         
        public void RemoveAllFromNames()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Names));
        }
         
        /// <summary>
        /// </summary>
        public OrganisationRole[]? OrganisationRoles
        {
            get => ObjectData.GetAssoc1ToM<OrganisationRole>(nameof(OrganisationRoles));
        }
         
        public void AddToOrganisationRoles(OrganisationRole value)
        {
            ObjectData.AddAssoc1ToM(nameof(OrganisationRoles), value);
        }
         
        public void RemoveFromOrganisationRoles(OrganisationRole value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(OrganisationRoles), value);
        }
         
        public void RemoveAllFromOrganisationRoles()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(OrganisationRoles));
        }
         
    }
     
    /// <summary>
    /// A short section of conductor with negligible impedance which can be manually
    /// removed and replaced if the circuit is de-energized. Note that zero-impedance
    /// branches can potentially be modelled by other equipment types.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Jumper")]
    public partial class Jumper : Switch, IModelObject
    {
        public Jumper(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Contains equipment beyond a substation belonging to a power transmission
    /// line.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Line")]
    public partial class Line : EquipmentContainer, IModelObject
    {
        public Line(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The sub-geographical region of the line.
        /// </summary>
        public SubGeographicalRegion? Region
        {
            get => ObjectData.GetAssoc1To1<SubGeographicalRegion>(nameof(Region));
            set => ObjectData.SetAssoc1To1(nameof(Region), value);
        }
         
    }
     
    /// <summary>
    /// A linear shunt compensator has banks or sections with equal admittance
    /// values.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#LinearShuntCompensator")]
    public partial class LinearShuntCompensator : ShuntCompensator, IModelObject
    {
        public LinearShuntCompensator(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A mechanical switching device capable of making, carrying, and breaking
    /// currents under normal operating conditions.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#LoadBreakSwitch")]
    public partial class LoadBreakSwitch : ProtectedSwitch, IModelObject
    {
        public LoadBreakSwitch(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The place, scene, or point of something where someone or something has
    /// been, is, and/or will be at a given moment in time. It can be defined with
    /// one or more position points (coordinates) in a given coordinate system.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Location")]
    public partial class Location : IdentifiedObject, IModelObject
    {
        public Location(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All assets at this location.
        /// </summary>
        public Asset[]? Assets
        {
            get => ObjectData.GetAssoc1ToM<Asset>(nameof(Assets));
        }
         
        public void AddToAssets(Asset value)
        {
            ObjectData.AddAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveFromAssets(Asset value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveAllFromAssets()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Assets));
        }
         
        /// <summary>
        /// Coordinate system used to describe position points of this location.
        /// </summary>
        public CoordinateSystem? CoordinateSystem
        {
            get => ObjectData.GetAssoc1To1<CoordinateSystem>(nameof(CoordinateSystem));
            set => ObjectData.SetAssoc1To1(nameof(CoordinateSystem), value);
        }
         
        /// <summary>
        /// Electronic address.
        /// </summary>
        public ElectronicAddress electronicAddress
        {
            get => ObjectData.GetAttribute<ElectronicAddress>(nameof(electronicAddress));
            set => ObjectData.SetAttribute<ElectronicAddress>(nameof(electronicAddress), value);
        }
         
        /// <summary>
        /// Main address of the location.
        /// </summary>
        public StreetAddress mainAddress
        {
            get => ObjectData.GetAttribute<StreetAddress>(nameof(mainAddress));
            set => ObjectData.SetAttribute<StreetAddress>(nameof(mainAddress), value);
        }
         
        /// <summary>
        /// Phone number.
        /// </summary>
        public TelephoneNumber phone1
        {
            get => ObjectData.GetAttribute<TelephoneNumber>(nameof(phone1));
            set => ObjectData.SetAttribute<TelephoneNumber>(nameof(phone1), value);
        }
         
        /// <summary>
        /// Additional phone number.
        /// </summary>
        public TelephoneNumber phone2
        {
            get => ObjectData.GetAttribute<TelephoneNumber>(nameof(phone2));
            set => ObjectData.SetAttribute<TelephoneNumber>(nameof(phone2), value);
        }
         
        /// <summary>
        /// Sequence of position points describing this location, expressed in coordinate
        /// system 'Location.CoordinateSystem'.
        /// </summary>
        public PositionPoint[]? PositionPoints
        {
            get => ObjectData.GetAssoc1ToM<PositionPoint>(nameof(PositionPoints));
        }
         
        public void AddToPositionPoints(PositionPoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(PositionPoints), value);
        }
         
        public void RemoveFromPositionPoints(PositionPoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PositionPoints), value);
        }
         
        public void RemoveAllFromPositionPoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PositionPoints));
        }
         
        /// <summary>
        /// All power system resources at this location.
        /// </summary>
        public PowerSystemResource[]? PowerSystemResources
        {
            get => ObjectData.GetAssoc1ToM<PowerSystemResource>(nameof(PowerSystemResources));
        }
         
        public void AddToPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveFromPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveAllFromPowerSystemResources()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerSystemResources));
        }
         
        /// <summary>
        /// Secondary address of the location. For example, PO Box address may have
        /// different ZIP code than that in the 'mainAddress'.
        /// </summary>
        public StreetAddress secondaryAddress
        {
            get => ObjectData.GetAttribute<StreetAddress>(nameof(secondaryAddress));
            set => ObjectData.SetAttribute<StreetAddress>(nameof(secondaryAddress), value);
        }
         
    }
     
    /// <summary>
    /// A Measurement represents any measured, calculated or non-measured non-calculated
    /// quantity. Any piece of equipment may contain Measurements, e.g. a substation
    /// may have temperature measurements and door open indications, a transformer
    /// may have oil temperature and tank pressure measurements, a bay may contain
    /// a number of power flow measurements and a Breaker may contain a switch
    /// status measurement.
    /// The PSR - Measurement association is intended to capture this use of Measurement
    /// and is included in the naming hierarchy based on EquipmentContainer. The
    /// naming hierarchy typically has Measurements as leaves, e.g. Substation-VoltageLevel-Bay-Switch-Measurement.
    /// Some Measurements represent quantities related to a particular sensor location
    /// in the network, e.g. a voltage transformer (VT) or potential transformer
    /// (PT) at a busbar or a current transformer (CT) at the bar between a breaker
    /// and an isolator. The sensing position is not captured in the PSR - Measurement
    /// association. Instead it is captured by the Measurement - Terminal association
    /// that is used to define the sensing location in the network topology. The
    /// location is defined by the connection of the Terminal to ConductingEquipment.
    /// If both a Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
    /// the associated Terminal should belong to that ConductingEquipment instance.
    /// When the sensor location is needed both Measurement-PSR and Measurement-Terminal
    /// are used. The Measurement-Terminal association is never used alone.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Measurement")]
    public partial class Measurement : IdentifiedObject, IModelObject
    {
        public Measurement(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Specifies the type of measurement. For example, this specifies if the measurement
        /// represents an indoor temperature, outdoor temperature, bus voltage, line
        /// flow, etc.
        /// When the measurementType is set to "Specialization", the type of Measurement
        /// is defined in more detail by the specialized class which inherits from
        /// Measurement.
        /// </summary>
        public string measurementType
        {
            get => ObjectData.GetAttribute<string>(nameof(measurementType));
            set => ObjectData.SetAttribute<string>(nameof(measurementType), value);
        }
         
        /// <summary>
        /// Indicates to which phases the measurement applies and avoids the need to
        /// use 'measurementType' to also encode phase information (which would explode
        /// the types). The phase information in Measurement, along with 'measurementType'
        /// and 'phases' uniquely defines a Measurement for a device, based on normal
        /// network phase. Their meaning will not change when the computed energizing
        /// phasing is changed due to jumpers or other reasons.
        /// If the attribute is missing three phases (ABC) shall be assumed.
        /// </summary>
        public PhaseCode phases
        {
            get => ObjectData.GetAttribute<PhaseCode>(nameof(phases));
            set => ObjectData.SetAttribute<PhaseCode>(nameof(phases), value);
        }
         
        /// <summary>
        /// The unit multiplier of the measured quantity.
        /// </summary>
        public UnitMultiplier unitMultiplier
        {
            get => ObjectData.GetAttribute<UnitMultiplier>(nameof(unitMultiplier));
            set => ObjectData.SetAttribute<UnitMultiplier>(nameof(unitMultiplier), value);
        }
         
        /// <summary>
        /// The unit of measure of the measured quantity.
        /// </summary>
        public UnitSymbol unitSymbol
        {
            get => ObjectData.GetAttribute<UnitSymbol>(nameof(unitSymbol));
            set => ObjectData.SetAttribute<UnitSymbol>(nameof(unitSymbol), value);
        }
         
        /// <summary>
        /// The power system resource that contains the measurement.
        /// </summary>
        public PowerSystemResource? PowerSystemResource
        {
            get => ObjectData.GetAssoc1To1<PowerSystemResource>(nameof(PowerSystemResource));
            set => ObjectData.SetAssoc1To1(nameof(PowerSystemResource), value);
        }
         
        /// <summary>
        /// One or more measurements may be associated with a terminal in the network.
        /// </summary>
        public ACDCTerminal? Terminal
        {
            get => ObjectData.GetAssoc1To1<ACDCTerminal>(nameof(Terminal));
            set => ObjectData.SetAssoc1To1(nameof(Terminal), value);
        }
         
    }
     
    /// <summary>
    /// The current state for a measurement. A state value is an instance of a
    /// measurement from a specific source. Measurements can be associated with
    /// many state values, each representing a different source for the measurement.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#MeasurementValue")]
    public partial class MeasurementValue : IOPoint, IModelObject
    {
        public MeasurementValue(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The time when the value was last updated.
        /// </summary>
        public object timeStamp
        {
            get => ObjectData.GetAttribute<object>(nameof(timeStamp));
            set => ObjectData.SetAttribute<object>(nameof(timeStamp), value);
        }
         
    }
     
    /// <summary>
    /// Physical asset that performs the metering role of the usage point. Used
    /// for measuring consumption and detection of events.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Meter")]
    public partial class Meter : EndDevice, IModelObject
    {
        public Meter(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The Name class provides the means to define any number of human readable
    /// names for an object. A name is <b>not</b> to be used for defining inter-object
    /// relationships. For inter-object relationships instead use the object identification
    /// 'mRID'.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Name")]
    public partial class Name : ModelObject, IModelObject
    {
        public Name(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Any free text that name the object.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// Identified object that this name designates.
        /// </summary>
        public IdentifiedObject? IdentifiedObject
        {
            get => ObjectData.GetAssoc1To1<IdentifiedObject>(nameof(IdentifiedObject));
            set => ObjectData.SetAssoc1To1(nameof(IdentifiedObject), value);
        }
         
        /// <summary>
        /// Type of this name.
        /// </summary>
        public NameType? NameType
        {
            get => ObjectData.GetAssoc1To1<NameType>(nameof(NameType));
            set => ObjectData.SetAssoc1To1(nameof(NameType), value);
        }
         
    }
     
    /// <summary>
    /// Type of name. Possible values for attribute 'name' are implementation dependent
    /// but standard profiles may specify types. An enterprise may have multiple
    /// IT systems each having its own local name for the same object, e.g. a planning
    /// system may have different names from an EMS. An object may also have different
    /// names within the same IT system, e.g. localName as defined in CIM version
    /// 14. The definition from CIM14 is:
    /// The localName is a human readable name of the object. It is a free text
    /// name local to a node in a naming hierarchy similar to a file directory
    /// structure. A power system related naming hierarchy may be: Substation,
    /// VoltageLevel, Equipment etc. Children of the same parent in such a hierarchy
    /// have names that typically are unique among them.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#NameType")]
    public partial class NameType : ModelObject, IModelObject
    {
        public NameType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Name of the name type.
        /// </summary>
        public string name
        {
            get => ObjectData.GetAttribute<string>(nameof(name));
            set => ObjectData.SetAttribute<string>(nameof(name), value);
        }
         
        /// <summary>
        /// All names of this type.
        /// </summary>
        public Name[]? Names
        {
            get => ObjectData.GetAssoc1ToM<Name>(nameof(Names));
        }
         
        public void AddToNames(Name value)
        {
            ObjectData.AddAssoc1ToM(nameof(Names), value);
        }
         
        public void RemoveFromNames(Name value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Names), value);
        }
         
        public void RemoveAllFromNames()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Names));
        }
         
    }
     
    /// <summary>
    /// A non linear shunt compensator has bank or section admittance values that
    /// differ. The attributes g, b, g0 and b0 of the associated NonlinearShuntCompensatorPoint
    /// describe the total conductance and admittance of a NonlinearShuntCompensatorPoint
    /// at a section number specified by NonlinearShuntCompensatorPoint.sectionNumber.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#NonlinearShuntCompensator")]
    public partial class NonlinearShuntCompensator : ShuntCompensator, IModelObject
    {
        public NonlinearShuntCompensator(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A nuclear generating unit.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#NuclearGeneratingUnit")]
    public partial class NuclearGeneratingUnit : GeneratingUnit, IModelObject
    {
        public NuclearGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Organisation that might have roles as utility, contractor, supplier, manufacturer,
    /// customer, etc.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Organisation")]
    public partial class Organisation : IdentifiedObject, IModelObject
    {
        public Organisation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public Organisation[]? ChildOrganisations
        {
            get => ObjectData.GetAssoc1ToM<Organisation>(nameof(ChildOrganisations));
        }
         
        public void AddToChildOrganisations(Organisation value)
        {
            ObjectData.AddAssoc1ToM(nameof(ChildOrganisations), value);
        }
         
        public void RemoveFromChildOrganisations(Organisation value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(ChildOrganisations), value);
        }
         
        public void RemoveAllFromChildOrganisations()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(ChildOrganisations));
        }
         
        /// <summary>
        /// </summary>
        public Organisation? ParentOrganisation
        {
            get => ObjectData.GetAssoc1To1<Organisation>(nameof(ParentOrganisation));
            set => ObjectData.SetAssoc1To1(nameof(ParentOrganisation), value);
        }
         
        /// <summary>
        /// All roles of this organisation.
        /// </summary>
        public OrganisationRole[]? Roles
        {
            get => ObjectData.GetAssoc1ToM<OrganisationRole>(nameof(Roles));
        }
         
        public void AddToRoles(OrganisationRole value)
        {
            ObjectData.AddAssoc1ToM(nameof(Roles), value);
        }
         
        public void RemoveFromRoles(OrganisationRole value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Roles), value);
        }
         
        public void RemoveAllFromRoles()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Roles));
        }
         
    }
     
    /// <summary>
    /// Identifies a way in which an organisation may participate in the utility
    /// enterprise (e.g., customer, manufacturer, etc).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#OrganisationRole")]
    public partial class OrganisationRole : IdentifiedObject, IModelObject
    {
        public OrganisationRole(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public IdentifiedObject[]? Objects
        {
            get => ObjectData.GetAssoc1ToM<IdentifiedObject>(nameof(Objects));
        }
         
        public void AddToObjects(IdentifiedObject value)
        {
            ObjectData.AddAssoc1ToM(nameof(Objects), value);
        }
         
        public void RemoveFromObjects(IdentifiedObject value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Objects), value);
        }
         
        public void RemoveAllFromObjects()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Objects));
        }
         
        /// <summary>
        /// Organisation having this role.
        /// </summary>
        public Organisation? Organisation
        {
            get => ObjectData.GetAssoc1To1<Organisation>(nameof(Organisation));
            set => ObjectData.SetAssoc1To1(nameof(Organisation), value);
        }
         
    }
     
    /// <summary>
    /// Classifying instances of the same class, e.g. overhead and underground
    /// ACLineSegments. This classification mechanism is intended to provide flexibility
    /// outside the scope of this document, i.e. provide customisation that is
    /// non standard.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PSRType")]
    public partial class PSRType : IdentifiedObject, IModelObject
    {
        public PSRType(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Power system resources classified with this power system resource type.
        /// </summary>
        public PowerSystemResource[]? PowerSystemResources
        {
            get => ObjectData.GetAssoc1ToM<PowerSystemResource>(nameof(PowerSystemResources));
        }
         
        public void AddToPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveFromPowerSystemResources(PowerSystemResource value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerSystemResources), value);
        }
         
        public void RemoveAllFromPowerSystemResources()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerSystemResources));
        }
         
    }
     
    /// <summary>
    /// Pressurized water reactor used as a steam supply to a steam turbine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PWRSteamSupply")]
    public partial class PWRSteamSupply : SteamSupply, IModelObject
    {
        public PWRSteamSupply(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// An unordered enumeration of phase identifiers. Allows designation of phases
    /// for both transmission and distribution equipment, circuits and loads. The
    /// enumeration, by itself, does not describe how the phases are connected
    /// together or connected to ground. Ground is not explicitly denoted as a
    /// phase.
    /// Residential and small commercial loads are often served from single-phase,
    /// or split-phase, secondary circuits. For the example of s12N, phases 1 and
    /// 2 refer to hot wires that are 180 degrees out of phase, while N refers
    /// to the neutral wire. Through single-phase transformer connections, these
    /// secondary circuits may be served from one or two of the primary phases
    /// A, B, and C. For three-phase loads, use the A, B, C phase codes instead
    /// of s12N.
    /// The integer values are from IEC 61968-9 to support revenue metering applications.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseCode")]
    public enum PhaseCode
    {
        /// <summary>
        /// Phase A.
        /// </summary>
        A,
        /// <summary>
        /// Phases A and B.
        /// </summary>
        AB,
        /// <summary>
        /// Phases A, B, and C.
        /// </summary>
        ABC,
        /// <summary>
        /// Phases A, B, C, and N.
        /// </summary>
        ABCN,
        /// <summary>
        /// Phases A, B, and neutral.
        /// </summary>
        ABN,
        /// <summary>
        /// Phases A and C.
        /// </summary>
        AC,
        /// <summary>
        /// Phases A, C and neutral.
        /// </summary>
        ACN,
        /// <summary>
        /// Phases A and neutral.
        /// </summary>
        AN,
        /// <summary>
        /// Phase B.
        /// </summary>
        B,
        /// <summary>
        /// Phases B and C.
        /// </summary>
        BC,
        /// <summary>
        /// Phases B, C, and neutral.
        /// </summary>
        BCN,
        /// <summary>
        /// Phases B and neutral.
        /// </summary>
        BN,
        /// <summary>
        /// Phase C.
        /// </summary>
        C,
        /// <summary>
        /// Phases C and neutral.
        /// </summary>
        CN,
        /// <summary>
        /// Neutral phase.
        /// </summary>
        N,
        /// <summary>
        /// Unknown non-neutral phase.
        /// </summary>
        X,
        /// <summary>
        /// Unknown non-neutral phase plus neutral.
        /// </summary>
        XN,
        /// <summary>
        /// Two unknown non-neutral phases.
        /// </summary>
        XY,
        /// <summary>
        /// Two unknown non-neutral phases plus neutral.
        /// </summary>
        XYN,
        /// <summary>
        /// No phases specified.
        /// </summary>
        none,
        /// <summary>
        /// Secondary phase 1.
        /// </summary>
        s1,
        /// <summary>
        /// Secondary phase 1 and 2.
        /// </summary>
        s12,
        /// <summary>
        /// Secondary phases 1, 2, and neutral.
        /// </summary>
        s12N,
        /// <summary>
        /// Secondary phase 1 and neutral.
        /// </summary>
        s1N,
        /// <summary>
        /// Secondary phase 2.
        /// </summary>
        s2,
        /// <summary>
        /// Secondary phase 2 and neutral.
        /// </summary>
        s2N,
    }
     
    /// <summary>
    /// A transformer phase shifting tap model that controls the phase angle difference
    /// across the power transformer and potentially the active power flow through
    /// the power transformer. This phase tap model may also impact the voltage
    /// magnitude.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChanger")]
    public partial class PhaseTapChanger : TapChanger, IModelObject
    {
        public PhaseTapChanger(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Transformer end to which this phase tap changer belongs.
        /// </summary>
        public TransformerEnd? TransformerEnd
        {
            get => ObjectData.GetAssoc1To1<TransformerEnd>(nameof(TransformerEnd));
            set => ObjectData.SetAssoc1To1(nameof(TransformerEnd), value);
        }
         
    }
     
    /// <summary>
    /// Describes the tap model for an asymmetrical phase shifting transformer
    /// in which the difference voltage vector adds to the in-phase winding. The
    /// out-of-phase winding is the transformer end where the tap changer is located.
    /// The angle between the in-phase and out-of-phase windings is named the winding
    /// connection angle. The phase shift depends on both the difference voltage
    /// magnitude and the winding connection angle.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChangerAsymmetrical")]
    public partial class PhaseTapChangerAsymmetrical : PhaseTapChangerNonLinear, IModelObject
    {
        public PhaseTapChangerAsymmetrical(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Describes a tap changer with a linear relation between the tap step and
    /// the phase angle difference across the transformer. This is a mathematical
    /// model that is an approximation of a real phase tap changer.
    /// The phase angle is computed as stepPhaseShiftIncrement times the tap position.
    /// The voltage magnitude of both sides is the same.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChangerLinear")]
    public partial class PhaseTapChangerLinear : PhaseTapChanger, IModelObject
    {
        public PhaseTapChangerLinear(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// The non-linear phase tap changer describes the non-linear behaviour of
    /// a phase tap changer. This is a base class for the symmetrical and asymmetrical
    /// phase tap changer models. The details of these models can be found in IEC
    /// 61970-301.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChangerNonLinear")]
    public partial class PhaseTapChangerNonLinear : PhaseTapChanger, IModelObject
    {
        public PhaseTapChangerNonLinear(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Describes a symmetrical phase shifting transformer tap model in which the
    /// voltage magnitude of both sides is the same. The difference voltage magnitude
    /// is the base in an equal-sided triangle where the sides corresponds to the
    /// primary and secondary voltages. The phase angle difference corresponds
    /// to the top angle and can be expressed as twice the arctangent of half the
    /// total difference voltage.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChangerSymmetrical")]
    public partial class PhaseTapChangerSymmetrical : PhaseTapChangerNonLinear, IModelObject
    {
        public PhaseTapChangerSymmetrical(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Describes a tap changer with a table defining the relation between the
    /// tap step and the phase angle difference across the transformer.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PhaseTapChangerTabular")]
    public partial class PhaseTapChangerTabular : PhaseTapChanger, IModelObject
    {
        public PhaseTapChangerTabular(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A Plant is a collection of equipment for purposes of generation.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Plant")]
    public partial class Plant : EquipmentContainer, IModelObject
    {
        public Plant(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public SubGeographicalRegion? Region
        {
            get => ObjectData.GetAssoc1To1<SubGeographicalRegion>(nameof(Region));
            set => ObjectData.SetAssoc1To1(nameof(Region), value);
        }
         
        /// <summary>
        /// </summary>
        public Substation[]? Substations
        {
            get => ObjectData.GetAssoc1ToM<Substation>(nameof(Substations));
        }
         
        public void AddToSubstations(Substation value)
        {
            ObjectData.AddAssoc1ToM(nameof(Substations), value);
        }
         
        public void RemoveFromSubstations(Substation value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Substations), value);
        }
         
        public void RemoveAllFromSubstations()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Substations));
        }
         
    }
     
    /// <summary>
    /// Set of spatial coordinates that determine a point, defined in the coordinate
    /// system specified in 'Location.CoordinateSystem'. Use a single position
    /// point instance to describe a point-oriented location. Use a sequence of
    /// position points to describe a line-oriented object (physical location of
    /// non-point oriented objects like cables or lines), or area of an object
    /// (like a substation or a geographical zone - in this case, have first and
    /// last position point with the same values).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PositionPoint")]
    public partial class PositionPoint : ModelObject, IModelObject
    {
        public PositionPoint(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Instrument transformer (also known as Voltage Transformer) used to measure
    /// electrical qualities of the circuit that is being protected and/or monitored.
    /// Typically used as voltage transducer for the purpose of metering, protection,
    /// or sometimes auxiliary substation supply. A typical secondary voltage rating
    /// would be 120V.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PotentialTransformer")]
    public partial class PotentialTransformer : Sensor, IModelObject
    {
        public PotentialTransformer(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A power system resource (PSR) can be an item of equipment such as a switch,
    /// an equipment container containing many individual items of equipment such
    /// as a substation, or an organisational entity such as sub-control area.
    /// Power system resources can have measurements associated.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerSystemResource")]
    public partial class PowerSystemResource : IdentifiedObject, IModelObject
    {
        public PowerSystemResource(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All assets represented by this power system resource. For example, multiple
        /// conductor assets are electrically modelled as a single AC line segment.
        /// </summary>
        public Asset[]? Assets
        {
            get => ObjectData.GetAssoc1ToM<Asset>(nameof(Assets));
        }
         
        public void AddToAssets(Asset value)
        {
            ObjectData.AddAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveFromAssets(Asset value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Assets), value);
        }
         
        public void RemoveAllFromAssets()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Assets));
        }
         
        /// <summary>
        /// Location of this power system resource.
        /// </summary>
        public Location? Location
        {
            get => ObjectData.GetAssoc1To1<Location>(nameof(Location));
            set => ObjectData.SetAssoc1To1(nameof(Location), value);
        }
         
        /// <summary>
        /// The measurements associated with this power system resource.
        /// </summary>
        public Measurement[]? Measurements
        {
            get => ObjectData.GetAssoc1ToM<Measurement>(nameof(Measurements));
        }
         
        public void AddToMeasurements(Measurement value)
        {
            ObjectData.AddAssoc1ToM(nameof(Measurements), value);
        }
         
        public void RemoveFromMeasurements(Measurement value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Measurements), value);
        }
         
        public void RemoveAllFromMeasurements()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Measurements));
        }
         
        /// <summary>
        /// Custom classification for this power system resource.
        /// </summary>
        public PSRType? PSRType
        {
            get => ObjectData.GetAssoc1To1<PSRType>(nameof(PSRType));
            set => ObjectData.SetAssoc1To1(nameof(PSRType), value);
        }
         
    }
     
    /// <summary>
    /// An electrical device consisting of two or more coupled windings, with or
    /// without a magnetic core, for introducing mutual coupling between electric
    /// circuits. Transformers can be used to control voltage and phase shift (active
    /// power flow).
    /// A power transformer may be composed of separate transformer tanks that
    /// need not be identical.
    /// A power transformer can be modelled with or without tanks and is intended
    /// for use in both balanced and unbalanced representations. A power transformer
    /// typically has two terminals, but may have one (grounding), three or more
    /// terminals.
    /// The inherited association ConductingEquipment.BaseVoltage should not be
    /// used. The association from TransformerEnd to BaseVoltage should be used
    /// instead.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerTransformer")]
    public partial class PowerTransformer : ConductingEquipment, IModelObject
    {
        public PowerTransformer(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The ends of this power transformer.
        /// </summary>
        public PowerTransformerEnd[]? PowerTransformerEnd
        {
            get => ObjectData.GetAssoc1ToM<PowerTransformerEnd>(nameof(PowerTransformerEnd));
        }
         
        public void AddToPowerTransformerEnd(PowerTransformerEnd value)
        {
            ObjectData.AddAssoc1ToM(nameof(PowerTransformerEnd), value);
        }
         
        public void RemoveFromPowerTransformerEnd(PowerTransformerEnd value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PowerTransformerEnd), value);
        }
         
        public void RemoveAllFromPowerTransformerEnd()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PowerTransformerEnd));
        }
         
    }
     
    /// <summary>
    /// A PowerTransformerEnd is associated with each Terminal of a PowerTransformer.
    /// The impedance values r, r0, x, and x0 of a PowerTransformerEnd represents
    /// a star equivalent as follows.
    /// 1) for a two Terminal PowerTransformer the high voltage (TransformerEnd.endNumber=1)
    /// PowerTransformerEnd has non zero values on r, r0, x, and x0 while the low
    /// voltage (TransformerEnd.endNumber=2) PowerTransformerEnd has zero values
    /// for r, r0, x, and x0. Parameters are always provided, even if the PowerTransformerEnds
    /// have the same rated voltage. In this case, the parameters are provided
    /// at the PowerTransformerEnd which has TransformerEnd.endNumber equal to
    /// 1.
    /// 2) for a three Terminal PowerTransformer the three PowerTransformerEnds
    /// represent a star equivalent with each leg in the star represented by r,
    /// r0, x, and x0 values.
    /// 3) For a three Terminal transformer each PowerTransformerEnd shall have
    /// g, g0, b and b0 values corresponding to the no load losses distributed
    /// on the three PowerTransformerEnds. The total no load loss shunt impedances
    /// may also be placed at one of the PowerTransformerEnds, preferably the end
    /// numbered 1, having the shunt values on end 1. This is the preferred way.
    /// 4) for a PowerTransformer with more than three Terminals the PowerTransformerEnd
    /// impedance values cannot be used. Instead use the TransformerMeshImpedance
    /// or split the transformer into multiple PowerTransformers.
    /// Each PowerTransformerEnd must be contained by a PowerTransformer. Because
    /// a PowerTransformerEnd (or any other object) can not be contained by more
    /// than one parent, a PowerTransformerEnd can not have an association to an
    /// EquipmentContainer (Substation, VoltageLevel, etc).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PowerTransformerEnd")]
    public partial class PowerTransformerEnd : TransformerEnd, IModelObject
    {
        public PowerTransformerEnd(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The power transformer of this power transformer end.
        /// </summary>
        public PowerTransformer? PowerTransformer
        {
            get => ObjectData.GetAssoc1To1<PowerTransformer>(nameof(PowerTransformer));
            set => ObjectData.SetAssoc1To1(nameof(PowerTransformer), value);
        }
         
    }
     
    /// <summary>
    /// The machine used to develop mechanical energy used to drive a generator.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#PrimeMover")]
    public partial class PrimeMover : PowerSystemResource, IModelObject
    {
        public PrimeMover(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public AsynchronousMachine? AsynchronousMachine
        {
            get => ObjectData.GetAssoc1To1<AsynchronousMachine>(nameof(AsynchronousMachine));
            set => ObjectData.SetAssoc1To1(nameof(AsynchronousMachine), value);
        }
         
        /// <summary>
        /// Synchronous machines this Prime mover drives.
        /// </summary>
        public SynchronousMachine[]? SynchronousMachines
        {
            get => ObjectData.GetAssoc1ToM<SynchronousMachine>(nameof(SynchronousMachines));
        }
         
        public void AddToSynchronousMachines(SynchronousMachine value)
        {
            ObjectData.AddAssoc1ToM(nameof(SynchronousMachines), value);
        }
         
        public void RemoveFromSynchronousMachines(SynchronousMachine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(SynchronousMachines), value);
        }
         
        public void RemoveAllFromSynchronousMachines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(SynchronousMachines));
        }
         
    }
     
    /// <summary>
    /// A ProtectedSwitch is a switching device that can be operated by ProtectionEquipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ProtectedSwitch")]
    public partial class ProtectedSwitch : Switch, IModelObject
    {
        public ProtectedSwitch(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A tap changer that changes the voltage ratio impacting the voltage magnitude
    /// but not the phase angle across the transformer.
    /// Angle sign convention (general): Positive value indicates a positive phase
    /// shift from the winding where the tap is located to the other winding (for
    /// a two-winding transformer).
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RatioTapChanger")]
    public partial class RatioTapChanger : TapChanger, IModelObject
    {
        public RatioTapChanger(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Transformer end to which this ratio tap changer belongs.
        /// </summary>
        public TransformerEnd? TransformerEnd
        {
            get => ObjectData.GetAssoc1To1<TransformerEnd>(nameof(TransformerEnd));
            set => ObjectData.SetAssoc1To1(nameof(TransformerEnd), value);
        }
         
    }
     
    /// <summary>
    /// Pole-mounted fault interrupter with built-in phase and ground relays, current
    /// transformer (CT), and supplemental controls.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Recloser")]
    public partial class Recloser : ProtectedSwitch, IModelObject
    {
        public Recloser(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A type of conducting equipment that can regulate a quantity (i.e. voltage
    /// or flow) at a specific point in the network.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RegulatingCondEq")]
    public partial class RegulatingCondEq : ModelObject, IModelObject
    {
        public RegulatingCondEq(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A rotating machine which may be used as a generator or motor.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#RotatingMachine")]
    public partial class RotatingMachine : RegulatingCondEq, IModelObject
    {
        public RotatingMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// A synchronous machine may operate as a generator and as such becomes a
        /// member of a generating unit.
        /// </summary>
        public GeneratingUnit? GeneratingUnit
        {
            get => ObjectData.GetAssoc1To1<GeneratingUnit>(nameof(GeneratingUnit));
            set => ObjectData.SetAssoc1To1(nameof(GeneratingUnit), value);
        }
         
    }
     
    /// <summary>
    /// This class describe devices that transform a measured quantity into signals
    /// that can be presented at displays, used in control or be recorded.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Sensor")]
    public partial class Sensor : AuxiliaryEquipment, IModelObject
    {
        public Sensor(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A Series Compensator is a series capacitor or reactor or an AC transmission
    /// line without charging susceptance. It is a two terminal device.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SeriesCompensator")]
    public partial class SeriesCompensator : ConductingEquipment, IModelObject
    {
        public SeriesCompensator(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A shunt capacitor or reactor or switchable bank of shunt capacitors or
    /// reactors. A section of a shunt compensator is an individual capacitor or
    /// reactor. A negative value for bPerSection indicates that the compensator
    /// is a reactor. ShuntCompensator is a single terminal device. Ground is implied.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ShuntCompensator")]
    public partial class ShuntCompensator : RegulatingCondEq, IModelObject
    {
        public ShuntCompensator(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A facility for providing variable and controllable shunt reactive power.
    /// The SVC typically consists of a stepdown transformer, filter, thyristor-controlled
    /// reactor, and thyristor-switched capacitor arms.
    /// The SVC may operate in fixed MVar output mode or in voltage control mode.
    /// When in voltage control mode, the output of the SVC will be proportional
    /// to the deviation of voltage at the controlled bus from the voltage setpoint.
    /// The SVC characteristic slope defines the proportion. If the voltage at
    /// the controlled bus is equal to the voltage setpoint, the SVC MVar output
    /// is zero.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#StaticVarCompensator")]
    public partial class StaticVarCompensator : RegulatingCondEq, IModelObject
    {
        public StaticVarCompensator(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Steam supply for steam turbine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SteamSupply")]
    public partial class SteamSupply : PowerSystemResource, IModelObject
    {
        public SteamSupply(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Steam turbines may have steam supplied by a steam supply.
        /// </summary>
        public SteamTurbine[]? SteamTurbines
        {
            get => ObjectData.GetAssoc1ToM<SteamTurbine>(nameof(SteamTurbines));
        }
         
        public void AddToSteamTurbines(SteamTurbine value)
        {
            ObjectData.AddAssoc1ToM(nameof(SteamTurbines), value);
        }
         
        public void RemoveFromSteamTurbines(SteamTurbine value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(SteamTurbines), value);
        }
         
        public void RemoveAllFromSteamTurbines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(SteamTurbines));
        }
         
    }
     
    /// <summary>
    /// Steam turbine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SteamTurbine")]
    public partial class SteamTurbine : PrimeMover, IModelObject
    {
        public SteamTurbine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Steam turbines may have steam supplied by a steam supply.
        /// </summary>
        public SteamSupply[]? SteamSupplys
        {
            get => ObjectData.GetAssoc1ToM<SteamSupply>(nameof(SteamSupplys));
        }
         
        public void AddToSteamSupplys(SteamSupply value)
        {
            ObjectData.AddAssoc1ToM(nameof(SteamSupplys), value);
        }
         
        public void RemoveFromSteamSupplys(SteamSupply value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(SteamSupplys), value);
        }
         
        public void RemoveAllFromSteamSupplys()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(SteamSupplys));
        }
         
    }
     
    /// <summary>
    /// General purpose street and postal address information.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#StreetAddress")]
    public partial class StreetAddress : ModelObject, IModelObject
    {
        public StreetAddress(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A subset of a geographical region of a power system network model.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SubGeographicalRegion")]
    public partial class SubGeographicalRegion : IdentifiedObject, IModelObject
    {
        public SubGeographicalRegion(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The lines within the sub-geographical region.
        /// </summary>
        public Line[]? Lines
        {
            get => ObjectData.GetAssoc1ToM<Line>(nameof(Lines));
        }
         
        public void AddToLines(Line value)
        {
            ObjectData.AddAssoc1ToM(nameof(Lines), value);
        }
         
        public void RemoveFromLines(Line value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Lines), value);
        }
         
        public void RemoveAllFromLines()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Lines));
        }
         
        /// <summary>
        /// </summary>
        public Plant[]? Plants
        {
            get => ObjectData.GetAssoc1ToM<Plant>(nameof(Plants));
        }
         
        public void AddToPlants(Plant value)
        {
            ObjectData.AddAssoc1ToM(nameof(Plants), value);
        }
         
        public void RemoveFromPlants(Plant value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Plants), value);
        }
         
        public void RemoveAllFromPlants()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Plants));
        }
         
        /// <summary>
        /// The geographical region which this sub-geographical region is within.
        /// </summary>
        public GeographicalRegion? Region
        {
            get => ObjectData.GetAssoc1To1<GeographicalRegion>(nameof(Region));
            set => ObjectData.SetAssoc1To1(nameof(Region), value);
        }
         
        /// <summary>
        /// The substations in this sub-geographical region.
        /// </summary>
        public Substation[]? Substations
        {
            get => ObjectData.GetAssoc1ToM<Substation>(nameof(Substations));
        }
         
        public void AddToSubstations(Substation value)
        {
            ObjectData.AddAssoc1ToM(nameof(Substations), value);
        }
         
        public void RemoveFromSubstations(Substation value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Substations), value);
        }
         
        public void RemoveAllFromSubstations()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Substations));
        }
         
    }
     
    /// <summary>
    /// Once-through subcritical boiler.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Subcritical")]
    public partial class Subcritical : FossilSteamSupply, IModelObject
    {
        public Subcritical(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A collection of equipment for purposes other than generation or utilization,
    /// through which electric energy in bulk is passed for the purposes of switching
    /// or modifying its characteristics.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Substation")]
    public partial class Substation : EquipmentContainer, IModelObject
    {
        public Substation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// </summary>
        public Plant? Plant
        {
            get => ObjectData.GetAssoc1To1<Plant>(nameof(Plant));
            set => ObjectData.SetAssoc1To1(nameof(Plant), value);
        }
         
        /// <summary>
        /// The SubGeographicalRegion containing the substation.
        /// </summary>
        public SubGeographicalRegion? Region
        {
            get => ObjectData.GetAssoc1To1<SubGeographicalRegion>(nameof(Region));
            set => ObjectData.SetAssoc1To1(nameof(Region), value);
        }
         
        /// <summary>
        /// The voltage levels within this substation.
        /// </summary>
        public VoltageLevel[]? VoltageLevels
        {
            get => ObjectData.GetAssoc1ToM<VoltageLevel>(nameof(VoltageLevels));
        }
         
        public void AddToVoltageLevels(VoltageLevel value)
        {
            ObjectData.AddAssoc1ToM(nameof(VoltageLevels), value);
        }
         
        public void RemoveFromVoltageLevels(VoltageLevel value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(VoltageLevels), value);
        }
         
        public void RemoveAllFromVoltageLevels()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(VoltageLevels));
        }
         
    }
     
    /// <summary>
    /// Once-through supercritical boiler.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Supercritical")]
    public partial class Supercritical : FossilSteamSupply, IModelObject
    {
        public Supercritical(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Shunt device, installed on the network, usually in the proximity of electrical
    /// equipment in order to protect the said equipment against transient voltage
    /// transients caused by lightning or switching activity.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SurgeArrester")]
    public partial class SurgeArrester : AuxiliaryEquipment, IModelObject
    {
        public SurgeArrester(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A generic device designed to close, or open, or both, one or more electric
    /// circuits. All switches are two terminal devices including grounding switches.
    /// The ACDCTerminal.connected at the two sides of the switch shall not be
    /// considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
    /// and .locked are relevant.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Switch")]
    public partial class Switch : ConductingEquipment, IModelObject
    {
        public Switch(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// An electromechanical device that operates with shaft rotating synchronously
    /// with the network. It is a single machine operating either as a generator
    /// or synchronous condenser or pump.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#SynchronousMachine")]
    public partial class SynchronousMachine : RotatingMachine, IModelObject
    {
        public SynchronousMachine(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Prime movers that drive this SynchronousMachine.
        /// </summary>
        public PrimeMover[]? PrimeMovers
        {
            get => ObjectData.GetAssoc1ToM<PrimeMover>(nameof(PrimeMovers));
        }
         
        public void AddToPrimeMovers(PrimeMover value)
        {
            ObjectData.AddAssoc1ToM(nameof(PrimeMovers), value);
        }
         
        public void RemoveFromPrimeMovers(PrimeMover value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(PrimeMovers), value);
        }
         
        public void RemoveAllFromPrimeMovers()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(PrimeMovers));
        }
         
    }
     
    /// <summary>
    /// Mechanism for changing transformer winding tap positions.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TapChanger")]
    public partial class TapChanger : PowerSystemResource, IModelObject
    {
        public TapChanger(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// Telephone number.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TelephoneNumber")]
    public partial class TelephoneNumber : ModelObject, IModelObject
    {
        public TelephoneNumber(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// An AC electrical connection point to a piece of conducting equipment. Terminals
    /// are connected at physical connection points called connectivity nodes.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#Terminal")]
    public partial class Terminal : ACDCTerminal, IModelObject
    {
        public Terminal(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The auxiliary equipment connected to the terminal.
        /// </summary>
        public AuxiliaryEquipment[]? AuxiliaryEquipment
        {
            get => ObjectData.GetAssoc1ToM<AuxiliaryEquipment>(nameof(AuxiliaryEquipment));
        }
         
        public void AddToAuxiliaryEquipment(AuxiliaryEquipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(AuxiliaryEquipment), value);
        }
         
        public void RemoveFromAuxiliaryEquipment(AuxiliaryEquipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(AuxiliaryEquipment), value);
        }
         
        public void RemoveAllFromAuxiliaryEquipment()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(AuxiliaryEquipment));
        }
         
        /// <summary>
        /// The conducting equipment of the terminal. Conducting equipment have terminals
        /// that may be connected to other conducting equipment terminals via connectivity
        /// nodes or topological nodes.
        /// </summary>
        public ConductingEquipment? ConductingEquipment
        {
            get => ObjectData.GetAssoc1To1<ConductingEquipment>(nameof(ConductingEquipment));
            set => ObjectData.SetAssoc1To1(nameof(ConductingEquipment), value);
        }
         
        /// <summary>
        /// The connectivity node to which this terminal connects with zero impedance.
        /// </summary>
        public ConnectivityNode? ConnectivityNode
        {
            get => ObjectData.GetAssoc1To1<ConnectivityNode>(nameof(ConnectivityNode));
            set => ObjectData.SetAssoc1To1(nameof(ConnectivityNode), value);
        }
         
        /// <summary>
        /// All transformer ends connected at this terminal.
        /// </summary>
        public TransformerEnd[]? TransformerEnd
        {
            get => ObjectData.GetAssoc1ToM<TransformerEnd>(nameof(TransformerEnd));
        }
         
        public void AddToTransformerEnd(TransformerEnd value)
        {
            ObjectData.AddAssoc1ToM(nameof(TransformerEnd), value);
        }
         
        public void RemoveFromTransformerEnd(TransformerEnd value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(TransformerEnd), value);
        }
         
        public void RemoveAllFromTransformerEnd()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(TransformerEnd));
        }
         
    }
     
    /// <summary>
    /// A generating unit whose prime mover could be a steam turbine, combustion
    /// turbine, or diesel engine.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#ThermalGeneratingUnit")]
    public partial class ThermalGeneratingUnit : GeneratingUnit, IModelObject
    {
        public ThermalGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A conducting connection point of a power transformer. It corresponds to
    /// a physical transformer winding terminal. In earlier CIM versions, the TransformerWinding
    /// class served a similar purpose, but this class is more flexible because
    /// it associates to terminal but is not a specialization of ConductingEquipment.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#TransformerEnd")]
    public partial class TransformerEnd : IdentifiedObject, IModelObject
    {
        public TransformerEnd(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Base voltage of the transformer end. This is essential for PU calculation.
        /// </summary>
        public BaseVoltage? BaseVoltage
        {
            get => ObjectData.GetAssoc1To1<BaseVoltage>(nameof(BaseVoltage));
            set => ObjectData.SetAssoc1To1(nameof(BaseVoltage), value);
        }
         
        /// <summary>
        /// Phase tap changer associated with this transformer end.
        /// </summary>
        public PhaseTapChanger? PhaseTapChanger
        {
            get => ObjectData.GetAssoc1To1<PhaseTapChanger>(nameof(PhaseTapChanger));
            set => ObjectData.SetAssoc1To1(nameof(PhaseTapChanger), value);
        }
         
        /// <summary>
        /// Ratio tap changer associated with this transformer end.
        /// </summary>
        public RatioTapChanger? RatioTapChanger
        {
            get => ObjectData.GetAssoc1To1<RatioTapChanger>(nameof(RatioTapChanger));
            set => ObjectData.SetAssoc1To1(nameof(RatioTapChanger), value);
        }
         
        /// <summary>
        /// Terminal of the power transformer to which this transformer end belongs.
        /// </summary>
        public Terminal? Terminal
        {
            get => ObjectData.GetAssoc1To1<Terminal>(nameof(Terminal));
            set => ObjectData.SetAssoc1To1(nameof(Terminal), value);
        }
         
    }
     
    /// <summary>
    /// Logical or physical point in the network to which readings or events may
    /// be attributed. Used at the place where a physical or virtual meter may
    /// be located; however, it is not required that a meter be present.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UsagePoint")]
    public partial class UsagePoint : IdentifiedObject, IModelObject
    {
        public UsagePoint(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// Nominal service voltage.
        /// </summary>
        public float nominalServiceVoltage
        {
            get => ObjectData.GetAttribute<float>(nameof(nominalServiceVoltage));
            set => ObjectData.SetAttribute<float>(nameof(nominalServiceVoltage), value);
        }
         
        /// <summary>
        /// Outage region in which this usage point is located.
        /// </summary>
        public string outageRegion
        {
            get => ObjectData.GetAttribute<string>(nameof(outageRegion));
            set => ObjectData.SetAttribute<string>(nameof(outageRegion), value);
        }
         
        /// <summary>
        /// Phase code. Number of wires and specific nominal phases can be deduced
        /// from enumeration literal values. For example, ABCN is three-phase, four-wire,
        /// s12n (splitSecondary12N) is single-phase, three-wire, and s1n and s2n are
        /// single-phase, two-wire.
        /// </summary>
        public PhaseCode phaseCode
        {
            get => ObjectData.GetAttribute<PhaseCode>(nameof(phaseCode));
            set => ObjectData.SetAttribute<PhaseCode>(nameof(phaseCode), value);
        }
         
        /// <summary>
        /// Priority of service for this usage point. Note that usage points at the
        /// same service location can have different priorities.
        /// </summary>
        public string servicePriority
        {
            get => ObjectData.GetAttribute<string>(nameof(servicePriority));
            set => ObjectData.SetAttribute<string>(nameof(servicePriority), value);
        }
         
        /// <summary>
        /// Customer agreement regulating this service delivery point.
        /// </summary>
        public CustomerAgreement? CustomerAgreement
        {
            get => ObjectData.GetAssoc1To1<CustomerAgreement>(nameof(CustomerAgreement));
            set => ObjectData.SetAssoc1To1(nameof(CustomerAgreement), value);
        }
         
        /// <summary>
        /// All end devices at this usage point.
        /// </summary>
        public EndDevice[]? EndDevices
        {
            get => ObjectData.GetAssoc1ToM<EndDevice>(nameof(EndDevices));
        }
         
        public void AddToEndDevices(EndDevice value)
        {
            ObjectData.AddAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveFromEndDevices(EndDevice value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(EndDevices), value);
        }
         
        public void RemoveAllFromEndDevices()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(EndDevices));
        }
         
        /// <summary>
        /// All equipment connecting this usage point to the electrical grid.
        /// </summary>
        public Equipment[]? Equipments
        {
            get => ObjectData.GetAssoc1ToM<Equipment>(nameof(Equipments));
        }
         
        public void AddToEquipments(Equipment value)
        {
            ObjectData.AddAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveFromEquipments(Equipment value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Equipments), value);
        }
         
        public void RemoveAllFromEquipments()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Equipments));
        }
         
        /// <summary>
        /// Location of this usage point.
        /// </summary>
        public UsagePointLocation? UsagePointLocation
        {
            get => ObjectData.GetAssoc1To1<UsagePointLocation>(nameof(UsagePointLocation));
            set => ObjectData.SetAssoc1To1(nameof(UsagePointLocation), value);
        }
         
    }
     
    /// <summary>
    /// Location of an individual usage point.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#UsagePointLocation")]
    public partial class UsagePointLocation : Location, IModelObject
    {
        public UsagePointLocation(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// All usage points at this location.
        /// </summary>
        public UsagePoint[]? UsagePoints
        {
            get => ObjectData.GetAssoc1ToM<UsagePoint>(nameof(UsagePoints));
        }
         
        public void AddToUsagePoints(UsagePoint value)
        {
            ObjectData.AddAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveFromUsagePoints(UsagePoint value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(UsagePoints), value);
        }
         
        public void RemoveAllFromUsagePoints()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(UsagePoints));
        }
         
    }
     
    /// <summary>
    /// A collection of equipment at one common system voltage forming a switchgear.
    /// The equipment typically consists of breakers, busbars, instrumentation,
    /// control, regulation and protection devices as well as assemblies of all
    /// these.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#VoltageLevel")]
    public partial class VoltageLevel : EquipmentContainer, IModelObject
    {
        public VoltageLevel(DataFacade objectData) : base(objectData) {}
         
        /// <summary>
        /// The base voltage used for all equipment within the voltage level.
        /// </summary>
        public BaseVoltage? BaseVoltage
        {
            get => ObjectData.GetAssoc1To1<BaseVoltage>(nameof(BaseVoltage));
            set => ObjectData.SetAssoc1To1(nameof(BaseVoltage), value);
        }
         
        /// <summary>
        /// The bays within this voltage level.
        /// </summary>
        public Bay[]? Bays
        {
            get => ObjectData.GetAssoc1ToM<Bay>(nameof(Bays));
        }
         
        public void AddToBays(Bay value)
        {
            ObjectData.AddAssoc1ToM(nameof(Bays), value);
        }
         
        public void RemoveFromBays(Bay value)
        {
            ObjectData.RemoveAssoc1ToM(nameof(Bays), value);
        }
         
        public void RemoveAllFromBays()
        {
            ObjectData.RemoveAllAssoc1ToM(nameof(Bays));
        }
         
        /// <summary>
        /// The substation of the voltage level.
        /// </summary>
        public Substation? Substation
        {
            get => ObjectData.GetAssoc1To1<Substation>(nameof(Substation));
            set => ObjectData.SetAssoc1To1(nameof(Substation), value);
        }
         
    }
     
    /// <summary>
    /// Line traps are devices that impede high frequency power line carrier signals
    /// yet present a negligible impedance at the main power frequency.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#WaveTrap")]
    public partial class WaveTrap : AuxiliaryEquipment, IModelObject
    {
        public WaveTrap(DataFacade objectData) : base(objectData) {}
         
    }
     
    /// <summary>
    /// A wind driven generating unit, connected to the grid by means of a rotating
    /// machine. May be used to represent a single turbine or an aggregation.
    /// </summary>
    [CimClass("http://iec.ch/TC57/CIM100#WindGeneratingUnit")]
    public partial class WindGeneratingUnit : GeneratingUnit, IModelObject
    {
        public WindGeneratingUnit(DataFacade objectData) : base(objectData) {}
         
    }
     
}
