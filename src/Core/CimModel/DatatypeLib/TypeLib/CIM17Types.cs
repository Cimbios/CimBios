/*
 *	CimBios Toolkit autogenerated CIM type library code.
 */
using CimBios.Core.CimModel.Schema;
using CimBios.Core.CimModel.CimDatatypeLib;
using CimBios.Core.CimModel.CimDatatypeLib.OID;

namespace CimBios.Core.CimModel.CimDatatypeLib.CIM17Types;

/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class Statement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement";
}
/// <summary>
/// A DC electrical connection point at the AC/DC converter. The AC/DC converter
/// is electrically connected also to the AC side. The AC connection is
/// inherited from the AC conducting equipment in the same way as any other AC
/// equipment. The AC/DC converter DC terminal is separate from generic DC
/// terminal to restrict the connection with the AC side to AC/DC converter and
/// so that no other DC conducting equipment can be connected to the AC side.
/// </summary>
[CimClass (ClassUri)]
public partial class ACDCConverterDCTerminal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : DCBaseTerminal (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ACDCConverterDCTerminal";
}
/// <summary>
/// An electrical connection point (AC or DC) to a piece of conducting
/// equipment. Terminals are connected at physical connection points called
/// connectivity nodes.
/// </summary>
[CimClass (ClassUri)]
public partial class ACDCTerminal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ACDCTerminal";

  /// <summary>
  /// The orientation of the terminal connections for a multiple terminal
  /// conducting equipment.  The sequence numbering starts with 1 and additional
  /// terminals should follow in increasing order.   The first terminal is the
  /// "starting point" for a two terminal branch.
  /// </summary>
  public int ? sequenceNumber
  {
    get => GetAttribute < int ? > (nameof (sequenceNumber));
    set => SetAttribute (nameof (sequenceNumber), value);
  }

  /// <summary>
  /// Measurements associated with this terminal defining  where the measurement
  /// is placed in the network topology.  It may be used, for instance, to
  /// capture the sensor position, such as a voltage transformer (PT) at a
  /// busbar or a current transformer (CT) at the bar between a breaker and an
  /// isolator.
  /// </summary>
  public Measurement[] Measurements => GetAssoc1ToM<Measurement> (
      nameof (Measurements));
  public void AddToMeasurements (Measurement assocObject) => AddAssoc1ToM (
      nameof (Measurements), assocObject);
  public void RemoveFromMeasurements (
      Measurement assocObject) => RemoveAssoc1ToM (nameof (Measurements),
                                                   assocObject);
  public void RemoveAllFromMeasurements () => RemoveAllAssocs1ToM (
      nameof (Measurements));
  /// <summary>
  /// The operational limit sets at the terminal.
  /// </summary>
  public OperationalLimitSet[] OperationalLimitSet => GetAssoc1ToM<
      OperationalLimitSet> (nameof (OperationalLimitSet));
  public void
  AddToOperationalLimitSet (OperationalLimitSet assocObject) => AddAssoc1ToM (
      nameof (OperationalLimitSet), assocObject);
  public void RemoveFromOperationalLimitSet (
      OperationalLimitSet
          assocObject) => RemoveAssoc1ToM (nameof (OperationalLimitSet),
                                           assocObject);
  public void RemoveAllFromOperationalLimitSet () => RemoveAllAssocs1ToM (
      nameof (OperationalLimitSet));
}
/// <summary>
/// A wire or combination of wires, with consistent electrical characteristics,
/// building a single electrical system, used to carry alternating current
/// between points in the power system.For symmetrical, transposed three phase
/// lines, it is sufficient to use attributes of the line segment, which
/// describe impedances and admittances for the entire length of the segment.
/// Additionally impedances can be computed by using length and associated per
/// length impedances.The BaseVoltage at the two ends of ACLineSegments in a
/// Line shall have the same BaseVoltage.nominalVoltage. However, boundary lines
/// may have slightly different BaseVoltage.nominalVoltages and variation is
/// allowed. Larger voltage difference in general requires use of an equivalent
/// branch.
/// </summary>
[CimClass (ClassUri)]
public partial class ACLineSegment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Conductor (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ACLineSegment";

  /// <summary>
  /// Zero sequence shunt (charging) susceptance, uniformly distributed, of the
  /// entire line section.
  /// </summary>
  public float ? b0ch
  {
    get => GetAttribute < float ? > (nameof (b0ch));
    set => SetAttribute (nameof (b0ch), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) susceptance, uniformly distributed, of
  /// the entire line section.  This value represents the full charging over the
  /// full length of the line.
  /// </summary>
  public float ? bch
  {
    get => GetAttribute < float ? > (nameof (bch));
    set => SetAttribute (nameof (bch), value);
  }
  /// <summary>
  /// Zero sequence shunt (charging) conductance, uniformly distributed, of the
  /// entire line section.
  /// </summary>
  public float ? g0ch
  {
    get => GetAttribute < float ? > (nameof (g0ch));
    set => SetAttribute (nameof (g0ch), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) conductance, uniformly distributed, of
  /// the entire line section.
  /// </summary>
  public float ? gch
  {
    get => GetAttribute < float ? > (nameof (gch));
    set => SetAttribute (nameof (gch), value);
  }
  /// <summary>
  /// Positive sequence series resistance of the entire line section.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence series resistance of the entire line section.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Positive sequence series reactance of the entire line section.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero sequence series reactance of the entire line section.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  /// Per-length impedance of this line segment.
  /// </summary>
  public PerLengthImpedance ? PerLengthImpedance
  {
    get => GetAssoc1To1<PerLengthImpedance> (nameof (PerLengthImpedance));
    set => SetAssoc1To1 (nameof (PerLengthImpedance), value);
  }

  /// <summary>
  /// The line segment phases which belong to the line segment.
  /// </summary>
  public ACLineSegmentPhase[] ACLineSegmentPhases => GetAssoc1ToM<
      ACLineSegmentPhase> (nameof (ACLineSegmentPhases));
  public void
  AddToACLineSegmentPhases (ACLineSegmentPhase assocObject) => AddAssoc1ToM (
      nameof (ACLineSegmentPhases), assocObject);
  public void RemoveFromACLineSegmentPhases (
      ACLineSegmentPhase
          assocObject) => RemoveAssoc1ToM (nameof (ACLineSegmentPhases),
                                           assocObject);
  public void RemoveAllFromACLineSegmentPhases () => RemoveAllAssocs1ToM (
      nameof (ACLineSegmentPhases));
  /// <summary>
  ///
  /// </summary>
  public ACLineSeriesSection[] ACLineSeriesSections => GetAssoc1ToM<
      ACLineSeriesSection> (nameof (ACLineSeriesSections));
  public void
  AddToACLineSeriesSections (ACLineSeriesSection assocObject) => AddAssoc1ToM (
      nameof (ACLineSeriesSections), assocObject);
  public void RemoveFromACLineSeriesSections (
      ACLineSeriesSection
          assocObject) => RemoveAssoc1ToM (nameof (ACLineSeriesSections),
                                           assocObject);
  public void RemoveAllFromACLineSeriesSections () => RemoveAllAssocs1ToM (
      nameof (ACLineSeriesSections));
}
/// <summary>
/// Represents a single wire of an alternating current line segment.
/// </summary>
[CimClass (ClassUri)]
public partial class ACLineSegmentPhase
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ACLineSegmentPhase";

  /// <summary>
  /// The phase connection of the wire at both ends.
  /// </summary>
  public SinglePhaseKind ? phase
  {
    get => GetAttribute < SinglePhaseKind ? > (nameof (phase));
    set => SetAttribute (nameof (phase), value);
  }
  /// <summary>
  /// Number designation for this line segment phase. Each line segment phase
  /// within a line segment should have a unique sequence number. This is useful
  /// for unbalanced modelling to bind the mathematical model
  /// (PhaseImpedanceData of PerLengthPhaseImpedance) with the connectivity
  /// model (this class) and the physical model (WirePosition) without tight
  /// coupling.
  /// </summary>
  public int ? sequenceNumber
  {
    get => GetAttribute < int ? > (nameof (sequenceNumber));
    set => SetAttribute (nameof (sequenceNumber), value);
  }

  /// <summary>
  /// The line segment to which the phase belongs.
  /// </summary>
  public ACLineSegment ? ACLineSegment
  {
    get => GetAssoc1To1<ACLineSegment> (nameof (ACLineSegment));
    set => SetAssoc1To1 (nameof (ACLineSegment), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ACLineSeriesSection
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ACLineSeriesSection";

  /// <summary>
  ///
  /// </summary>
  public float ? b0ch
  {
    get => GetAttribute < float ? > (nameof (b0ch));
    set => SetAttribute (nameof (b0ch), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? bch
  {
    get => GetAttribute < float ? > (nameof (bch));
    set => SetAttribute (nameof (bch), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? distance
  {
    get => GetAttribute < float ? > (nameof (distance));
    set => SetAttribute (nameof (distance), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? g0ch
  {
    get => GetAttribute < float ? > (nameof (g0ch));
    set => SetAttribute (nameof (g0ch), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? gch
  {
    get => GetAttribute < float ? > (nameof (gch));
    set => SetAttribute (nameof (gch), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? length
  {
    get => GetAttribute < float ? > (nameof (length));
    set => SetAttribute (nameof (length), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? sectionNumber
  {
    get => GetAttribute < object ? > (nameof (sectionNumber));
    set => SetAttribute (nameof (sectionNumber), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  ///
  /// </summary>
  public ACLineSegment ? ACLineSegment
  {
    get => GetAssoc1To1<ACLineSegment> (nameof (ACLineSegment));
    set => SetAssoc1To1 (nameof (ACLineSegment), value);
  }
  /// <summary>
  ///
  /// </summary>
  public PerLengthImpedance ? PerLengthImpedance
  {
    get => GetAssoc1To1<PerLengthImpedance> (nameof (PerLengthImpedance));
    set => SetAssoc1To1 (nameof (PerLengthImpedance), value);
  }
  /// <summary>
  ///
  /// </summary>
  public Terminal ? Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }
}
/// <summary>
/// Limit on active power flow.
/// </summary>
[CimClass (ClassUri)]
public partial class ActivePowerLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OperationalLimit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ActivePowerLimit";

  /// <summary>
  /// The normal value of active power limit. The attribute shall be a positive
  /// value or zero.
  /// </summary>
  public float ? normalValue
  {
    get => GetAttribute < float ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }
  /// <summary>
  /// Value of active power limit. The attribute shall be a positive value or
  /// zero.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Records activity for an entity at a point in time; activity may be for an
/// event that has already occurred or for a planned activity.
/// </summary>
[CimClass (ClassUri)]
public partial class ActivityRecord
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ActivityRecord";

  /// <summary>
  /// Date and time this activity record has been created (different from the
  /// 'status.dateTime', which is the time of a status change of the associated
  /// object, if applicable).
  /// </summary>
  public DateTime ? createdDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (createdDateTime));
    set => SetAttribute (nameof (createdDateTime), value);
  }
  /// <summary>
  /// Reason for event resulting in this activity record, typically supplied
  /// when user initiated.
  /// </summary>
  public string ? reason
  {
    get => GetAttribute < string ? > (nameof (reason));
    set => SetAttribute (nameof (reason), value);
  }
  /// <summary>
  /// Severity level of event resulting in this activity record.
  /// </summary>
  public string ? severity
  {
    get => GetAttribute < string ? > (nameof (severity));
    set => SetAttribute (nameof (severity), value);
  }
  /// <summary>
  /// Information on consequence of event resulting in this activity record.
  /// </summary>
  public Status ? status
  {
    get => GetAttribute < Status ? > (nameof (status));
    set => SetAttribute (nameof (status), value);
  }
  /// <summary>
  /// Type of event resulting in this activity record.
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }

  /// <summary>
  /// All assets for which this activity record has been created.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
}
/// <summary>
/// Formal agreement between two parties defining the terms and conditions for a
/// set of services. The specifics of the services are, in turn, defined via one
/// or more service agreements.
/// </summary>
[CimClass (ClassUri)]
public partial class Agreement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Document (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Agreement";

  /// <summary>
  /// Date this agreement was consummated among associated persons and/or
  /// organisations.
  /// </summary>
  public DateTime ? signDate
  {
    get => GetAttribute < DateTime ? > (nameof (signDate));
    set => SetAttribute (nameof (signDate), value);
  }
  /// <summary>
  /// Date and time interval this agreement is valid (from going into effect to
  /// termination).
  /// </summary>
  public DateTimeInterval ? validityInterval
  {
    get => GetAttribute < DateTimeInterval ? > (nameof (validityInterval));
    set => SetAttribute (nameof (validityInterval), value);
  }
}
/// <summary>
/// Analog represents an analog Measurement.
/// </summary>
[CimClass (ClassUri)]
public partial class Analog
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Measurement (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Analog";

  /// <summary>
  /// Normal value range maximum for any of the MeasurementValue.values. Used
  /// for scaling, e.g. in bar graphs or of telemetered raw values.
  /// </summary>
  public float ? maxValue
  {
    get => GetAttribute < float ? > (nameof (maxValue));
    set => SetAttribute (nameof (maxValue), value);
  }
  /// <summary>
  /// Normal value range minimum for any of the MeasurementValue.values. Used
  /// for scaling, e.g. in bar graphs or of telemetered raw values.
  /// </summary>
  public float ? minValue
  {
    get => GetAttribute < float ? > (nameof (minValue));
    set => SetAttribute (nameof (minValue), value);
  }
  /// <summary>
  /// Normal measurement value, e.g., used for percentage calculations.
  /// </summary>
  public float ? normalValue
  {
    get => GetAttribute < float ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }
  /// <summary>
  /// If true then this measurement is an active power, reactive power or
  /// current with the convention that a positive value measured at the Terminal
  /// means power is flowing into the related PowerSystemResource.
  /// </summary>
  public bool ? positiveFlowIn
  {
    get => GetAttribute < bool ? > (nameof (positiveFlowIn));
    set => SetAttribute (nameof (positiveFlowIn), value);
  }

  /// <summary>
  /// The values connected to this measurement.
  /// </summary>
  public AnalogValue[] AnalogValues => GetAssoc1ToM<AnalogValue> (
      nameof (AnalogValues));
  public void AddToAnalogValues (AnalogValue assocObject) => AddAssoc1ToM (
      nameof (AnalogValues), assocObject);
  public void RemoveFromAnalogValues (
      AnalogValue assocObject) => RemoveAssoc1ToM (nameof (AnalogValues),
                                                   assocObject);
  public void RemoveAllFromAnalogValues () => RemoveAllAssocs1ToM (
      nameof (AnalogValues));
}
/// <summary>
/// AnalogValue represents an analog MeasurementValue.
/// </summary>
[CimClass (ClassUri)]
public partial class AnalogValue
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : MeasurementValue (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AnalogValue";

  /// <summary>
  /// The value to supervise.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }

  /// <summary>
  /// Measurement to which this value is connected.
  /// </summary>
  public Analog ? Analog
  {
    get => GetAssoc1To1<Analog> (nameof (Analog));
    set => SetAssoc1To1 (nameof (Analog), value);
  }
}
/// <summary>
/// An indicative scoring by an analytic that can be used to characterize the
/// health of or the risk associated with one or more assets.  The analytic
/// score reflects the results of an execution of an analytic against an asset
/// or group of assets.
/// </summary>
[CimClass (ClassUri)]
public partial class AnalyticScore
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AnalyticScore";
}
/// <summary>
/// Tangible resource of the utility, including power system equipment, various
/// end devices, cabinets, buildings, etc. For electrical network equipment, the
/// role of the asset is defined through PowerSystemResource and its subclasses,
/// defined mainly in the Wires model (refer to IEC61970-301 and model package
/// IEC61970::Wires). Asset description places emphasis on the physical
/// characteristics of the equipment fulfilling that role.
/// </summary>
[CimClass (ClassUri)]
public partial class Asset
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Asset";

  /// <summary>
  /// Electronic address.
  /// </summary>
  public ElectronicAddress ? electronicAddress
  {
    get => GetAttribute < ElectronicAddress ? > (nameof (electronicAddress));
    set => SetAttribute (nameof (electronicAddress), value);
  }
  /// <summary>
  /// In use dates for this asset.
  /// </summary>
  public InUseDate ? inUseDate
  {
    get => GetAttribute < InUseDate ? > (nameof (inUseDate));
    set => SetAttribute (nameof (inUseDate), value);
  }
  /// <summary>
  /// Indication of whether asset is currently deployed (in use), ready to be
  /// put into use or not available for use.
  /// </summary>
  public InUseStateKind ? inUseState
  {
    get => GetAttribute < InUseStateKind ? > (nameof (inUseState));
    set => SetAttribute (nameof (inUseState), value);
  }
  /// <summary>
  /// <was lifecycle>Lifecycle dates for this asset.
  /// </summary>
  public LifecycleDate ? lifecycleDate
  {
    get => GetAttribute < LifecycleDate ? > (nameof (lifecycleDate));
    set => SetAttribute (nameof (lifecycleDate), value);
  }
  /// <summary>
  /// Lot number for this asset. Even for the same model and version number,
  /// many assets are manufactured in lots.
  /// </summary>
  public string ? lotNumber
  {
    get => GetAttribute < string ? > (nameof (lotNumber));
    set => SetAttribute (nameof (lotNumber), value);
  }
  /// <summary>
  /// Position of asset or asset component. May often be in relation to other
  /// assets or components.
  /// </summary>
  public string ? position
  {
    get => GetAttribute < string ? > (nameof (position));
    set => SetAttribute (nameof (position), value);
  }
  /// <summary>
  /// Serial number of this asset.
  /// </summary>
  public string ? serialNumber
  {
    get => GetAttribute < string ? > (nameof (serialNumber));
    set => SetAttribute (nameof (serialNumber), value);
  }
  /// <summary>
  /// Status of this asset.
  /// </summary>
  public Status ? status
  {
    get => GetAttribute < Status ? > (nameof (status));
    set => SetAttribute (nameof (status), value);
  }
  /// <summary>
  /// Utility-specific classification of Asset and its subtypes, according to
  /// their corporate standards, practices, and existing IT systems (e.g., for
  /// management of assets, maintenance, work, outage, customers, etc.).
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
  /// <summary>
  /// Uniquely tracked commodity (UTC) number.
  /// </summary>
  public string ? utcNumber
  {
    get => GetAttribute < string ? > (nameof (utcNumber));
    set => SetAttribute (nameof (utcNumber), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? baselineCondition
  {
    get => GetAttribute < string ? > (nameof (baselineCondition));
    set => SetAttribute (nameof (baselineCondition), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? baselineLossOfLife
  {
    get => GetAttribute < float ? > (nameof (baselineLossOfLife));
    set => SetAttribute (nameof (baselineLossOfLife), value);
  }

  /// <summary>
  /// Container of this asset.
  /// </summary>
  public AssetContainer ? AssetContainer
  {
    get => GetAssoc1To1<AssetContainer> (nameof (AssetContainer));
    set => SetAssoc1To1 (nameof (AssetContainer), value);
  }
  /// <summary>
  /// This asset's deployment.
  /// </summary>
  public AssetDeployment ? AssetDeployment
  {
    get => GetAssoc1To1<AssetDeployment> (nameof (AssetDeployment));
    set => SetAssoc1To1 (nameof (AssetDeployment), value);
  }
  /// <summary>
  /// Data applicable to this asset.
  /// </summary>
  public AssetInfo ? AssetInfo
  {
    get => GetAssoc1To1<AssetInfo> (nameof (AssetInfo));
    set => SetAssoc1To1 (nameof (AssetInfo), value);
  }
  /// <summary>
  ///
  /// </summary>
  public ErpItemMaster ? ErpItemMaster
  {
    get => GetAssoc1To1<ErpItemMaster> (nameof (ErpItemMaster));
    set => SetAssoc1To1 (nameof (ErpItemMaster), value);
  }
  /// <summary>
  /// Location of this asset.
  /// </summary>
  public Location ? Location
  {
    get => GetAssoc1To1<Location> (nameof (Location));
    set => SetAssoc1To1 (nameof (Location), value);
  }
  /// <summary>
  /// The model of this asset.
  /// </summary>
  public ProductAssetModel ? ProductAssetModel
  {
    get => GetAssoc1To1<ProductAssetModel> (nameof (ProductAssetModel));
    set => SetAssoc1To1 (nameof (ProductAssetModel), value);
  }

  /// <summary>
  /// All activity records created for this asset.
  /// </summary>
  public ActivityRecord[] ActivityRecords => GetAssoc1ToM<ActivityRecord> (
      nameof (ActivityRecords));
  public void AddToActivityRecords (
      ActivityRecord assocObject) => AddAssoc1ToM (nameof (ActivityRecords),
                                                   assocObject);
  public void RemoveFromActivityRecords (
      ActivityRecord assocObject) => RemoveAssoc1ToM (nameof (ActivityRecords),
                                                      assocObject);
  public void RemoveAllFromActivityRecords () => RemoveAllAssocs1ToM (
      nameof (ActivityRecords));
  /// <summary>
  /// Analytic result related to this asset.
  /// </summary>
  public AnalyticScore[] AnalyticScore => GetAssoc1ToM<AnalyticScore> (
      nameof (AnalyticScore));
  public void AddToAnalyticScore (AnalyticScore assocObject) => AddAssoc1ToM (
      nameof (AnalyticScore), assocObject);
  public void RemoveFromAnalyticScore (
      AnalyticScore assocObject) => RemoveAssoc1ToM (nameof (AnalyticScore),
                                                     assocObject);
  public void RemoveAllFromAnalyticScore () => RemoveAllAssocs1ToM (
      nameof (AnalyticScore));
  /// <summary>
  /// All configuration events created for this asset.
  /// </summary>
  public ConfigurationEvent[] ConfigurationEvents => GetAssoc1ToM<
      ConfigurationEvent> (nameof (ConfigurationEvents));
  public void
  AddToConfigurationEvents (ConfigurationEvent assocObject) => AddAssoc1ToM (
      nameof (ConfigurationEvents), assocObject);
  public void RemoveFromConfigurationEvents (
      ConfigurationEvent
          assocObject) => RemoveAssoc1ToM (nameof (ConfigurationEvents),
                                           assocObject);
  public void RemoveAllFromConfigurationEvents () => RemoveAllAssocs1ToM (
      nameof (ConfigurationEvents));
  /// <summary>
  /// All power system resources used to electrically model this asset. For
  /// example, transformer asset is electrically modelled with a transformer and
  /// its windings and tap changer.
  /// </summary>
  public PowerSystemResource[] PowerSystemResources => GetAssoc1ToM<
      PowerSystemResource> (nameof (PowerSystemResources));
  public void
  AddToPowerSystemResources (PowerSystemResource assocObject) => AddAssoc1ToM (
      nameof (PowerSystemResources), assocObject);
  public void RemoveFromPowerSystemResources (
      PowerSystemResource
          assocObject) => RemoveAssoc1ToM (nameof (PowerSystemResources),
                                           assocObject);
  public void RemoveAllFromPowerSystemResources () => RemoveAllAssocs1ToM (
      nameof (PowerSystemResources));
}
/// <summary>
/// Asset that is aggregation of other assets such as conductors, transformers,
/// switchgear, land, fences, buildings, equipment, vehicles, etc.
/// </summary>
[CimClass (ClassUri)]
public partial class AssetContainer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Asset (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AssetContainer";

  /// <summary>
  /// All assets within this container asset.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
  /// <summary>
  /// All seals applied to this asset container.
  /// </summary>
  public Seal[] Seals => GetAssoc1ToM<Seal> (nameof (Seals));
  public void AddToSeals (Seal assocObject) => AddAssoc1ToM (nameof (Seals),
                                                             assocObject);
  public void RemoveFromSeals (Seal assocObject) => RemoveAssoc1ToM (
      nameof (Seals), assocObject);
  public void RemoveAllFromSeals () => RemoveAllAssocs1ToM (nameof (Seals));
}
/// <summary>
/// Deployment of asset deployment in a power system resource role.
/// </summary>
[CimClass (ClassUri)]
public partial class AssetDeployment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#AssetDeployment";

  /// <summary>
  /// Dates of asset deployment.
  /// </summary>
  public DeploymentDate ? deploymentDate
  {
    get => GetAttribute < DeploymentDate ? > (nameof (deploymentDate));
    set => SetAttribute (nameof (deploymentDate), value);
  }
  /// <summary>
  /// Current deployment state of asset.
  /// </summary>
  public DeploymentStateKind ? deploymentState
  {
    get => GetAttribute < DeploymentStateKind ? > (nameof (deploymentState));
    set => SetAttribute (nameof (deploymentState), value);
  }
  /// <summary>
  /// Kind of facility (like substation or pole or building or plant or service
  /// center) at which asset deployed.
  /// </summary>
  public FacilityKind ? facilityKind
  {
    get => GetAttribute < FacilityKind ? > (nameof (facilityKind));
    set => SetAttribute (nameof (facilityKind), value);
  }

  /// <summary>
  /// Asset in this deployment.
  /// </summary>
  public Asset ? Asset
  {
    get => GetAssoc1To1<Asset> (nameof (Asset));
    set => SetAssoc1To1 (nameof (Asset), value);
  }
  /// <summary>
  /// Base voltage of this network asset deployment.
  /// </summary>
  public BaseVoltage ? BaseVoltage
  {
    get => GetAssoc1To1<BaseVoltage> (nameof (BaseVoltage));
    set => SetAssoc1To1 (nameof (BaseVoltage), value);
  }
}
/// <summary>
/// Function performed by an asset.
/// </summary>
[CimClass (ClassUri)]
public partial class AssetFunction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AssetFunction";

  /// <summary>
  /// Configuration specified for this function.
  /// </summary>
  public string ? configID
  {
    get => GetAttribute < string ? > (nameof (configID));
    set => SetAttribute (nameof (configID), value);
  }
  /// <summary>
  /// Firmware version.
  /// </summary>
  public string ? firmwareID
  {
    get => GetAttribute < string ? > (nameof (firmwareID));
    set => SetAttribute (nameof (firmwareID), value);
  }
  /// <summary>
  /// Hardware version.
  /// </summary>
  public string ? hardwareID
  {
    get => GetAttribute < string ? > (nameof (hardwareID));
    set => SetAttribute (nameof (hardwareID), value);
  }
  /// <summary>
  /// Password needed to access this function.
  /// </summary>
  public string ? password
  {
    get => GetAttribute < string ? > (nameof (password));
    set => SetAttribute (nameof (password), value);
  }
  /// <summary>
  /// Name of program.
  /// </summary>
  public string ? programID
  {
    get => GetAttribute < string ? > (nameof (programID));
    set => SetAttribute (nameof (programID), value);
  }
}
/// <summary>
/// Set of attributes of an asset, representing typical datasheet information of
/// a physical device that can be instantiated and shared in different data
/// exchange contexts:- as attributes of an asset instance (installed or in
/// stock)- as attributes of an asset model (product by a manufacturer)- as
/// attributes of a type asset (generic type of an asset as used in
/// designs/extension planning).
/// </summary>
[CimClass (ClassUri)]
public partial class AssetInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AssetInfo";

  /// <summary>
  /// Product asset model which conforms to this catalog asset type.
  /// </summary>
  public ProductAssetModel ? ProductAssetModel
  {
    get => GetAssoc1To1<ProductAssetModel> (nameof (ProductAssetModel));
    set => SetAssoc1To1 (nameof (ProductAssetModel), value);
  }

  /// <summary>
  /// All assets described by this data.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
  /// <summary>
  /// All power system resources with this datasheet information.
  /// </summary>
  public PowerSystemResource[] PowerSystemResources => GetAssoc1ToM<
      PowerSystemResource> (nameof (PowerSystemResources));
  public void
  AddToPowerSystemResources (PowerSystemResource assocObject) => AddAssoc1ToM (
      nameof (PowerSystemResources), assocObject);
  public void RemoveFromPowerSystemResources (
      PowerSystemResource
          assocObject) => RemoveAssoc1ToM (nameof (PowerSystemResources),
                                           assocObject);
  public void RemoveAllFromPowerSystemResources () => RemoveAllAssocs1ToM (
      nameof (PowerSystemResources));
}
/// <summary>
/// Role an organisation plays with respect to asset.
/// </summary>
[CimClass (ClassUri)]
public partial class AssetOrganisationRole
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OrganisationRole (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#AssetOrganisationRole";

  /// <summary>
  /// All assets for this organisation role.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
}
/// <summary>
/// Owner of the asset.
/// </summary>
[CimClass (ClassUri)]
public partial class AssetOwner
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetOrganisationRole (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#AssetOwner";
}
/// <summary>
/// A rotating machine whose shaft rotates asynchronously with the electrical
/// field.  Also known as an induction machine with no external connection to
/// the rotor windings, e.g. squirrel-cage induction machine.
/// </summary>
[CimClass (ClassUri)]
public partial class AsynchronousMachine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RotatingMachine (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#AsynchronousMachine";

  /// <summary>
  /// Indicates the type of Asynchronous Machine (motor or generator).
  /// </summary>
  public AsynchronousMachineKind ? asynchronousMachineType
  {
    get => GetAttribute < AsynchronousMachineKind
        ? > (nameof (asynchronousMachineType));
    set => SetAttribute (nameof (asynchronousMachineType), value);
  }
  /// <summary>
  /// Efficiency of the asynchronous machine at nominal operation as a
  /// percentage. Indicator for converter drive motors. Used for short circuit
  /// data exchange according to IEC 60909.
  /// </summary>
  public float ? efficiency
  {
    get => GetAttribute < float ? > (nameof (efficiency));
    set => SetAttribute (nameof (efficiency), value);
  }
  /// <summary>
  /// Rated mechanical power (Pr in IEC 60909-0). Used for short circuit data
  /// exchange according to IEC 60909.
  /// </summary>
  public float ? ratedMechanicalPower
  {
    get => GetAttribute < float ? > (nameof (ratedMechanicalPower));
    set => SetAttribute (nameof (ratedMechanicalPower), value);
  }

  /// <summary>
  ///
  /// </summary>
  public AsynchronousMachineReactiveCapabilityCurve ? ReactiveCapabilityCurve
  {
    get => GetAssoc1To1<AsynchronousMachineReactiveCapabilityCurve> (
        nameof (ReactiveCapabilityCurve));
    set => SetAssoc1To1 (nameof (ReactiveCapabilityCurve), value);
  }
  /// <summary>
  ///
  /// </summary>
  public TorqueSpeedCurve ? TorqueSpeedCurve
  {
    get => GetAssoc1To1<TorqueSpeedCurve> (nameof (TorqueSpeedCurve));
    set => SetAssoc1To1 (nameof (TorqueSpeedCurve), value);
  }
  /// <summary>
  ///
  /// </summary>
  public PrimeMover ? PrimeMover
  {
    get => GetAssoc1To1<PrimeMover> (nameof (PrimeMover));
    set => SetAssoc1To1 (nameof (PrimeMover), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class AsynchronousMachineReactiveCapabilityCurve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Curve (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/"
        + "schema-cim01#AsynchronousMachineReactiveCapabilityCurve";

  /// <summary>
  ///
  /// </summary>
  public AsynchronousMachine[] AsynchronousMachine => GetAssoc1ToM<
      AsynchronousMachine> (nameof (AsynchronousMachine));
  public void
  AddToAsynchronousMachine (AsynchronousMachine assocObject) => AddAssoc1ToM (
      nameof (AsynchronousMachine), assocObject);
  public void RemoveFromAsynchronousMachine (
      AsynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (AsynchronousMachine),
                                           assocObject);
  public void RemoveAllFromAsynchronousMachine () => RemoveAllAssocs1ToM (
      nameof (AsynchronousMachine));
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class AsynchronousMachinelnfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RotatingMachineInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#AsynchronousMachinelnfo";

  /// <summary>
  ///
  /// </summary>
  public float ? maxTorque
  {
    get => GetAttribute < float ? > (nameof (maxTorque));
    set => SetAttribute (nameof (maxTorque), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? startCurrent
  {
    get => GetAttribute < float ? > (nameof (startCurrent));
    set => SetAttribute (nameof (startCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? startingTorque
  {
    get => GetAttribute < float ? > (nameof (startingTorque));
    set => SetAttribute (nameof (startingTorque), value);
  }
}
/// <summary>
/// AuxiliaryEquipment describe equipment that is not performing any primary
/// functions but support for the equipment performing the primary
/// function.AuxiliaryEquipment is attached to primary equipment via an
/// association with Terminal.
/// </summary>
[CimClass (ClassUri)]
public partial class AuxiliaryEquipment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#AuxiliaryEquipment";

  /// <summary>
  /// The Terminal at the equipment where the AuxiliaryEquipment is attached.
  /// </summary>
  public Terminal ? Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }
}
/// <summary>
/// Boiling water reactor used as a steam supply to a steam turbine.
/// </summary>
[CimClass (ClassUri)]
public partial class BWRSteamSupply
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SteamSupply (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#BWRSteamSupply";
}
/// <summary>
/// Common representation for reading values. Note that a reading value may have
/// multiple qualities, as produced by various systems
/// ('ReadingQuality.source').
/// </summary>
[CimClass (ClassUri)]
public partial class BaseReading
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : MeasurementValue (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#BaseReading";

  /// <summary>
  /// (used only when there are detailed auditing requirements) Date and time at
  /// which the reading was first delivered to the metering system.
  /// </summary>
  public DateTime ? reportedDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (reportedDateTime));
    set => SetAttribute (nameof (reportedDateTime), value);
  }
  /// <summary>
  /// System that originally supplied the reading (e.g., customer, AMI system,
  /// handheld reading system, another enterprise system, etc.).
  /// </summary>
  public string ? source
  {
    get => GetAttribute < string ? > (nameof (source));
    set => SetAttribute (nameof (source), value);
  }
  /// <summary>
  /// Start and end of the period for those readings whose type has a time
  /// attribute such as 'billing', seasonal' or 'forTheSpecifiedPeriod'.
  /// </summary>
  public DateTimeInterval ? timePeriod
  {
    get => GetAttribute < DateTimeInterval ? > (nameof (timePeriod));
    set => SetAttribute (nameof (timePeriod), value);
  }
  /// <summary>
  /// Value of this reading.
  /// </summary>
  public string ? value
  {
    get => GetAttribute < string ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }

  /// <summary>
  /// All qualities of this reading.
  /// </summary>
  public ReadingQuality[] ReadingQualities => GetAssoc1ToM<ReadingQuality> (
      nameof (ReadingQualities));
  public void AddToReadingQualities (
      ReadingQuality assocObject) => AddAssoc1ToM (nameof (ReadingQualities),
                                                   assocObject);
  public void RemoveFromReadingQualities (
      ReadingQuality assocObject) => RemoveAssoc1ToM (nameof (ReadingQualities),
                                                      assocObject);
  public void RemoveAllFromReadingQualities () => RemoveAllAssocs1ToM (
      nameof (ReadingQualities));
}
/// <summary>
/// Defines a system base voltage which is referenced.
/// </summary>
[CimClass (ClassUri)]
public partial class BaseVoltage
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#BaseVoltage";

  /// <summary>
  /// The power system resource's base voltage.  Shall be a positive value and
  /// not zero.
  /// </summary>
  public float ? nominalVoltage
  {
    get => GetAttribute < float ? > (nameof (nominalVoltage));
    set => SetAttribute (nameof (nominalVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? isDC
  {
    get => GetAttribute < bool ? > (nameof (isDC));
    set => SetAttribute (nameof (isDC), value);
  }

  /// <summary>
  /// All conducting equipment with this base voltage.  Use only when there is
  /// no voltage level container used and only one base voltage applies.  For
  /// example, not used for transformers.
  /// </summary>
  public ConductingEquipment[] ConductingEquipment => GetAssoc1ToM<
      ConductingEquipment> (nameof (ConductingEquipment));
  public void
  AddToConductingEquipment (ConductingEquipment assocObject) => AddAssoc1ToM (
      nameof (ConductingEquipment), assocObject);
  public void RemoveFromConductingEquipment (
      ConductingEquipment
          assocObject) => RemoveAssoc1ToM (nameof (ConductingEquipment),
                                           assocObject);
  public void RemoveAllFromConductingEquipment () => RemoveAllAssocs1ToM (
      nameof (ConductingEquipment));
  /// <summary>
  /// A network asset deployment at this base voltage level.
  /// </summary>
  public AssetDeployment[] NetworkAssetDeployment => GetAssoc1ToM<
      AssetDeployment> (nameof (NetworkAssetDeployment));
  public void
  AddToNetworkAssetDeployment (AssetDeployment assocObject) => AddAssoc1ToM (
      nameof (NetworkAssetDeployment), assocObject);
  public void RemoveFromNetworkAssetDeployment (
      AssetDeployment
          assocObject) => RemoveAssoc1ToM (nameof (NetworkAssetDeployment),
                                           assocObject);
  public void RemoveAllFromNetworkAssetDeployment () => RemoveAllAssocs1ToM (
      nameof (NetworkAssetDeployment));
  /// <summary>
  /// Transformer ends at the base voltage.  This is essential for PU
  /// calculation.
  /// </summary>
  public TransformerEnd[] TransformerEnds => GetAssoc1ToM<TransformerEnd> (
      nameof (TransformerEnds));
  public void AddToTransformerEnds (
      TransformerEnd assocObject) => AddAssoc1ToM (nameof (TransformerEnds),
                                                   assocObject);
  public void RemoveFromTransformerEnds (
      TransformerEnd assocObject) => RemoveAssoc1ToM (nameof (TransformerEnds),
                                                      assocObject);
  public void RemoveAllFromTransformerEnds () => RemoveAllAssocs1ToM (
      nameof (TransformerEnds));
  /// <summary>
  /// The voltage levels having this base voltage.
  /// </summary>
  public VoltageLevel[] VoltageLevel => GetAssoc1ToM<VoltageLevel> (
      nameof (VoltageLevel));
  public void AddToVoltageLevel (VoltageLevel assocObject) => AddAssoc1ToM (
      nameof (VoltageLevel), assocObject);
  public void RemoveFromVoltageLevel (
      VoltageLevel assocObject) => RemoveAssoc1ToM (nameof (VoltageLevel),
                                                    assocObject);
  public void RemoveAllFromVoltageLevel () => RemoveAllAssocs1ToM (
      nameof (VoltageLevel));
}
/// <summary>
/// A collection of power system resources (within a given substation) including
/// conducting equipment, protection relays, measurements, and telemetry.  A bay
/// typically represents a physical grouping related to modularization of
/// equipment.
/// </summary>
[CimClass (ClassUri)]
public partial class Bay
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Bay";

  /// <summary>
  /// Breaker configuration.
  /// </summary>
  public BreakerConfiguration ? breakerConfiguration
  {
    get => GetAttribute < BreakerConfiguration
        ? > (nameof (breakerConfiguration));
    set => SetAttribute (nameof (breakerConfiguration), value);
  }
  /// <summary>
  /// Busbar configuration.
  /// </summary>
  public BusbarConfiguration ? busBarConfiguration
  {
    get => GetAttribute < BusbarConfiguration
        ? > (nameof (busBarConfiguration));
    set => SetAttribute (nameof (busBarConfiguration), value);
  }

  /// <summary>
  /// The voltage level containing this bay.
  /// </summary>
  public VoltageLevel ? VoltageLevel
  {
    get => GetAssoc1To1<VoltageLevel> (nameof (VoltageLevel));
    set => SetAssoc1To1 (nameof (VoltageLevel), value);
  }
}
/// <summary>
/// A mechanical switching device capable of making, carrying, and breaking
/// currents under normal circuit conditions and also making, carrying for a
/// specified time, and breaking currents under specified abnormal circuit
/// conditions e.g.  those of short circuit.
/// </summary>
[CimClass (ClassUri)]
public partial class Breaker
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ProtectedSwitch (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Breaker";

  /// <summary>
  /// The transition time from open to close.
  /// </summary>
  public float ? inTransitTime
  {
    get => GetAttribute < float ? > (nameof (inTransitTime));
    set => SetAttribute (nameof (inTransitTime), value);
  }
}
/// <summary>
/// Properties of breaker assets.
/// </summary>
[CimClass (ClassUri)]
public partial class BreakerInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OldSwitchInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#BreakerInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? interruptingTime
  {
    get => GetAttribute < float ? > (nameof (interruptingTime));
    set => SetAttribute (nameof (interruptingTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedRecloseTime
  {
    get => GetAttribute < float ? > (nameof (ratedRecloseTime));
    set => SetAttribute (nameof (ratedRecloseTime), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class BrushlessExciterlnfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#BrushlessExciterlnfo";

  /// <summary>
  ///
  /// </summary>
  public float ? deexcitationRatio
  {
    get => GetAttribute < float ? > (nameof (deexcitationRatio));
    set => SetAttribute (nameof (deexcitationRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? forcingRatio
  {
    get => GetAttribute < float ? > (nameof (forcingRatio));
    set => SetAttribute (nameof (forcingRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? nominalP
  {
    get => GetAttribute < float ? > (nameof (nominalP));
    set => SetAttribute (nameof (nominalP), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rAdditionalResistor
  {
    get => GetAttribute < float ? > (nameof (rAdditionalResistor));
    set => SetAttribute (nameof (rAdditionalResistor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rExcitationWinding
  {
    get => GetAttribute < float ? > (nameof (rExcitationWinding));
    set => SetAttribute (nameof (rExcitationWinding), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotorResistance
  {
    get => GetAttribute < float ? > (nameof (rotorResistance));
    set => SetAttribute (nameof (rotorResistance), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? td
  {
    get => GetAttribute < float ? > (nameof (td));
    set => SetAttribute (nameof (td), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xDirectSubtrans
  {
    get => GetAttribute < float ? > (nameof (xDirectSubtrans));
    set => SetAttribute (nameof (xDirectSubtrans), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xDirectSync
  {
    get => GetAttribute < float ? > (nameof (xDirectSync));
    set => SetAttribute (nameof (xDirectSync), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xDirectTrans
  {
    get => GetAttribute < float ? > (nameof (xDirectTrans));
    set => SetAttribute (nameof (xDirectTrans), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xQuadSubtrans
  {
    get => GetAttribute < float ? > (nameof (xQuadSubtrans));
    set => SetAttribute (nameof (xQuadSubtrans), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xQuadSync
  {
    get => GetAttribute < float ? > (nameof (xQuadSync));
    set => SetAttribute (nameof (xQuadSync), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? xs
  {
    get => GetAttribute < float ? > (nameof (xs));
    set => SetAttribute (nameof (xs), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class BusArrangement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AuxiliaryEquipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#BusArrangement";
}
/// <summary>
/// A conductor, or group of conductors, with negligible impedance, that serve
/// to connect other conducting equipment within a single substation. Voltage
/// measurements are typically obtained from voltage transformers that are
/// connected to busbar sections. A bus bar section may have many physical
/// terminals but for analysis is modelled with exactly one logical terminal.
/// </summary>
[CimClass (ClassUri)]
public partial class BusbarSection
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Connector (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#BusbarSection";

  /// <summary>
  /// Maximum allowable peak short-circuit current of busbar (Ipmax in IEC
  /// 60909-0). Mechanical limit of the busbar in the substation itself. Used
  /// for short circuit data exchange according to IEC 60909.
  /// </summary>
  public float ? ipMax
  {
    get => GetAttribute < float ? > (nameof (ipMax));
    set => SetAttribute (nameof (ipMax), value);
  }
}
/// <summary>
/// Busbar section data.
/// </summary>
[CimClass (ClassUri)]
public partial class BusbarSectionInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#BusbarSectionInfo";

  /// <summary>
  /// Rated current.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Rated voltage.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
}
/// <summary>
/// Cable data.
/// </summary>
[CimClass (ClassUri)]
public partial class CableInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : WireInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#CableInfo";

  /// <summary>
  /// Kind of construction of this cable.
  /// </summary>
  public CableConstructionKind ? constructionKind
  {
    get => GetAttribute < CableConstructionKind ? > (nameof (constructionKind));
    set => SetAttribute (nameof (constructionKind), value);
  }
  /// <summary>
  /// Diameter over the core, including any semi-con screen; should be the
  /// insulating layer's inside diameter.
  /// </summary>
  public float ? diameterOverCore
  {
    get => GetAttribute < float ? > (nameof (diameterOverCore));
    set => SetAttribute (nameof (diameterOverCore), value);
  }
  /// <summary>
  /// Diameter over the insulating layer, excluding outer screen.
  /// </summary>
  public float ? diameterOverInsulation
  {
    get => GetAttribute < float ? > (nameof (diameterOverInsulation));
    set => SetAttribute (nameof (diameterOverInsulation), value);
  }
  /// <summary>
  /// Diameter over the outermost jacketing layer.
  /// </summary>
  public float ? diameterOverJacket
  {
    get => GetAttribute < float ? > (nameof (diameterOverJacket));
    set => SetAttribute (nameof (diameterOverJacket), value);
  }
  /// <summary>
  /// Diameter over the outer screen; should be the shield's inside diameter.
  /// </summary>
  public float ? diameterOverScreen
  {
    get => GetAttribute < float ? > (nameof (diameterOverScreen));
    set => SetAttribute (nameof (diameterOverScreen), value);
  }
  /// <summary>
  /// Maximum nominal design operating temperature.
  /// </summary>
  public float ? nominalTemperature
  {
    get => GetAttribute < float ? > (nameof (nominalTemperature));
    set => SetAttribute (nameof (nominalTemperature), value);
  }
  /// <summary>
  /// Kind of outer jacket of this cable.
  /// </summary>
  public CableOuterJacketKind ? outerJacketKind
  {
    get => GetAttribute < CableOuterJacketKind ? > (nameof (outerJacketKind));
    set => SetAttribute (nameof (outerJacketKind), value);
  }
  /// <summary>
  /// Material of the shield.
  /// </summary>
  public CableShieldMaterialKind ? shieldMaterial
  {
    get => GetAttribute < CableShieldMaterialKind ? > (nameof (shieldMaterial));
    set => SetAttribute (nameof (shieldMaterial), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? insulationEr
  {
    get => GetAttribute < float ? > (nameof (insulationEr));
    set => SetAttribute (nameof (insulationEr), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? insulationErShield
  {
    get => GetAttribute < float ? > (nameof (insulationErShield));
    set => SetAttribute (nameof (insulationErShield), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? radialMoistureBarrierThicknes
  {
    get => GetAttribute < float ? > (nameof (radialMoistureBarrierThicknes));
    set => SetAttribute (nameof (radialMoistureBarrierThicknes), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? sheathThickness
  {
    get => GetAttribute < float ? > (nameof (sheathThickness));
    set => SetAttribute (nameof (sheathThickness), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? shieldCrossSection
  {
    get => GetAttribute < float ? > (nameof (shieldCrossSection));
    set => SetAttribute (nameof (shieldCrossSection), value);
  }
  /// <summary>
  ///
  /// </summary>
  public ShieldGroundingKind ? shieldGrounding
  {
    get => GetAttribute < ShieldGroundingKind ? > (nameof (shieldGrounding));
    set => SetAttribute (nameof (shieldGrounding), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? shieldIsTransposed
  {
    get => GetAttribute < bool ? > (nameof (shieldIsTransposed));
    set => SetAttribute (nameof (shieldIsTransposed), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? underShieldScreenThickness
  {
    get => GetAttribute < float ? > (nameof (underShieldScreenThickness));
    set => SetAttribute (nameof (underShieldScreenThickness), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class CapacityConfiguration
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#CapacityConfiguration";

  /// <summary>
  ///
  /// </summary>
  public float ? maximumCapacity
  {
    get => GetAttribute < float ? > (nameof (maximumCapacity));
    set => SetAttribute (nameof (maximumCapacity), value);
  }

  /// <summary>
  ///
  /// </summary>
  public CombinedCyclePlant ? CombinedCyclePlant
  {
    get => GetAssoc1To1<CombinedCyclePlant> (nameof (CombinedCyclePlant));
    set => SetAssoc1To1 (nameof (CombinedCyclePlant), value);
  }

  /// <summary>
  ///
  /// </summary>
  public ThermalGeneratingUnit[] ThermalGeneratingUnits => GetAssoc1ToM<
      ThermalGeneratingUnit> (nameof (ThermalGeneratingUnits));
  public void AddToThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => AddAssoc1ToM (nameof (ThermalGeneratingUnits),
                                        assocObject);
  public void RemoveFromThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => RemoveAssoc1ToM (nameof (ThermalGeneratingUnits),
                                           assocObject);
  public void RemoveAllFromThermalGeneratingUnits () => RemoveAllAssocs1ToM (
      nameof (ThermalGeneratingUnits));
}
/// <summary>
/// A single path for the collection or reporting of register values over a
/// period of time. For example, a register which measures forward energy can
/// have two channels, one providing bulk quantity readings and the other
/// providing interval readings of a fixed interval size.
/// </summary>
[CimClass (ClassUri)]
public partial class Channel
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Channel";

  /// <summary>
  /// If true, the data is being calculated by an enterprise system rather than
  /// metered directly.
  /// </summary>
  public bool ? isVirtual
  {
    get => GetAttribute < bool ? > (nameof (isVirtual));
    set => SetAttribute (nameof (isVirtual), value);
  }

  /// <summary>
  /// Reading type for register values reported/collected by this channel.
  /// </summary>
  public ReadingType ? ReadingType
  {
    get => GetAssoc1To1<ReadingType> (nameof (ReadingType));
    set => SetAssoc1To1 (nameof (ReadingType), value);
  }
}
/// <summary>
/// A set of thermal generating units for the production of electrical energy
/// and process steam (usually from the output of the steam turbines). The steam
/// sendout is typically used for industrial purposes or for municipal heating
/// and cooling.
/// </summary>
[CimClass (ClassUri)]
public partial class CogenerationPlant
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CogenerationPlant";

  /// <summary>
  /// The rated output active power of the cogeneration plant.The attribute
  /// shall be a positive value.
  /// </summary>
  public float ? ratedP
  {
    get => GetAttribute < float ? > (nameof (ratedP));
    set => SetAttribute (nameof (ratedP), value);
  }

  /// <summary>
  /// A thermal generating unit may be a member of a cogeneration plant.
  /// </summary>
  public ThermalGeneratingUnit[] ThermalGeneratingUnits => GetAssoc1ToM<
      ThermalGeneratingUnit> (nameof (ThermalGeneratingUnits));
  public void AddToThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => AddAssoc1ToM (nameof (ThermalGeneratingUnits),
                                        assocObject);
  public void RemoveFromThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => RemoveAssoc1ToM (nameof (ThermalGeneratingUnits),
                                           assocObject);
  public void RemoveAllFromThermalGeneratingUnits () => RemoveAllAssocs1ToM (
      nameof (ThermalGeneratingUnits));
}
/// <summary>
/// Communication function of communication equipment or a device such as a
/// meter.
/// </summary>
[CimClass (ClassUri)]
public partial class ComFunction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EndDeviceFunction (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ComFunction";

  /// <summary>
  /// Communication ID number (e.g. serial number, IP address, telephone number,
  /// etc.) of the AMR module which serves this meter.
  /// </summary>
  public string ? amrAddress
  {
    get => GetAttribute < string ? > (nameof (amrAddress));
    set => SetAttribute (nameof (amrAddress), value);
  }
  /// <summary>
  /// Communication ID number (e.g. port number, serial number, data collector
  /// ID, etc.) of the parent device associated to this AMR module.
  /// </summary>
  public string ? amrRouter
  {
    get => GetAttribute < string ? > (nameof (amrRouter));
    set => SetAttribute (nameof (amrRouter), value);
  }
  /// <summary>
  /// Kind of communication direction.
  /// </summary>
  public ComDirectionKind ? direction
  {
    get => GetAttribute < ComDirectionKind ? > (nameof (direction));
    set => SetAttribute (nameof (direction), value);
  }
  /// <summary>
  /// Kind of communication technology.
  /// </summary>
  public ComTechnologyKind ? technology
  {
    get => GetAttribute < ComTechnologyKind ? > (nameof (technology));
    set => SetAttribute (nameof (technology), value);
  }
}
/// <summary>
/// A set of combustion turbines and steam turbines where the exhaust heat from
/// the combustion turbines is recovered to make steam for the steam turbines,
/// resulting in greater overall plant efficiency.
/// </summary>
[CimClass (ClassUri)]
public partial class CombinedCyclePlant
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CombinedCyclePlant";

  /// <summary>
  /// The combined cycle plant's active power output rating.
  /// </summary>
  public float ? combCyclePlantRating
  {
    get => GetAttribute < float ? > (nameof (combCyclePlantRating));
    set => SetAttribute (nameof (combCyclePlantRating), value);
  }

  /// <summary>
  /// A thermal generating unit may be a member of a combined cycle plant.
  /// </summary>
  public ThermalGeneratingUnit[] ThermalGeneratingUnits => GetAssoc1ToM<
      ThermalGeneratingUnit> (nameof (ThermalGeneratingUnits));
  public void AddToThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => AddAssoc1ToM (nameof (ThermalGeneratingUnits),
                                        assocObject);
  public void RemoveFromThermalGeneratingUnits (
      ThermalGeneratingUnit
          assocObject) => RemoveAssoc1ToM (nameof (ThermalGeneratingUnits),
                                           assocObject);
  public void RemoveAllFromThermalGeneratingUnits () => RemoveAllAssocs1ToM (
      nameof (ThermalGeneratingUnits));
}
/// <summary>
/// A prime mover that is typically fuelled by gas or light oil.
/// </summary>
[CimClass (ClassUri)]
public partial class CombustionTurbine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PrimeMover (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CombustionTurbine";

  /// <summary>
  /// A combustion turbine may have a heat recovery boiler for making steam.
  /// </summary>
  public HeatRecoveryBoiler ? HeatRecoveryBoiler
  {
    get => GetAssoc1To1<HeatRecoveryBoiler> (nameof (HeatRecoveryBoiler));
    set => SetAssoc1To1 (nameof (HeatRecoveryBoiler), value);
  }
}
/// <summary>
/// Concentric neutral cable data.
/// </summary>
[CimClass (ClassUri)]
public partial class ConcentricNeutralCableInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : CableInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConcentricNeutralCableInfo";

  /// <summary>
  /// Diameter over the concentric neutral strands.
  /// </summary>
  public float ? diameterOverNeutral
  {
    get => GetAttribute < float ? > (nameof (diameterOverNeutral));
    set => SetAttribute (nameof (diameterOverNeutral), value);
  }
  /// <summary>
  /// DC resistance per unit length of the neutral strand at 20 °C.
  /// </summary>
  public float ? neutralStrandRDC20
  {
    get => GetAttribute < float ? > (nameof (neutralStrandRDC20));
    set => SetAttribute (nameof (neutralStrandRDC20), value);
  }
}
/// <summary>
/// The parts of the AC power system that are designed to carry current or that
/// are conductively connected through terminals.
/// </summary>
[CimClass (ClassUri)]
public partial class ConductingEquipment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConductingEquipment";

  /// <summary>
  ///
  /// </summary>
  public bool ? isThreePhaseEquipment
  {
    get => GetAttribute < bool ? > (nameof (isThreePhaseEquipment));
    set => SetAttribute (nameof (isThreePhaseEquipment), value);
  }

  /// <summary>
  /// Base voltage of this conducting equipment.  Use only when there is no
  /// voltage level container used and only one base voltage applies.  For
  /// example, not used for transformers.
  /// </summary>
  public BaseVoltage ? BaseVoltage
  {
    get => GetAssoc1To1<BaseVoltage> (nameof (BaseVoltage));
    set => SetAssoc1To1 (nameof (BaseVoltage), value);
  }
  /// <summary>
  /// Action involving grounding operation on this conducting equipment.
  /// </summary>
  public GroundAction ? GroundingAction
  {
    get => GetAssoc1To1<GroundAction> (nameof (GroundingAction));
    set => SetAssoc1To1 (nameof (GroundingAction), value);
  }

  /// <summary>
  /// Conducting equipment have terminals that may be connected to other
  /// conducting equipment terminals via connectivity nodes or topological
  /// nodes.
  /// </summary>
  public Terminal[] Terminals => GetAssoc1ToM<Terminal> (nameof (Terminals));
  public void AddToTerminals (Terminal assocObject) => AddAssoc1ToM (
      nameof (Terminals), assocObject);
  public void RemoveFromTerminals (Terminal assocObject) => RemoveAssoc1ToM (
      nameof (Terminals), assocObject);
  public void RemoveAllFromTerminals () => RemoveAllAssocs1ToM (
      nameof (Terminals));
}
/// <summary>
/// Combination of conducting material with consistent electrical
/// characteristics, building a single electrical system, used to carry current
/// between points in the power system.
/// </summary>
[CimClass (ClassUri)]
public partial class Conductor
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Conductor";

  /// <summary>
  /// Segment length for calculating line section capabilities.
  /// </summary>
  public float ? length
  {
    get => GetAttribute < float ? > (nameof (length));
    set => SetAttribute (nameof (length), value);
  }
}
/// <summary>
/// Used to report details on creation, change or deletion of an entity or its
/// configuration.
/// </summary>
[CimClass (ClassUri)]
public partial class ConfigurationEvent
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ActivityRecord (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConfigurationEvent";

  /// <summary>
  /// Date and time this event has or will become effective.
  /// </summary>
  public DateTime ? effectiveDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (effectiveDateTime));
    set => SetAttribute (nameof (effectiveDateTime), value);
  }
  /// <summary>
  /// Source/initiator of modification.
  /// </summary>
  public string ? modifiedBy
  {
    get => GetAttribute < string ? > (nameof (modifiedBy));
    set => SetAttribute (nameof (modifiedBy), value);
  }
  /// <summary>
  /// Free text remarks.
  /// </summary>
  public string ? remark
  {
    get => GetAttribute < string ? > (nameof (remark));
    set => SetAttribute (nameof (remark), value);
  }
}
/// <summary>
/// A function that will disconnect and reconnect the customer's load under
/// defined conditions.
/// </summary>
[CimClass (ClassUri)]
public partial class ConnectDisconnectFunction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EndDeviceFunction (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConnectDisconnectFunction";

  /// <summary>
  /// Running cumulative count of connect or disconnect events, for the lifetime
  /// of this function or until the value is cleared.
  /// </summary>
  public int ? eventCount
  {
    get => GetAttribute < int ? > (nameof (eventCount));
    set => SetAttribute (nameof (eventCount), value);
  }
  /// <summary>
  /// True if this function is in the connected state.
  /// </summary>
  public bool ? isConnected
  {
    get => GetAttribute < bool ? > (nameof (isConnected));
    set => SetAttribute (nameof (isConnected), value);
  }
  /// <summary>
  /// If set true, the switch may disconnect the service at the end of a
  /// specified time delay after the disconnect signal has been given. If set
  /// false, the switch may disconnect the service immediately after the
  /// disconnect signal has been given. This is typically the case for over
  /// current circuit-breakers which are classified as either instantaneous or
  /// slow acting.
  /// </summary>
  public bool ? isDelayedDiscon
  {
    get => GetAttribute < bool ? > (nameof (isDelayedDiscon));
    set => SetAttribute (nameof (isDelayedDiscon), value);
  }
  /// <summary>
  /// If set true and if disconnection can be operated locally, the operation
  /// happens automatically. Otherwise it happens manually.
  /// </summary>
  public bool ? isLocalAutoDisconOp
  {
    get => GetAttribute < bool ? > (nameof (isLocalAutoDisconOp));
    set => SetAttribute (nameof (isLocalAutoDisconOp), value);
  }
  /// <summary>
  /// If set true and if reconnection can be operated locally, then the
  /// operation happens automatically. Otherwise, it happens manually.
  /// </summary>
  public bool ? isLocalAutoReconOp
  {
    get => GetAttribute < bool ? > (nameof (isLocalAutoReconOp));
    set => SetAttribute (nameof (isLocalAutoReconOp), value);
  }
  /// <summary>
  /// If set true and if disconnection can be operated remotely, then the
  /// operation happens automatically. If set false and if disconnection can be
  /// operated remotely, then the operation happens manually.
  /// </summary>
  public bool ? isRemoteAutoDisconOp
  {
    get => GetAttribute < bool ? > (nameof (isRemoteAutoDisconOp));
    set => SetAttribute (nameof (isRemoteAutoDisconOp), value);
  }
  /// <summary>
  /// If set true and if reconnection can be operated remotely, then the
  /// operation happens automatically. If set false and if reconnection can be
  /// operated remotely, then the operation happens manually.
  /// </summary>
  public bool ? isRemoteAutoReconOp
  {
    get => GetAttribute < bool ? > (nameof (isRemoteAutoReconOp));
    set => SetAttribute (nameof (isRemoteAutoReconOp), value);
  }
  /// <summary>
  /// Information on remote connect disconnect switch.
  /// </summary>
  public RemoteConnectDisconnectInfo ? rcdInfo
  {
    get => GetAttribute < RemoteConnectDisconnectInfo ? > (nameof (rcdInfo));
    set => SetAttribute (nameof (rcdInfo), value);
  }
}
/// <summary>
/// Connectivity nodes are points where terminals of AC conducting equipment are
/// connected together with zero impedance.
/// </summary>
[CimClass (ClassUri)]
public partial class ConnectivityNode
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConnectivityNode";

  /// <summary>
  /// Container of this connectivity node.
  /// </summary>
  public ConnectivityNodeContainer ? ConnectivityNodeContainer
  {
    get => GetAssoc1To1<ConnectivityNodeContainer> (
        nameof (ConnectivityNodeContainer));
    set => SetAssoc1To1 (nameof (ConnectivityNodeContainer), value);
  }

  /// <summary>
  /// Terminals interconnected with zero impedance at a this connectivity node.
  /// </summary>
  public Terminal[] Terminals => GetAssoc1ToM<Terminal> (nameof (Terminals));
  public void AddToTerminals (Terminal assocObject) => AddAssoc1ToM (
      nameof (Terminals), assocObject);
  public void RemoveFromTerminals (Terminal assocObject) => RemoveAssoc1ToM (
      nameof (Terminals), assocObject);
  public void RemoveAllFromTerminals () => RemoveAllAssocs1ToM (
      nameof (Terminals));
}
/// <summary>
/// A base class for all objects that may contain connectivity nodes or
/// topological nodes.
/// </summary>
[CimClass (ClassUri)]
public partial class ConnectivityNodeContainer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ConnectivityNodeContainer";

  /// <summary>
  /// Connectivity nodes which belong to this connectivity node container.
  /// </summary>
  public ConnectivityNode[] ConnectivityNodes => GetAssoc1ToM<
      ConnectivityNode> (nameof (ConnectivityNodes));
  public void AddToConnectivityNodes (
      ConnectivityNode assocObject) => AddAssoc1ToM (nameof (ConnectivityNodes),
                                                     assocObject);
  public void RemoveFromConnectivityNodes (
      ConnectivityNode
          assocObject) => RemoveAssoc1ToM (nameof (ConnectivityNodes),
                                           assocObject);
  public void RemoveAllFromConnectivityNodes () => RemoveAllAssocs1ToM (
      nameof (ConnectivityNodes));
}
/// <summary>
/// A conductor, or group of conductors, with negligible impedance, that serve
/// to connect other conducting equipment within a single substation and are
/// modelled with a single logical terminal.
/// </summary>
[CimClass (ClassUri)]
public partial class Connector
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Connector";
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ControlledShuntReactorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntReactorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ControlledShuntReactorInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? boostRegulatingSpeed
  {
    get => GetAttribute < float ? > (nameof (boostRegulatingSpeed));
    set => SetAttribute (nameof (boostRegulatingSpeed), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxSlope
  {
    get => GetAttribute < float ? > (nameof (maxSlope));
    set => SetAttribute (nameof (maxSlope), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? minSlope
  {
    get => GetAttribute < float ? > (nameof (minSlope));
    set => SetAttribute (nameof (minSlope), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedRegulatingTime
  {
    get => GetAttribute < float ? > (nameof (ratedRegulatingTime));
    set => SetAttribute (nameof (ratedRegulatingTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? regulatingSpeed
  {
    get => GetAttribute < float ? > (nameof (regulatingSpeed));
    set => SetAttribute (nameof (regulatingSpeed), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? shortCircuitVoltage
  {
    get => GetAttribute < float ? > (nameof (shortCircuitVoltage));
    set => SetAttribute (nameof (shortCircuitVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }
}
/// <summary>
/// Coordinate reference system.
/// </summary>
[CimClass (ClassUri)]
public partial class CoordinateSystem
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CoordinateSystem";

  /// <summary>
  /// A Uniform Resource Name (URN) for the coordinate reference system (crs)
  /// used to define 'Location.PositionPoints'.An example would be the European
  /// Petroleum Survey Group (EPSG) code for a coordinate reference system,
  /// defined in URN under the Open Geospatial Consortium (OGC) namespace as:
  /// urn:ogc:def:crs:EPSG::XXXX, where XXXX is an EPSG code (a full list of
  /// codes can be found at the EPSG Registry web site
  /// http://www.epsg-registry.org/). To define the coordinate system as being
  /// WGS84 (latitude, longitude) using an EPSG OGC, this attribute would be
  /// urn:ogc:def:crs:EPSG::4.3.2.6A profile should limit this code to a set of
  /// allowed URNs agreed to by all sending and receiving parties.
  /// </summary>
  public string ? crsUrn
  {
    get => GetAttribute < string ? > (nameof (crsUrn));
    set => SetAttribute (nameof (crsUrn), value);
  }

  /// <summary>
  /// All locations described with position points in this coordinate system.
  /// </summary>
  public Location[] Locations => GetAssoc1ToM<Location> (nameof (Locations));
  public void AddToLocations (Location assocObject) => AddAssoc1ToM (
      nameof (Locations), assocObject);
  public void RemoveFromLocations (Location assocObject) => RemoveAssoc1ToM (
      nameof (Locations), assocObject);
  public void RemoveAllFromLocations () => RemoveAllAssocs1ToM (
      nameof (Locations));
}
/// <summary>
/// Operational limit on current.
/// </summary>
[CimClass (ClassUri)]
public partial class CurrentLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OperationalLimit (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#CurrentLimit";

  /// <summary>
  /// The normal value for limit on current flow. The attribute shall be a
  /// positive value or zero.
  /// </summary>
  public float ? normalValue
  {
    get => GetAttribute < float ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }
  /// <summary>
  /// Limit on current flow. The attribute shall be a positive value or zero.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Instrument transformer used to measure electrical qualities of the circuit
/// that is being protected and/or monitored. Typically used as current
/// transducer for the purpose of metering or protection. A typical secondary
/// current rating would be 5A.
/// </summary>
[CimClass (ClassUri)]
public partial class CurrentTransformer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Sensor (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CurrentTransformer";

  /// <summary>
  /// CT accuracy classification.
  /// </summary>
  public string ? accuracyClass
  {
    get => GetAttribute < string ? > (nameof (accuracyClass));
    set => SetAttribute (nameof (accuracyClass), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? isEmbeded
  {
    get => GetAttribute < bool ? > (nameof (isEmbeded));
    set => SetAttribute (nameof (isEmbeded), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedSecondaryCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedSecondaryCurrent));
    set => SetAttribute (nameof (ratedSecondaryCurrent), value);
  }

  /// <summary>
  ///
  /// </summary>
  public CurrentTransformerWinding[] Windings => GetAssoc1ToM<
      CurrentTransformerWinding> (nameof (Windings));
  public void AddToWindings (
      CurrentTransformerWinding assocObject) => AddAssoc1ToM (nameof (Windings),
                                                              assocObject);
  public void RemoveFromWindings (
      CurrentTransformerWinding
          assocObject) => RemoveAssoc1ToM (nameof (Windings), assocObject);
  public void RemoveAllFromWindings () => RemoveAllAssocs1ToM (
      nameof (Windings));
}
/// <summary>
/// Properties of current transformer asset.
/// </summary>
[CimClass (ClassUri)]
public partial class CurrentTransformerInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CurrentTransformerInfo";

  /// <summary>
  /// Number of cores.
  /// </summary>
  public int ? coreCount
  {
    get => GetAttribute < int ? > (nameof (coreCount));
    set => SetAttribute (nameof (coreCount), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? ctClass
  {
    get => GetAttribute < string ? > (nameof (ctClass));
    set => SetAttribute (nameof (ctClass), value);
  }
  /// <summary>
  /// Maximum primary current where the CT still displays linear
  /// characteristicts.
  /// </summary>
  public float ? kneePointCurrent
  {
    get => GetAttribute < float ? > (nameof (kneePointCurrent));
    set => SetAttribute (nameof (kneePointCurrent), value);
  }
  /// <summary>
  /// Maximum voltage across the secondary terminals where the CT still displays
  /// linear characteristicts.
  /// </summary>
  public float ? kneePointVoltage
  {
    get => GetAttribute < float ? > (nameof (kneePointVoltage));
    set => SetAttribute (nameof (kneePointVoltage), value);
  }
  /// <summary>
  /// Maximum ratio between the primary and secondary current.
  /// </summary>
  public Ratio ? maxRatio
  {
    get => GetAttribute < Ratio ? > (nameof (maxRatio));
    set => SetAttribute (nameof (maxRatio), value);
  }
  /// <summary>
  /// Nominal ratio between the primary and secondary current; i.e. 100:5.
  /// </summary>
  public Ratio ? nominalRatio
  {
    get => GetAttribute < Ratio ? > (nameof (nominalRatio));
    set => SetAttribute (nameof (nominalRatio), value);
  }
  /// <summary>
  /// Full load secondary (FLS) rating for primary winding.
  /// </summary>
  public float ? primaryFlsRating
  {
    get => GetAttribute < float ? > (nameof (primaryFlsRating));
    set => SetAttribute (nameof (primaryFlsRating), value);
  }
  /// <summary>
  /// Ratio for the primary winding tap changer.
  /// </summary>
  public Ratio ? primaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (primaryRatio));
    set => SetAttribute (nameof (primaryRatio), value);
  }
  /// <summary>
  /// Rated current on the primary side.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Full load secondary (FLS) rating for secondary winding.
  /// </summary>
  public float ? secondaryFlsRating
  {
    get => GetAttribute < float ? > (nameof (secondaryFlsRating));
    set => SetAttribute (nameof (secondaryFlsRating), value);
  }
  /// <summary>
  /// Ratio for the secondary winding tap changer.
  /// </summary>
  public Ratio ? secondaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (secondaryRatio));
    set => SetAttribute (nameof (secondaryRatio), value);
  }
  /// <summary>
  /// Full load secondary (FLS) rating for tertiary winding.
  /// </summary>
  public float ? tertiaryFlsRating
  {
    get => GetAttribute < float ? > (nameof (tertiaryFlsRating));
    set => SetAttribute (nameof (tertiaryFlsRating), value);
  }
  /// <summary>
  /// Ratio for the tertiary winding tap changer.
  /// </summary>
  public Ratio ? tertiaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (tertiaryRatio));
    set => SetAttribute (nameof (tertiaryRatio), value);
  }
  /// <summary>
  /// Usage: eg. metering, protection, etc.
  /// </summary>
  public string ? usage
  {
    get => GetAttribute < string ? > (nameof (usage));
    set => SetAttribute (nameof (usage), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class CurrentTransformerWinding
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SensorWinding (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#CurrentTransformerWinding";

  /// <summary>
  ///
  /// </summary>
  public float ? kMax
  {
    get => GetAttribute < float ? > (nameof (kMax));
    set => SetAttribute (nameof (kMax), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? kt
  {
    get => GetAttribute < float ? > (nameof (kt));
    set => SetAttribute (nameof (kt), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? nominalKTs
  {
    get => GetAttribute < string ? > (nameof (nominalKTs));
    set => SetAttribute (nameof (nominalKTs), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedLoadR
  {
    get => GetAttribute < float ? > (nameof (ratedLoadR));
    set => SetAttribute (nameof (ratedLoadR), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedLoadX
  {
    get => GetAttribute < float ? > (nameof (ratedLoadX));
    set => SetAttribute (nameof (ratedLoadX), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }

  /// <summary>
  ///
  /// </summary>
  public CurrentTransformer ? Transformer
  {
    get => GetAssoc1To1<CurrentTransformer> (nameof (Transformer));
    set => SetAssoc1To1 (nameof (Transformer), value);
  }
}
/// <summary>
/// A multi-purpose curve or functional relationship between an independent
/// variable (X-axis) and dependent (Y-axis) variables.
/// </summary>
[CimClass (ClassUri)]
public partial class Curve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Curve";

  /// <summary>
  /// The style or shape of the curve.
  /// </summary>
  public CurveStyle ? curveStyle
  {
    get => GetAttribute < CurveStyle ? > (nameof (curveStyle));
    set => SetAttribute (nameof (curveStyle), value);
  }
  /// <summary>
  /// Multiplier for X-axis.
  /// </summary>
  public UnitMultiplier ? xMultiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (xMultiplier));
    set => SetAttribute (nameof (xMultiplier), value);
  }
  /// <summary>
  /// The X-axis units of measure.
  /// </summary>
  public UnitSymbol ? xUnit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (xUnit));
    set => SetAttribute (nameof (xUnit), value);
  }
  /// <summary>
  /// Multiplier for Y1-axis.
  /// </summary>
  public UnitMultiplier ? y1Multiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (y1Multiplier));
    set => SetAttribute (nameof (y1Multiplier), value);
  }
  /// <summary>
  /// The Y1-axis units of measure.
  /// </summary>
  public UnitSymbol ? y1Unit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (y1Unit));
    set => SetAttribute (nameof (y1Unit), value);
  }
  /// <summary>
  /// Multiplier for Y2-axis.
  /// </summary>
  public UnitMultiplier ? y2Multiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (y2Multiplier));
    set => SetAttribute (nameof (y2Multiplier), value);
  }
  /// <summary>
  /// The Y2-axis units of measure.
  /// </summary>
  public UnitSymbol ? y2Unit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (y2Unit));
    set => SetAttribute (nameof (y2Unit), value);
  }
  /// <summary>
  /// Multiplier for Y3-axis.
  /// </summary>
  public UnitMultiplier ? y3Multiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (y3Multiplier));
    set => SetAttribute (nameof (y3Multiplier), value);
  }
  /// <summary>
  /// The Y3-axis units of measure.
  /// </summary>
  public UnitSymbol ? y3Unit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (y3Unit));
    set => SetAttribute (nameof (y3Unit), value);
  }

  /// <summary>
  /// The point data values that define this curve.
  /// </summary>
  public CurveData[] CurveDatas => GetAssoc1ToM<CurveData> (
      nameof (CurveDatas));
  public void AddToCurveDatas (CurveData assocObject) => AddAssoc1ToM (
      nameof (CurveDatas), assocObject);
  public void RemoveFromCurveDatas (CurveData assocObject) => RemoveAssoc1ToM (
      nameof (CurveDatas), assocObject);
  public void RemoveAllFromCurveDatas () => RemoveAllAssocs1ToM (
      nameof (CurveDatas));
}
/// <summary>
/// Multi-purpose data points for defining a curve.  The use of this generic
/// class is discouraged if a more specific class can be used to specify the X
/// and Y axis values along with their specific data types.
/// </summary>
[CimClass (ClassUri)]
public partial class CurveData
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#CurveData";

  /// <summary>
  /// The data value of the X-axis variable,  depending on the X-axis units.
  /// </summary>
  public float ? xvalue
  {
    get => GetAttribute < float ? > (nameof (xvalue));
    set => SetAttribute (nameof (xvalue), value);
  }
  /// <summary>
  /// The data value of the  first Y-axis variable, depending on the Y-axis
  /// units.
  /// </summary>
  public float ? y1value
  {
    get => GetAttribute < float ? > (nameof (y1value));
    set => SetAttribute (nameof (y1value), value);
  }
  /// <summary>
  /// The data value of the second Y-axis variable (if present), depending on
  /// the Y-axis units.
  /// </summary>
  public float ? y2value
  {
    get => GetAttribute < float ? > (nameof (y2value));
    set => SetAttribute (nameof (y2value), value);
  }
  /// <summary>
  /// The data value of the third Y-axis variable (if present), depending on the
  /// Y-axis units.
  /// </summary>
  public float ? y3value
  {
    get => GetAttribute < float ? > (nameof (y3value));
    set => SetAttribute (nameof (y3value), value);
  }

  /// <summary>
  /// The curve of  this curve data point.
  /// </summary>
  public Curve ? Curve
  {
    get => GetAssoc1To1<Curve> (nameof (Curve));
    set => SetAssoc1To1 (nameof (Curve), value);
  }
}
/// <summary>
/// Organisation receiving services from service supplier.
/// </summary>
[CimClass (ClassUri)]
public partial class Customer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OrganisationRole (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Customer";

  /// <summary>
  /// Kind of customer.
  /// </summary>
  public CustomerKind ? kind
  {
    get => GetAttribute < CustomerKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
  /// <summary>
  /// Locale designating language to use in communications with this customer.
  /// </summary>
  public string ? locale
  {
    get => GetAttribute < string ? > (nameof (locale));
    set => SetAttribute (nameof (locale), value);
  }
  /// <summary>
  /// (if applicable) Public utilities commission (PUC) identification number.
  /// </summary>
  public string ? pucNumber
  {
    get => GetAttribute < string ? > (nameof (pucNumber));
    set => SetAttribute (nameof (pucNumber), value);
  }
  /// <summary>
  /// True if customer organisation has special service needs such as life
  /// support, hospitals, etc.
  /// </summary>
  public string ? specialNeed
  {
    get => GetAttribute < string ? > (nameof (specialNeed));
    set => SetAttribute (nameof (specialNeed), value);
  }
  /// <summary>
  /// Status of this customer.
  /// </summary>
  public Status ? status
  {
    get => GetAttribute < Status ? > (nameof (status));
    set => SetAttribute (nameof (status), value);
  }
  /// <summary>
  /// (deprecated) (use 'priority' instead) True if this is an important
  /// customer. Importance is for matters different than those in 'specialNeed'
  /// attribute.
  /// </summary>
  public bool ? vip
  {
    get => GetAttribute < bool ? > (nameof (vip));
    set => SetAttribute (nameof (vip), value);
  }

  /// <summary>
  /// All agreements of this customer.
  /// </summary>
  public CustomerAgreement[] CustomerAgreements => GetAssoc1ToM<
      CustomerAgreement> (nameof (CustomerAgreements));
  public void
  AddToCustomerAgreements (CustomerAgreement assocObject) => AddAssoc1ToM (
      nameof (CustomerAgreements), assocObject);
  public void RemoveFromCustomerAgreements (
      CustomerAgreement
          assocObject) => RemoveAssoc1ToM (nameof (CustomerAgreements),
                                           assocObject);
  public void RemoveAllFromCustomerAgreements () => RemoveAllAssocs1ToM (
      nameof (CustomerAgreements));
  /// <summary>
  /// All end devices of this customer.
  /// </summary>
  public EndDevice[] EndDevices => GetAssoc1ToM<EndDevice> (
      nameof (EndDevices));
  public void AddToEndDevices (EndDevice assocObject) => AddAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveFromEndDevices (EndDevice assocObject) => RemoveAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveAllFromEndDevices () => RemoveAllAssocs1ToM (
      nameof (EndDevices));
}
/// <summary>
/// Agreement between the customer and the service supplier to pay for service
/// at a specific service location. It records certain billing information about
/// the type of service provided at the service location and is used during
/// charge creation to determine the type of service.
/// </summary>
[CimClass (ClassUri)]
public partial class CustomerAgreement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Agreement (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#CustomerAgreement";

  /// <summary>
  /// Load management code.
  /// </summary>
  public string ? loadMgmt
  {
    get => GetAttribute < string ? > (nameof (loadMgmt));
    set => SetAttribute (nameof (loadMgmt), value);
  }

  /// <summary>
  /// Customer for this agreement.
  /// </summary>
  public Customer ? Customer
  {
    get => GetAssoc1To1<Customer> (nameof (Customer));
    set => SetAssoc1To1 (nameof (Customer), value);
  }
  /// <summary>
  /// Service category for this agreement.
  /// </summary>
  public ServiceCategory ? ServiceCategory
  {
    get => GetAssoc1To1<ServiceCategory> (nameof (ServiceCategory));
    set => SetAssoc1To1 (nameof (ServiceCategory), value);
  }

  /// <summary>
  /// All service delivery points regulated by this customer agreement.
  /// </summary>
  public UsagePoint[] UsagePoints => GetAssoc1ToM<UsagePoint> (
      nameof (UsagePoints));
  public void AddToUsagePoints (UsagePoint assocObject) => AddAssoc1ToM (
      nameof (UsagePoints), assocObject);
  public void RemoveFromUsagePoints (
      UsagePoint assocObject) => RemoveAssoc1ToM (nameof (UsagePoints),
                                                  assocObject);
  public void RemoveAllFromUsagePoints () => RemoveAllAssocs1ToM (
      nameof (UsagePoints));
}
/// <summary>
/// An electrical connection point at a piece of DC conducting equipment. DC
/// terminals are connected at one physical DC node that may have multiple DC
/// terminals connected. A DC node is similar to an AC connectivity node. The
/// model requires that DC connections are distinct from AC connections.
/// </summary>
[CimClass (ClassUri)]
public partial class DCBaseTerminal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ACDCTerminal (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DCBaseTerminal";
}
/// <summary>
/// The parts of the DC power system that are designed to carry current or that
/// are conductively connected through DC terminals.
/// </summary>
[CimClass (ClassUri)]
public partial class DCConductingEquipment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#DCConductingEquipment";

  /// <summary>
  /// A DC conducting equipment has DC terminals.
  /// </summary>
  public DCTerminal[] DCTerminals => GetAssoc1ToM<DCTerminal> (
      nameof (DCTerminals));
  public void AddToDCTerminals (DCTerminal assocObject) => AddAssoc1ToM (
      nameof (DCTerminals), assocObject);
  public void RemoveFromDCTerminals (
      DCTerminal assocObject) => RemoveAssoc1ToM (nameof (DCTerminals),
                                                  assocObject);
  public void RemoveAllFromDCTerminals () => RemoveAllAssocs1ToM (
      nameof (DCTerminals));
}
/// <summary>
/// A modelling construct to provide a root class for containment of DC as well
/// as AC equipment. The class differ from the EquipmentContaner for AC in that
/// it may also contain DCNode-s. Hence it can contain both AC and DC equipment.
/// </summary>
[CimClass (ClassUri)]
public partial class DCEquipmentContainer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#DCEquipmentContainer";
}
/// <summary>
/// Overhead lines and/or cables connecting two or more HVDC substations.
/// </summary>
[CimClass (ClassUri)]
public partial class DCLine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : DCEquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DCLine";
}
/// <summary>
/// A wire or combination of wires not insulated from one another, with
/// consistent electrical characteristics, used to carry direct current between
/// points in the DC region of the power system.
/// </summary>
[CimClass (ClassUri)]
public partial class DCLineSegment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : DCConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DCLineSegment";

  /// <summary>
  /// Capacitance of the DC line segment. Significant for cables only.
  /// </summary>
  public float ? capacitance
  {
    get => GetAttribute < float ? > (nameof (capacitance));
    set => SetAttribute (nameof (capacitance), value);
  }
  /// <summary>
  /// Inductance of the DC line segment. Negligible compared with DCSeriesDevice
  /// used for smoothing.
  /// </summary>
  public float ? inductance
  {
    get => GetAttribute < float ? > (nameof (inductance));
    set => SetAttribute (nameof (inductance), value);
  }
  /// <summary>
  /// Segment length for calculating line section capabilities.
  /// </summary>
  public float ? length
  {
    get => GetAttribute < float ? > (nameof (length));
    set => SetAttribute (nameof (length), value);
  }
  /// <summary>
  /// Resistance of the DC line segment.
  /// </summary>
  public float ? resistance
  {
    get => GetAttribute < float ? > (nameof (resistance));
    set => SetAttribute (nameof (resistance), value);
  }
}
/// <summary>
/// An electrical connection point to generic DC conducting equipment.
/// </summary>
[CimClass (ClassUri)]
public partial class DCTerminal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : DCBaseTerminal (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DCTerminal";

  /// <summary>
  /// An DC  terminal belong to a DC conducting equipment.
  /// </summary>
  public DCConductingEquipment ? DCConductingEquipment
  {
    get => GetAssoc1To1<DCConductingEquipment> (nameof (DCConductingEquipment));
    set => SetAssoc1To1 (nameof (DCConductingEquipment), value);
  }
}
/// <summary>
/// Interval between two date and time points, where the interval includes the
/// start time but excludes end time.
/// </summary>
[CimClass (ClassUri)]
public partial class DateTimeInterval
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#DateTimeInterval";

  /// <summary>
  /// End date and time of this interval.  The end date and time where the
  /// interval is defined up to, but excluded.
  /// </summary>
  public DateTime ? end
  {
    get => GetAttribute < DateTime ? > (nameof (end));
    set => SetAttribute (nameof (end), value);
  }
  /// <summary>
  /// Start date and time of this interval.  The start date and time is included
  /// in the defined interval.
  /// </summary>
  public DateTime ? start
  {
    get => GetAttribute < DateTime ? > (nameof (start));
    set => SetAttribute (nameof (start), value);
  }
}
/// <summary>
/// Dates for deployment events of an asset.  May have multiple deployment type
/// dates for this device and a compound type allows a query to return multiple
/// dates.
/// </summary>
[CimClass (ClassUri)]
public partial class DeploymentDate
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DeploymentDate";

  /// <summary>
  /// Date and time asset most recently put in service.
  /// </summary>
  public DateTime ? inServiceDate
  {
    get => GetAttribute < DateTime ? > (nameof (inServiceDate));
    set => SetAttribute (nameof (inServiceDate), value);
  }
  /// <summary>
  /// Date and time asset most recently installed.
  /// </summary>
  public DateTime ? installedDate
  {
    get => GetAttribute < DateTime ? > (nameof (installedDate));
    set => SetAttribute (nameof (installedDate), value);
  }
  /// <summary>
  /// Date and time of asset deployment transition to not yet installed.
  /// </summary>
  public DateTime ? notYetInstalledDate
  {
    get => GetAttribute < DateTime ? > (nameof (notYetInstalledDate));
    set => SetAttribute (nameof (notYetInstalledDate), value);
  }
  /// <summary>
  /// Date and time asset most recently taken out of service.
  /// </summary>
  public DateTime ? outOfServiceDate
  {
    get => GetAttribute < DateTime ? > (nameof (outOfServiceDate));
    set => SetAttribute (nameof (outOfServiceDate), value);
  }
  /// <summary>
  /// Date and time asset most recently removed.
  /// </summary>
  public DateTime ? removedDate
  {
    get => GetAttribute < DateTime ? > (nameof (removedDate));
    set => SetAttribute (nameof (removedDate), value);
  }
}
/// <summary>
/// A manually operated or motor operated mechanical switching device used for
/// changing the connections in a circuit, or for isolating a circuit or
/// equipment from a source of power. It is required to open or close circuits
/// when negligible current is broken or made.
/// </summary>
[CimClass (ClassUri)]
public partial class Disconnector
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Switch (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Disconnector";
}
/// <summary>
/// Discrete represents a discrete Measurement, i.e. a Measurement representing
/// discrete values, e.g. a Breaker position.
/// </summary>
[CimClass (ClassUri)]
public partial class Discrete
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Measurement (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Discrete";

  /// <summary>
  /// Normal value range maximum for any of the MeasurementValue.values. Used
  /// for scaling, e.g. in bar graphs or of telemetered raw values.
  /// </summary>
  public int ? maxValue
  {
    get => GetAttribute < int ? > (nameof (maxValue));
    set => SetAttribute (nameof (maxValue), value);
  }
  /// <summary>
  /// Normal value range minimum for any of the MeasurementValue.values. Used
  /// for scaling, e.g. in bar graphs or of telemetered raw values.
  /// </summary>
  public int ? minValue
  {
    get => GetAttribute < int ? > (nameof (minValue));
    set => SetAttribute (nameof (minValue), value);
  }
  /// <summary>
  /// Normal measurement value, e.g., used for percentage calculations.
  /// </summary>
  public int ? normalValue
  {
    get => GetAttribute < int ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }

  /// <summary>
  /// The values connected to this measurement.
  /// </summary>
  public DiscreteValue[] DiscreteValues => GetAssoc1ToM<DiscreteValue> (
      nameof (DiscreteValues));
  public void AddToDiscreteValues (DiscreteValue assocObject) => AddAssoc1ToM (
      nameof (DiscreteValues), assocObject);
  public void RemoveFromDiscreteValues (
      DiscreteValue assocObject) => RemoveAssoc1ToM (nameof (DiscreteValues),
                                                     assocObject);
  public void RemoveAllFromDiscreteValues () => RemoveAllAssocs1ToM (
      nameof (DiscreteValues));
}
/// <summary>
/// DiscreteValue represents a discrete MeasurementValue.
/// </summary>
[CimClass (ClassUri)]
public partial class DiscreteValue
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : MeasurementValue (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DiscreteValue";

  /// <summary>
  /// The value to supervise.
  /// </summary>
  public int ? value
  {
    get => GetAttribute < int ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }

  /// <summary>
  /// Measurement to which this value is connected.
  /// </summary>
  public Discrete ? Discrete
  {
    get => GetAssoc1To1<Discrete> (nameof (Discrete));
    set => SetAssoc1To1 (nameof (Discrete), value);
  }
}
/// <summary>
/// Parent class for different groupings of information collected and managed as
/// a part of a business process. It will frequently contain references to other
/// objects, such as assets, people and power system resources.
/// </summary>
[CimClass (ClassUri)]
public partial class Document
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Document";

  /// <summary>
  /// Date and time that this document was created.
  /// </summary>
  public DateTime ? createdDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (createdDateTime));
    set => SetAttribute (nameof (createdDateTime), value);
  }
  /// <summary>
  /// Electronic address.
  /// </summary>
  public ElectronicAddress ? electronicAddress
  {
    get => GetAttribute < ElectronicAddress ? > (nameof (electronicAddress));
    set => SetAttribute (nameof (electronicAddress), value);
  }
  /// <summary>
  /// Date and time this document was last modified. Documents may potentially
  /// be modified many times during their lifetime.
  /// </summary>
  public DateTime ? lastModifiedDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (lastModifiedDateTime));
    set => SetAttribute (nameof (lastModifiedDateTime), value);
  }

  /// <summary>
  /// All configuration events created for this document.
  /// </summary>
  public ConfigurationEvent[] ConfigurationEvents => GetAssoc1ToM<
      ConfigurationEvent> (nameof (ConfigurationEvents));
  public void
  AddToConfigurationEvents (ConfigurationEvent assocObject) => AddAssoc1ToM (
      nameof (ConfigurationEvents), assocObject);
  public void RemoveFromConfigurationEvents (
      ConfigurationEvent
          assocObject) => RemoveAssoc1ToM (nameof (ConfigurationEvents),
                                           assocObject);
  public void RemoveAllFromConfigurationEvents () => RemoveAllAssocs1ToM (
      nameof (ConfigurationEvents));
}
/// <summary>
/// Drum boiler.
/// </summary>
[CimClass (ClassUri)]
public partial class DrumBoiler
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : FossilSteamSupply (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#DrumBoiler";
}
/// <summary>
/// Abstract parent class for all Dynamics function blocks.
/// </summary>
[CimClass (ClassUri)]
public partial class DynamicsFunctionBlock
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#DynamicsFunctionBlock";
}
/// <summary>
/// A conducting equipment used to represent a connection to ground which is
/// typically used to compensate earth faults.   An earth fault compensator
/// device modelled with a single terminal implies a second terminal solidly
/// connected to ground.  If two terminals are modelled, the ground is not
/// assumed and normal connection rules apply.
/// </summary>
[CimClass (ClassUri)]
public partial class EarthFaultCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EarthFaultCompensator";

  /// <summary>
  /// Nominal resistance of device.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
}
/// <summary>
/// Electronic address information.
/// </summary>
[CimClass (ClassUri)]
public partial class ElectronicAddress
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ElectronicAddress";

  /// <summary>
  /// Primary email address.
  /// </summary>
  public string ? email1
  {
    get => GetAttribute < string ? > (nameof (email1));
    set => SetAttribute (nameof (email1), value);
  }
  /// <summary>
  /// Alternate email address.
  /// </summary>
  public string ? email2
  {
    get => GetAttribute < string ? > (nameof (email2));
    set => SetAttribute (nameof (email2), value);
  }
  /// <summary>
  /// Address on local area network.
  /// </summary>
  public string ? lan
  {
    get => GetAttribute < string ? > (nameof (lan));
    set => SetAttribute (nameof (lan), value);
  }
  /// <summary>
  /// MAC (Media Access Control) address.
  /// </summary>
  public string ? mac
  {
    get => GetAttribute < string ? > (nameof (mac));
    set => SetAttribute (nameof (mac), value);
  }
  /// <summary>
  /// Password needed to log in.
  /// </summary>
  public string ? password
  {
    get => GetAttribute < string ? > (nameof (password));
    set => SetAttribute (nameof (password), value);
  }
  /// <summary>
  /// Radio address.
  /// </summary>
  public string ? radio
  {
    get => GetAttribute < string ? > (nameof (radio));
    set => SetAttribute (nameof (radio), value);
  }
  /// <summary>
  /// User ID needed to log in, which can be for an individual person, an
  /// organisation, a location, etc.
  /// </summary>
  public string ? userID
  {
    get => GetAttribute < string ? > (nameof (userID));
    set => SetAttribute (nameof (userID), value);
  }
  /// <summary>
  /// World wide web address.
  /// </summary>
  public string ? web
  {
    get => GetAttribute < string ? > (nameof (web));
    set => SetAttribute (nameof (web), value);
  }
}
/// <summary>
/// Asset container that performs one or more end device functions. One type of
/// end device is a meter which can perform metering, load management,
/// connect/disconnect, accounting functions, etc. Some end devices, such as
/// ones monitoring and controlling air conditioners, refrigerators, pool pumps
/// may be connected to a meter. All end devices may have communication
/// capability defined by the associated communication function(s). An end
/// device may be owned by a consumer, a service provider, utility or
/// otherwise.There may be a related end device function that identifies a
/// sensor or control point within a metering application or communications
/// systems (e.g., water, gas, electricity).Some devices may use an optical port
/// that conforms to the ANSI C12.18 standard for communications.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDevice
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#EndDevice";

  /// <summary>
  /// Installation code.
  /// </summary>
  public string ? installCode
  {
    get => GetAttribute < string ? > (nameof (installCode));
    set => SetAttribute (nameof (installCode), value);
  }
  /// <summary>
  /// If true, this is a premises area network (PAN) device.
  /// </summary>
  public bool ? isPan
  {
    get => GetAttribute < bool ? > (nameof (isPan));
    set => SetAttribute (nameof (isPan), value);
  }
  /// <summary>
  /// If true, there is no physical device. As an example, a virtual meter can
  /// be defined to aggregate the consumption for two or more physical meters.
  /// Otherwise, this is a physical hardware device.
  /// </summary>
  public bool ? isVirtual
  {
    get => GetAttribute < bool ? > (nameof (isVirtual));
    set => SetAttribute (nameof (isVirtual), value);
  }
  /// <summary>
  /// Time zone offset relative to GMT for the location of this end device.
  /// </summary>
  public float ? timeZoneOffset
  {
    get => GetAttribute < float ? > (nameof (timeZoneOffset));
    set => SetAttribute (nameof (timeZoneOffset), value);
  }

  /// <summary>
  /// Customer owning this end device.
  /// </summary>
  public Customer ? Customer
  {
    get => GetAssoc1To1<Customer> (nameof (Customer));
    set => SetAssoc1To1 (nameof (Customer), value);
  }
  /// <summary>
  /// End device data.
  /// </summary>
  public EndDeviceInfo ? EndDeviceInfo
  {
    get => GetAssoc1To1<EndDeviceInfo> (nameof (EndDeviceInfo));
    set => SetAssoc1To1 (nameof (EndDeviceInfo), value);
  }
  /// <summary>
  /// Usage point to which this end device belongs.
  /// </summary>
  public UsagePoint ? UsagePoint
  {
    get => GetAssoc1To1<UsagePoint> (nameof (UsagePoint));
    set => SetAssoc1To1 (nameof (UsagePoint), value);
  }

  /// <summary>
  /// All end device functions this end device performs.
  /// </summary>
  public EndDeviceFunction[] EndDeviceFunctions => GetAssoc1ToM<
      EndDeviceFunction> (nameof (EndDeviceFunctions));
  public void
  AddToEndDeviceFunctions (EndDeviceFunction assocObject) => AddAssoc1ToM (
      nameof (EndDeviceFunctions), assocObject);
  public void RemoveFromEndDeviceFunctions (
      EndDeviceFunction
          assocObject) => RemoveAssoc1ToM (nameof (EndDeviceFunctions),
                                           assocObject);
  public void RemoveAllFromEndDeviceFunctions () => RemoveAllAssocs1ToM (
      nameof (EndDeviceFunctions));
}
/// <summary>
/// Inherent capabilities of an end device (i.e., the functions it supports).
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceCapability
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceCapability";

  /// <summary>
  /// True if autonomous DST (daylight saving time) function is supported.
  /// </summary>
  public bool ? autonomousDst
  {
    get => GetAttribute < bool ? > (nameof (autonomousDst));
    set => SetAttribute (nameof (autonomousDst), value);
  }
  /// <summary>
  /// True if communication function is supported.
  /// </summary>
  public bool ? communication
  {
    get => GetAttribute < bool ? > (nameof (communication));
    set => SetAttribute (nameof (communication), value);
  }
  /// <summary>
  /// True if connect and disconnect function is supported.
  /// </summary>
  public bool ? connectDisconnect
  {
    get => GetAttribute < bool ? > (nameof (connectDisconnect));
    set => SetAttribute (nameof (connectDisconnect), value);
  }
  /// <summary>
  /// True if demand response function is supported.
  /// </summary>
  public bool ? demandResponse
  {
    get => GetAttribute < bool ? > (nameof (demandResponse));
    set => SetAttribute (nameof (demandResponse), value);
  }
  /// <summary>
  /// True if electric metering function is supported.
  /// </summary>
  public bool ? electricMetering
  {
    get => GetAttribute < bool ? > (nameof (electricMetering));
    set => SetAttribute (nameof (electricMetering), value);
  }
  /// <summary>
  /// True if gas metering function is supported.
  /// </summary>
  public bool ? gasMetering
  {
    get => GetAttribute < bool ? > (nameof (gasMetering));
    set => SetAttribute (nameof (gasMetering), value);
  }
  /// <summary>
  /// True if metrology function is supported.
  /// </summary>
  public bool ? metrology
  {
    get => GetAttribute < bool ? > (nameof (metrology));
    set => SetAttribute (nameof (metrology), value);
  }
  /// <summary>
  /// True if on request read function is supported.
  /// </summary>
  public bool ? onRequestRead
  {
    get => GetAttribute < bool ? > (nameof (onRequestRead));
    set => SetAttribute (nameof (onRequestRead), value);
  }
  /// <summary>
  /// True if outage history function is supported.
  /// </summary>
  public bool ? outageHistory
  {
    get => GetAttribute < bool ? > (nameof (outageHistory));
    set => SetAttribute (nameof (outageHistory), value);
  }
  /// <summary>
  /// True if device performs pressure compensation for metered quantities.
  /// </summary>
  public bool ? pressureCompensation
  {
    get => GetAttribute < bool ? > (nameof (pressureCompensation));
    set => SetAttribute (nameof (pressureCompensation), value);
  }
  /// <summary>
  /// True if pricing information is supported.
  /// </summary>
  public bool ? pricingInfo
  {
    get => GetAttribute < bool ? > (nameof (pricingInfo));
    set => SetAttribute (nameof (pricingInfo), value);
  }
  /// <summary>
  /// True if device produces pulse outputs.
  /// </summary>
  public bool ? pulseOutput
  {
    get => GetAttribute < bool ? > (nameof (pulseOutput));
    set => SetAttribute (nameof (pulseOutput), value);
  }
  /// <summary>
  /// True if relays programming function is supported.
  /// </summary>
  public bool ? relaysProgramming
  {
    get => GetAttribute < bool ? > (nameof (relaysProgramming));
    set => SetAttribute (nameof (relaysProgramming), value);
  }
  /// <summary>
  /// True if reverse flow function is supported.
  /// </summary>
  public bool ? reverseFlow
  {
    get => GetAttribute < bool ? > (nameof (reverseFlow));
    set => SetAttribute (nameof (reverseFlow), value);
  }
  /// <summary>
  /// True if device performs super compressibility compensation for metered
  /// quantities.
  /// </summary>
  public bool ? superCompressibilityCompensation
  {
    get => GetAttribute < bool ? > (nameof (superCompressibilityCompensation));
    set => SetAttribute (nameof (superCompressibilityCompensation), value);
  }
  /// <summary>
  /// True if device performs temperature compensation for metered quantities.
  /// </summary>
  public bool ? temperatureCompensation
  {
    get => GetAttribute < bool ? > (nameof (temperatureCompensation));
    set => SetAttribute (nameof (temperatureCompensation), value);
  }
  /// <summary>
  /// True if the displaying of text messages is supported.
  /// </summary>
  public bool ? textMessage
  {
    get => GetAttribute < bool ? > (nameof (textMessage));
    set => SetAttribute (nameof (textMessage), value);
  }
  /// <summary>
  /// True if water metering function is supported.
  /// </summary>
  public bool ? waterMetering
  {
    get => GetAttribute < bool ? > (nameof (waterMetering));
    set => SetAttribute (nameof (waterMetering), value);
  }
}
/// <summary>
/// Instructs an end device (or an end device group) to perform a specified
/// action.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceControl
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceControl";

  /// <summary>
  /// Reason for the control action that allows to determine how to continue
  /// processing. For example, disconnect meter command may require different
  /// processing by the receiving system if it has been issued for a
  /// network-related reason (protection) or for a payment-related reason.
  /// </summary>
  public string ? reason
  {
    get => GetAttribute < string ? > (nameof (reason));
    set => SetAttribute (nameof (reason), value);
  }

  /// <summary>
  /// Type of this end device control.
  /// </summary>
  public EndDeviceControlType ? EndDeviceControlType
  {
    get => GetAssoc1To1<EndDeviceControlType> (nameof (EndDeviceControlType));
    set => SetAssoc1To1 (nameof (EndDeviceControlType), value);
  }

  /// <summary>
  /// All end devices receiving commands from this end device control.
  /// </summary>
  public EndDevice[] EndDevices => GetAssoc1ToM<EndDevice> (
      nameof (EndDevices));
  public void AddToEndDevices (EndDevice assocObject) => AddAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveFromEndDevices (EndDevice assocObject) => RemoveAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveAllFromEndDevices () => RemoveAllAssocs1ToM (
      nameof (EndDevices));
  /// <summary>
  /// All usage points receiving commands from this end device control.
  /// </summary>
  public UsagePoint[] UsagePoints => GetAssoc1ToM<UsagePoint> (
      nameof (UsagePoints));
  public void AddToUsagePoints (UsagePoint assocObject) => AddAssoc1ToM (
      nameof (UsagePoints), assocObject);
  public void RemoveFromUsagePoints (
      UsagePoint assocObject) => RemoveAssoc1ToM (nameof (UsagePoints),
                                                  assocObject);
  public void RemoveAllFromUsagePoints () => RemoveAllAssocs1ToM (
      nameof (UsagePoints));
}
/// <summary>
/// Detailed description for a control produced by an end device. Values in
/// attributes allow for creation of recommended codes to be used for
/// identifying end device controls as follows:
/// <type>.<domain>.<subDomain>.<eventOrAction>.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceControlType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceControlType";

  /// <summary>
  /// High-level nature of the control.
  /// </summary>
  public string ? domain
  {
    get => GetAttribute < string ? > (nameof (domain));
    set => SetAttribute (nameof (domain), value);
  }
  /// <summary>
  /// The most specific part of this control type. It is mainly in the form of a
  /// verb that gives action to the control that just occurred.
  /// </summary>
  public string ? eventOrAction
  {
    get => GetAttribute < string ? > (nameof (eventOrAction));
    set => SetAttribute (nameof (eventOrAction), value);
  }
  /// <summary>
  /// More specific nature of the control, as a further sub-categorisation of
  /// 'domain'.
  /// </summary>
  public string ? subDomain
  {
    get => GetAttribute < string ? > (nameof (subDomain));
    set => SetAttribute (nameof (subDomain), value);
  }
  /// <summary>
  /// Type of physical device from which the control was created. A value of
  /// zero (0) can be used when the source is unknown.
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
}
/// <summary>
/// Event detected by a device function associated with the end device.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceEvent
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ActivityRecord (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#EndDeviceEvent";

  /// <summary>
  /// Type of this end device event.
  /// </summary>
  public EndDeviceEventType ? EndDeviceEventType
  {
    get => GetAssoc1To1<EndDeviceEventType> (nameof (EndDeviceEventType));
    set => SetAssoc1To1 (nameof (EndDeviceEventType), value);
  }
  /// <summary>
  /// Usage point for which this end device event is reported.
  /// </summary>
  public UsagePoint ? UsagePoint
  {
    get => GetAssoc1To1<UsagePoint> (nameof (UsagePoint));
    set => SetAssoc1To1 (nameof (UsagePoint), value);
  }

  /// <summary>
  /// All details of this end device event.
  /// </summary>
  public EndDeviceEventDetail[] EndDeviceEventDetails => GetAssoc1ToM<
      EndDeviceEventDetail> (nameof (EndDeviceEventDetails));
  public void AddToEndDeviceEventDetails (
      EndDeviceEventDetail
          assocObject) => AddAssoc1ToM (nameof (EndDeviceEventDetails),
                                        assocObject);
  public void RemoveFromEndDeviceEventDetails (
      EndDeviceEventDetail
          assocObject) => RemoveAssoc1ToM (nameof (EndDeviceEventDetails),
                                           assocObject);
  public void RemoveAllFromEndDeviceEventDetails () => RemoveAllAssocs1ToM (
      nameof (EndDeviceEventDetails));
}
/// <summary>
/// Name-value pair, specific to end device events.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceEventDetail
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceEventDetail";

  /// <summary>
  /// Name.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }
  /// <summary>
  /// Value, including unit information.
  /// </summary>
  public StringQuantity ? value
  {
    get => GetAttribute < StringQuantity ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Detailed description for an event produced by an end device. Values in
/// attributes allow for creation of recommended codes to be used for
/// identifying end device events as follows:
/// <type>.<domain>.<subDomain>.<eventOrAction>.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceEventType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceEventType";

  /// <summary>
  /// High-level nature of the event. By properly classifying events by a small
  /// set of domain codes, a system can more easily run reports based on the
  /// types of events that have occurred or been received.
  /// </summary>
  public string ? domain
  {
    get => GetAttribute < string ? > (nameof (domain));
    set => SetAttribute (nameof (domain), value);
  }
  /// <summary>
  /// The most specific part of this event type. It is mainly in the form of a
  /// verb that gives action to the event that just occurred.
  /// </summary>
  public string ? eventOrAction
  {
    get => GetAttribute < string ? > (nameof (eventOrAction));
    set => SetAttribute (nameof (eventOrAction), value);
  }
  /// <summary>
  /// More specific nature of the event, as a further sub-categorisation of
  /// 'domain'.
  /// </summary>
  public string ? subDomain
  {
    get => GetAttribute < string ? > (nameof (subDomain));
    set => SetAttribute (nameof (subDomain), value);
  }
  /// <summary>
  /// Type of physical device from which the event was created. A value of zero
  /// (0) can be used when the source is unknown.
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
}
/// <summary>
/// Function performed by an end device such as a meter, communication
/// equipment, controllers, etc.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceFunction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetFunction (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EndDeviceFunction";

  /// <summary>
  /// True if the function is enabled.
  /// </summary>
  public bool ? enabled
  {
    get => GetAttribute < bool ? > (nameof (enabled));
    set => SetAttribute (nameof (enabled), value);
  }

  /// <summary>
  /// All registers for quantities metered by this end device function.
  /// </summary>
  public Register[] Registers => GetAssoc1ToM<Register> (nameof (Registers));
  public void AddToRegisters (Register assocObject) => AddAssoc1ToM (
      nameof (Registers), assocObject);
  public void RemoveFromRegisters (Register assocObject) => RemoveAssoc1ToM (
      nameof (Registers), assocObject);
  public void RemoveAllFromRegisters () => RemoveAllAssocs1ToM (
      nameof (Registers));
}
/// <summary>
/// End device data.
/// </summary>
[CimClass (ClassUri)]
public partial class EndDeviceInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#EndDeviceInfo";

  /// <summary>
  /// Inherent capabilities of the device (i.e., the functions it supports).
  /// </summary>
  public EndDeviceCapability ? capability
  {
    get => GetAttribute < EndDeviceCapability ? > (nameof (capability));
    set => SetAttribute (nameof (capability), value);
  }
  /// <summary>
  /// If true, this is a solid state end device (as opposed to a mechanical or
  /// electromechanical device).
  /// </summary>
  public bool ? isSolidState
  {
    get => GetAttribute < bool ? > (nameof (isSolidState));
    set => SetAttribute (nameof (isSolidState), value);
  }
  /// <summary>
  /// Number of potential phases the end device supports, typically 0, 1 or 3.
  /// </summary>
  public int ? phaseCount
  {
    get => GetAttribute < int ? > (nameof (phaseCount));
    set => SetAttribute (nameof (phaseCount), value);
  }
  /// <summary>
  /// Rated current.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Rated voltage.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
}
/// <summary>
/// Generic user of energy - a  point of consumption on the power system
/// model.EnergyConsumer.pfixed, .qfixed, .pfixedPct and .qfixedPct have meaning
/// only if there is no LoadResponseCharacteristic associated with
/// EnergyConsumer or if LoadResponseCharacteristic.exponentModel is set to
/// False.
/// </summary>
[CimClass (ClassUri)]
public partial class EnergyConsumer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#EnergyConsumer";

  /// <summary>
  /// Number of individual customers represented by this demand.
  /// </summary>
  public int ? customerCount
  {
    get => GetAttribute < int ? > (nameof (customerCount));
    set => SetAttribute (nameof (customerCount), value);
  }
}
/// <summary>
/// A generic equivalent for an energy supplier on a transmission or
/// distribution voltage level.
/// </summary>
[CimClass (ClassUri)]
public partial class EnergySource
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#EnergySource";
}
/// <summary>
/// This is a environmental based limit dependency model for calculating
/// operational limits.
/// </summary>
[CimClass (ClassUri)]
public partial class EnvironmentalDependentLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : LimitDependency (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EnvironmentalDependentLimit";
}
/// <summary>
/// The parts of a power system that are physical devices, electronic or
/// mechanical.
/// </summary>
[CimClass (ClassUri)]
public partial class Equipment
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Equipment";

  /// <summary>
  /// Specifies the availability of the equipment under normal operating
  /// conditions. True means the equipment is available for topology processing,
  /// which determines if the equipment is energized or not. False means that
  /// the equipment is treated by network applications as if it is not in the
  /// model.
  /// </summary>
  public bool ? normallyInService
  {
    get => GetAttribute < bool ? > (nameof (normallyInService));
    set => SetAttribute (nameof (normallyInService), value);
  }

  /// <summary>
  /// Container of this equipment.
  /// </summary>
  public EquipmentContainer ? EquipmentContainer
  {
    get => GetAssoc1To1<EquipmentContainer> (nameof (EquipmentContainer));
    set => SetAssoc1To1 (nameof (EquipmentContainer), value);
  }
  /// <summary>
  ///
  /// </summary>
  public VoltageLimitDurationCurve ? VoltageLimitDurationCurve
  {
    get => GetAssoc1To1<VoltageLimitDurationCurve> (
        nameof (VoltageLimitDurationCurve));
    set => SetAssoc1To1 (nameof (VoltageLimitDurationCurve), value);
  }

  /// <summary>
  /// Additional equipment container beyond the primary equipment container. The
  /// equipment is contained in another equipment container, but also grouped
  /// with this equipment container.
  /// </summary>
  public EquipmentContainer[] AdditionalEquipmentContainer => GetAssoc1ToM<
      EquipmentContainer> (nameof (AdditionalEquipmentContainer));
  public void AddToAdditionalEquipmentContainer (
      EquipmentContainer
          assocObject) => AddAssoc1ToM (nameof (AdditionalEquipmentContainer),
                                        assocObject);
  public void RemoveFromAdditionalEquipmentContainer (
      EquipmentContainer
          assocObject) => RemoveAssoc1ToM (nameof (AdditionalEquipmentContainer),
                                           assocObject);
  public void
  RemoveAllFromAdditionalEquipmentContainer () => RemoveAllAssocs1ToM (
      nameof (AdditionalEquipmentContainer));
  /// <summary>
  /// Limit dependencymodels organized under this equipment as a means for
  /// organizing the model in a tree view.
  /// </summary>
  public LimitDependency[] LimitDependencyModel => GetAssoc1ToM<
      LimitDependency> (nameof (LimitDependencyModel));
  public void
  AddToLimitDependencyModel (LimitDependency assocObject) => AddAssoc1ToM (
      nameof (LimitDependencyModel), assocObject);
  public void RemoveFromLimitDependencyModel (
      LimitDependency
          assocObject) => RemoveAssoc1ToM (nameof (LimitDependencyModel),
                                           assocObject);
  public void RemoveAllFromLimitDependencyModel () => RemoveAllAssocs1ToM (
      nameof (LimitDependencyModel));
  /// <summary>
  /// The operational limit sets associated with this equipment.
  /// </summary>
  public OperationalLimitSet[] OperationalLimitSet => GetAssoc1ToM<
      OperationalLimitSet> (nameof (OperationalLimitSet));
  public void
  AddToOperationalLimitSet (OperationalLimitSet assocObject) => AddAssoc1ToM (
      nameof (OperationalLimitSet), assocObject);
  public void RemoveFromOperationalLimitSet (
      OperationalLimitSet
          assocObject) => RemoveAssoc1ToM (nameof (OperationalLimitSet),
                                           assocObject);
  public void RemoveAllFromOperationalLimitSet () => RemoveAllAssocs1ToM (
      nameof (OperationalLimitSet));
  /// <summary>
  /// All usage points connected to the electrical grid through this equipment.
  /// </summary>
  public UsagePoint[] UsagePoints => GetAssoc1ToM<UsagePoint> (
      nameof (UsagePoints));
  public void AddToUsagePoints (UsagePoint assocObject) => AddAssoc1ToM (
      nameof (UsagePoints), assocObject);
  public void RemoveFromUsagePoints (
      UsagePoint assocObject) => RemoveAssoc1ToM (nameof (UsagePoints),
                                                  assocObject);
  public void RemoveAllFromUsagePoints () => RemoveAllAssocs1ToM (
      nameof (UsagePoints));
}
/// <summary>
/// A modelling construct to provide a root class for containing equipment.
/// </summary>
[CimClass (ClassUri)]
public partial class EquipmentContainer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConnectivityNodeContainer (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#EquipmentContainer";

  /// <summary>
  /// The additonal contained equipment.  The equipment belong to the equipment
  /// container. The equipment is contained in another equipment container, but
  /// also grouped with this equipment container.  Examples include when a
  /// switch contained in a substation is also desired to be grouped with a line
  /// contianer or when a switch is included in a secondary substation and also
  /// grouped in a feeder.
  /// </summary>
  public Equipment[] AdditionalGroupedEquipment => GetAssoc1ToM<Equipment> (
      nameof (AdditionalGroupedEquipment));
  public void
  AddToAdditionalGroupedEquipment (Equipment assocObject) => AddAssoc1ToM (
      nameof (AdditionalGroupedEquipment), assocObject);
  public void RemoveFromAdditionalGroupedEquipment (
      Equipment
          assocObject) => RemoveAssoc1ToM (nameof (AdditionalGroupedEquipment),
                                           assocObject);
  public void
  RemoveAllFromAdditionalGroupedEquipment () => RemoveAllAssocs1ToM (
      nameof (AdditionalGroupedEquipment));
  /// <summary>
  /// Contained equipment.
  /// </summary>
  public Equipment[] Equipments => GetAssoc1ToM<Equipment> (
      nameof (Equipments));
  public void AddToEquipments (Equipment assocObject) => AddAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveFromEquipments (Equipment assocObject) => RemoveAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveAllFromEquipments () => RemoveAllAssocs1ToM (
      nameof (Equipments));
}
/// <summary>
/// Any unique purchased part for manufactured product tracked by ERP systems
/// for a utility.Item, as used by the OAG, refers to the basic information
/// about an item, including its attributes, cost, and locations. It does not
/// include item quantities. Compare to the Inventory, which includes all
/// quantities and other location-specific information.
/// </summary>
[CimClass (ClassUri)]
public partial class ErpItemMaster
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ErpItemMaster";
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ExcitationControl
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ExcitationControl";

  /// <summary>
  ///
  /// </summary>
  public string ? stabilizerType
  {
    get => GetAttribute < string ? > (nameof (stabilizerType));
    set => SetAttribute (nameof (stabilizerType), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? voltageControlType
  {
    get => GetAttribute < string ? > (nameof (voltageControlType));
    set => SetAttribute (nameof (voltageControlType), value);
  }

  /// <summary>
  ///
  /// </summary>
  public ExcitationSystem ? ExcitationSystem
  {
    get => GetAssoc1To1<ExcitationSystem> (nameof (ExcitationSystem));
    set => SetAssoc1To1 (nameof (ExcitationSystem), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ExcitationControllnfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ExcitationControllnfo";

  /// <summary>
  ///
  /// </summary>
  public string ? algorithmVersion
  {
    get => GetAttribute < string ? > (nameof (algorithmVersion));
    set => SetAttribute (nameof (algorithmVersion), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? currentGainFactor
  {
    get => GetAttribute < float ? > (nameof (currentGainFactor));
    set => SetAttribute (nameof (currentGainFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyGainFactor
  {
    get => GetAttribute < float ? > (nameof (frequencyGainFactor));
    set => SetAttribute (nameof (frequencyGainFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyGainFactorDerivative
  {
    get => GetAttribute < float ? > (nameof (frequencyGainFactorDerivative));
    set => SetAttribute (nameof (frequencyGainFactorDerivative), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyMaxGainFactor
  {
    get => GetAttribute < float ? > (nameof (frequencyMaxGainFactor));
    set => SetAttribute (nameof (frequencyMaxGainFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyMaxGainFactorDerivative
  {
    get => GetAttribute < float ? > (nameof (frequencyMaxGainFactorDerivative));
    set => SetAttribute (nameof (frequencyMaxGainFactorDerivative), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? piTimeConstant
  {
    get => GetAttribute < float ? > (nameof (piTimeConstant));
    set => SetAttribute (nameof (piTimeConstant), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotorCurrentGainFactorDerivative
  {
    get => GetAttribute < float ? > (nameof (rotorCurrentGainFactorDerivative));
    set => SetAttribute (nameof (rotorCurrentGainFactorDerivative), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotorCurrentMaxGainFactorDerivative
  {
    get => GetAttribute < float
        ? > (nameof (rotorCurrentMaxGainFactorDerivative));
    set => SetAttribute (nameof (rotorCurrentMaxGainFactorDerivative), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageGainFactor
  {
    get => GetAttribute < float ? > (nameof (voltageGainFactor));
    set => SetAttribute (nameof (voltageGainFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageGainFactorDerivative
  {
    get => GetAttribute < float ? > (nameof (voltageGainFactorDerivative));
    set => SetAttribute (nameof (voltageGainFactorDerivative), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageMaxGainFactor
  {
    get => GetAttribute < float ? > (nameof (voltageMaxGainFactor));
    set => SetAttribute (nameof (voltageMaxGainFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageMaxGainFactorDerivative
  {
    get => GetAttribute < float ? > (nameof (voltageMaxGainFactorDerivative));
    set => SetAttribute (nameof (voltageMaxGainFactorDerivative), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ExcitationSystem
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ExcitationSystem";

  /// <summary>
  ///
  /// </summary>
  public float ? currentExcitationForcingRatio
  {
    get => GetAttribute < float ? > (nameof (currentExcitationForcingRatio));
    set => SetAttribute (nameof (currentExcitationForcingRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? excitationForcingDelay
  {
    get => GetAttribute < float ? > (nameof (excitationForcingDelay));
    set => SetAttribute (nameof (excitationForcingDelay), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? excitationForcingDuration
  {
    get => GetAttribute < float ? > (nameof (excitationForcingDuration));
    set => SetAttribute (nameof (excitationForcingDuration), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? excitationForcingRapidity
  {
    get => GetAttribute < float ? > (nameof (excitationForcingRapidity));
    set => SetAttribute (nameof (excitationForcingRapidity), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fullDeexcitationTime
  {
    get => GetAttribute < float ? > (nameof (fullDeexcitationTime));
    set => SetAttribute (nameof (fullDeexcitationTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxDoubleOverloadTime
  {
    get => GetAttribute < float ? > (nameof (maxDoubleOverloadTime));
    set => SetAttribute (nameof (maxDoubleOverloadTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? relayExcitationReleaseDelay
  {
    get => GetAttribute < float ? > (nameof (relayExcitationReleaseDelay));
    set => SetAttribute (nameof (relayExcitationReleaseDelay), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? relayExcitationReleaseVoltage
  {
    get => GetAttribute < float ? > (nameof (relayExcitationReleaseVoltage));
    set => SetAttribute (nameof (relayExcitationReleaseVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? relayExcitationTriggerVoltage
  {
    get => GetAttribute < float ? > (nameof (relayExcitationTriggerVoltage));
    set => SetAttribute (nameof (relayExcitationTriggerVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotorGD2
  {
    get => GetAttribute < float ? > (nameof (rotorGD2));
    set => SetAttribute (nameof (rotorGD2), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? timeConstant
  {
    get => GetAttribute < float ? > (nameof (timeConstant));
    set => SetAttribute (nameof (timeConstant), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? timeDoubleCurrentOverload
  {
    get => GetAttribute < float ? > (nameof (timeDoubleCurrentOverload));
    set => SetAttribute (nameof (timeDoubleCurrentOverload), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageDeexcitationRatio
  {
    get => GetAttribute < float ? > (nameof (voltageDeexcitationRatio));
    set => SetAttribute (nameof (voltageDeexcitationRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageExcitationForcingRatio
  {
    get => GetAttribute < float ? > (nameof (voltageExcitationForcingRatio));
    set => SetAttribute (nameof (voltageExcitationForcingRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? voltageExcitationRampRate
  {
    get => GetAttribute < float ? > (nameof (voltageExcitationRampRate));
    set => SetAttribute (nameof (voltageExcitationRampRate), value);
  }

  /// <summary>
  ///
  /// </summary>
  public ExcitationControl ? ExcitationControl
  {
    get => GetAssoc1To1<ExcitationControl> (nameof (ExcitationControl));
    set => SetAssoc1To1 (nameof (ExcitationControl), value);
  }

  /// <summary>
  ///
  /// </summary>
  public SynchronousMachine[] SynchronousMachine => GetAssoc1ToM<
      SynchronousMachine> (nameof (SynchronousMachine));
  public void
  AddToSynchronousMachine (SynchronousMachine assocObject) => AddAssoc1ToM (
      nameof (SynchronousMachine), assocObject);
  public void RemoveFromSynchronousMachine (
      SynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (SynchronousMachine),
                                           assocObject);
  public void RemoveAllFromSynchronousMachine () => RemoveAllAssocs1ToM (
      nameof (SynchronousMachine));
}
/// <summary>
/// A facility may contain buildings, storage facilities, switching facilities,
/// power generation, manufacturing facilities, maintenance facilities, etc.
/// </summary>
[CimClass (ClassUri)]
public partial class Facility
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Facility";
}
/// <summary>
/// The fossil fuel consumed by the non-nuclear thermal generating unit.   For
/// example, coal, oil, gas, etc.   These are the specific fuels that the
/// generating unit can consume.
/// </summary>
[CimClass (ClassUri)]
public partial class FossilFuel
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#FossilFuel";

  /// <summary>
  /// The type of fossil fuel, such as coal, oil, or gas.
  /// </summary>
  public FuelType ? fossilFuelType
  {
    get => GetAttribute < FuelType ? > (nameof (fossilFuelType));
    set => SetAttribute (nameof (fossilFuelType), value);
  }
  /// <summary>
  /// The efficiency factor for the fuel (per unit) in terms of the effective
  /// energy absorbed.
  /// </summary>
  public float ? fuelEffFactor
  {
    get => GetAttribute < float ? > (nameof (fuelEffFactor));
    set => SetAttribute (nameof (fuelEffFactor), value);
  }
  /// <summary>
  /// The amount of heat per weight (or volume) of the given type of fuel.
  /// </summary>
  public float ? fuelHeatContent
  {
    get => GetAttribute < float ? > (nameof (fuelHeatContent));
    set => SetAttribute (nameof (fuelHeatContent), value);
  }

  /// <summary>
  /// A thermal generating unit may have one or more fossil fuels.
  /// </summary>
  public ThermalGeneratingUnit ? ThermalGeneratingUnit
  {
    get => GetAssoc1To1<ThermalGeneratingUnit> (nameof (ThermalGeneratingUnit));
    set => SetAssoc1To1 (nameof (ThermalGeneratingUnit), value);
  }
}
/// <summary>
/// Fossil fuelled boiler (e.g., coal, oil, gas).
/// </summary>
[CimClass (ClassUri)]
public partial class FossilSteamSupply
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SteamSupply (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#FossilSteamSupply";
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class FrequencyLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OperationalLimit (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#FrequencyLimit";

  /// <summary>
  ///
  /// </summary>
  public float ? normalValue
  {
    get => GetAttribute < float ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// An overcurrent protective device with a circuit opening fusible part that is
/// heated and severed by the passage of overcurrent through it. A fuse is
/// considered a switching device because it breaks current.
/// </summary>
[CimClass (ClassUri)]
public partial class Fuse
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Switch (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Fuse";
}
/// <summary>
/// A single or set of synchronous machines for converting mechanical power into
/// alternating-current power. For example, individual machines within a set may
/// be defined for scheduling purposes while a single control signal is derived
/// for the set. In this case there would be a GeneratingUnit for each member of
/// the set and an additional GeneratingUnit corresponding to the set.
/// </summary>
[CimClass (ClassUri)]
public partial class GeneratingUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#GeneratingUnit";

  /// <summary>
  /// Governor Speed Changer Droop.   This is the change in generator power
  /// output divided by the change in frequency normalized by the nominal power
  /// of the generator and the nominal frequency and expressed in percent and
  /// negated. A positive value of speed change droop provides additional
  /// generator output upon a drop in frequency.
  /// </summary>
  public float ? governorSCD
  {
    get => GetAttribute < float ? > (nameof (governorSCD));
    set => SetAttribute (nameof (governorSCD), value);
  }
  /// <summary>
  /// High limit for secondary (AGC) control.
  /// </summary>
  public float ? highControlLimit
  {
    get => GetAttribute < float ? > (nameof (highControlLimit));
    set => SetAttribute (nameof (highControlLimit), value);
  }
  /// <summary>
  /// Low limit for secondary (AGC) control.
  /// </summary>
  public float ? lowControlLimit
  {
    get => GetAttribute < float ? > (nameof (lowControlLimit));
    set => SetAttribute (nameof (lowControlLimit), value);
  }
  /// <summary>
  /// The normal maximum rate the generating unit active power output can be
  /// lowered by control actions.
  /// </summary>
  public float ? lowerRampRate
  {
    get => GetAttribute < float ? > (nameof (lowerRampRate));
    set => SetAttribute (nameof (lowerRampRate), value);
  }
  /// <summary>
  /// This is the maximum operating active power limit the dispatcher can enter
  /// for this unit.
  /// </summary>
  public float ? maxOperatingP
  {
    get => GetAttribute < float ? > (nameof (maxOperatingP));
    set => SetAttribute (nameof (maxOperatingP), value);
  }
  /// <summary>
  /// This is the minimum operating active power limit the dispatcher can enter
  /// for this unit.
  /// </summary>
  public float ? minOperatingP
  {
    get => GetAttribute < float ? > (nameof (minOperatingP));
    set => SetAttribute (nameof (minOperatingP), value);
  }
  /// <summary>
  /// The nominal power of the generating unit.  Used to give precise meaning to
  /// percentage based attributes such as the governor speed change droop
  /// (governorSCD attribute).The attribute shall be a positive value equal to
  /// or less than RotatingMachine.ratedS.
  /// </summary>
  public float ? nominalP
  {
    get => GetAttribute < float ? > (nameof (nominalP));
    set => SetAttribute (nameof (nominalP), value);
  }
  /// <summary>
  /// The normal maximum rate the generating unit active power output can be
  /// raised by control actions.
  /// </summary>
  public float ? raiseRampRate
  {
    get => GetAttribute < float ? > (nameof (raiseRampRate));
    set => SetAttribute (nameof (raiseRampRate), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? unitGD2
  {
    get => GetAttribute < float ? > (nameof (unitGD2));
    set => SetAttribute (nameof (unitGD2), value);
  }

  /// <summary>
  /// A synchronous machine may operate as a generator and as such becomes a
  /// member of a generating unit.
  /// </summary>
  public RotatingMachine[] RotatingMachine => GetAssoc1ToM<RotatingMachine> (
      nameof (RotatingMachine));
  public void AddToRotatingMachine (
      RotatingMachine assocObject) => AddAssoc1ToM (nameof (RotatingMachine),
                                                    assocObject);
  public void RemoveFromRotatingMachine (
      RotatingMachine assocObject) => RemoveAssoc1ToM (nameof (RotatingMachine),
                                                       assocObject);
  public void RemoveAllFromRotatingMachine () => RemoveAllAssocs1ToM (
      nameof (RotatingMachine));
}
/// <summary>
/// A geographical region of a power system network model.
/// </summary>
[CimClass (ClassUri)]
public partial class GeographicalRegion
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#GeographicalRegion";

  /// <summary>
  /// All sub-geographical regions within this geographical region.
  /// </summary>
  public SubGeographicalRegion[] Regions => GetAssoc1ToM<
      SubGeographicalRegion> (nameof (Regions));
  public void AddToRegions (SubGeographicalRegion assocObject) => AddAssoc1ToM (
      nameof (Regions), assocObject);
  public void RemoveFromRegions (
      SubGeographicalRegion assocObject) => RemoveAssoc1ToM (nameof (Regions),
                                                             assocObject);
  public void RemoveAllFromRegions () => RemoveAllAssocs1ToM (nameof (Regions));
}
/// <summary>
/// Action on ground as a switching step.
/// </summary>
[CimClass (ClassUri)]
public partial class GroundAction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#GroundAction";
}
/// <summary>
/// A manually operated or motor operated mechanical switching device used for
/// isolating a circuit or equipment from ground.
/// </summary>
[CimClass (ClassUri)]
public partial class GroundDisconnector
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Switch (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#GroundDisconnector";
}
/// <summary>
/// A fixed impedance device used for grounding.
/// </summary>
[CimClass (ClassUri)]
public partial class GroundingImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EarthFaultCompensator (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#GroundingImpedance";

  /// <summary>
  /// Reactance of device.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
}
/// <summary>
/// The heat recovery system associated with combustion turbines in order to
/// produce steam for combined cycle plants.
/// </summary>
[CimClass (ClassUri)]
public partial class HeatRecoveryBoiler
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : FossilSteamSupply (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#HeatRecoveryBoiler";

  /// <summary>
  /// A combustion turbine may have a heat recovery boiler for making steam.
  /// </summary>
  public CombustionTurbine[] CombustionTurbines => GetAssoc1ToM<
      CombustionTurbine> (nameof (CombustionTurbines));
  public void
  AddToCombustionTurbines (CombustionTurbine assocObject) => AddAssoc1ToM (
      nameof (CombustionTurbines), assocObject);
  public void RemoveFromCombustionTurbines (
      CombustionTurbine
          assocObject) => RemoveAssoc1ToM (nameof (CombustionTurbines),
                                           assocObject);
  public void RemoveAllFromCombustionTurbines () => RemoveAllAssocs1ToM (
      nameof (CombustionTurbines));
}
/// <summary>
/// A generating unit whose prime mover is a hydraulic turbine (e.g., Francis,
/// Pelton, Kaplan).
/// </summary>
[CimClass (ClassUri)]
public partial class HydroGeneratingUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : GeneratingUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#HydroGeneratingUnit";

  /// <summary>
  /// Energy conversion capability for generating.
  /// </summary>
  public HydroEnergyConversionKind ? energyConversionCapability
  {
    get => GetAttribute < HydroEnergyConversionKind
        ? > (nameof (energyConversionCapability));
    set => SetAttribute (nameof (energyConversionCapability), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? normaIWaterLevel
  {
    get => GetAttribute < float ? > (nameof (normaIWaterLevel));
    set => SetAttribute (nameof (normaIWaterLevel), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? normalWaterFlow
  {
    get => GetAttribute < float ? > (nameof (normalWaterFlow));
    set => SetAttribute (nameof (normalWaterFlow), value);
  }

  /// <summary>
  /// The hydro generating unit belongs to a hydro power plant.
  /// </summary>
  public HydroPowerPlant ? HydroPowerPlant
  {
    get => GetAssoc1To1<HydroPowerPlant> (nameof (HydroPowerPlant));
    set => SetAssoc1To1 (nameof (HydroPowerPlant), value);
  }
}
/// <summary>
/// A hydro power station which can generate or pump. When generating, the
/// generator turbines receive water from an upper reservoir. When pumping, the
/// pumps receive their water from a lower reservoir.
/// </summary>
[CimClass (ClassUri)]
public partial class HydroPowerPlant
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#HydroPowerPlant";

  /// <summary>
  /// The hydro plant's generating rating active power for rated head
  /// conditions.The attribute shall be a positive value.
  /// </summary>
  public float ? genRatedP
  {
    get => GetAttribute < float ? > (nameof (genRatedP));
    set => SetAttribute (nameof (genRatedP), value);
  }
  /// <summary>
  /// The type of hydro power plant water storage.
  /// </summary>
  public HydroPlantStorageKind ? hydroPlantStorageType
  {
    get => GetAttribute < HydroPlantStorageKind
        ? > (nameof (hydroPlantStorageType));
    set => SetAttribute (nameof (hydroPlantStorageType), value);
  }

  /// <summary>
  /// The hydro generating unit belongs to a hydro power plant.
  /// </summary>
  public HydroGeneratingUnit[] HydroGeneratingUnits => GetAssoc1ToM<
      HydroGeneratingUnit> (nameof (HydroGeneratingUnits));
  public void
  AddToHydroGeneratingUnits (HydroGeneratingUnit assocObject) => AddAssoc1ToM (
      nameof (HydroGeneratingUnits), assocObject);
  public void RemoveFromHydroGeneratingUnits (
      HydroGeneratingUnit
          assocObject) => RemoveAssoc1ToM (nameof (HydroGeneratingUnits),
                                           assocObject);
  public void RemoveAllFromHydroGeneratingUnits () => RemoveAllAssocs1ToM (
      nameof (HydroGeneratingUnits));
}
/// <summary>
/// A water driven prime mover. Typical turbine types are: Francis, Kaplan, and
/// Pelton.
/// </summary>
[CimClass (ClassUri)]
public partial class HydroTurbine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PrimeMover (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#HydroTurbine";

  /// <summary>
  /// Type of turbine.
  /// </summary>
  public HydroTurbineKind ? turbineType
  {
    get => GetAttribute < HydroTurbineKind ? > (nameof (turbineType));
    set => SetAttribute (nameof (turbineType), value);
  }
}
/// <summary>
/// The class describe a measurement or control value. The purpose is to enable
/// having attributes and associations common for measurement and control.
/// </summary>
[CimClass (ClassUri)]
public partial class IOPoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#IOPoint";
}
/// <summary>
/// This is a root class to provide common identification for all classes
/// needing identification and naming attributes.
/// </summary>
[CimClass (ClassUri)]
public partial class IdentifiedObject
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#IdentifiedObject";

  /// <summary>
  /// The aliasName is free text human readable name of the object alternative
  /// to IdentifiedObject.name. It may be non unique and may not correlate to a
  /// naming hierarchy.The attribute aliasName is retained because of backwards
  /// compatibility between CIM relases. It is however recommended to replace
  /// aliasName with the Name class as aliasName is planned for retirement at a
  /// future time.
  /// </summary>
  public string ? aliasName
  {
    get => GetAttribute < string ? > (nameof (aliasName));
    set => SetAttribute (nameof (aliasName), value);
  }
  /// <summary>
  /// The description is a free human readable text describing or naming the
  /// object. It may be non unique and may not correlate to a naming hierarchy.
  /// </summary>
  public string ? description
  {
    get => GetAttribute < string ? > (nameof (description));
    set => SetAttribute (nameof (description), value);
  }
  /// <summary>
  /// Master resource identifier issued by a model authority. The mRID is unique
  /// within an exchange context. Global uniqueness is easily achieved by using
  /// a UUID, as specified in RFC 4122, for the mRID. The use of UUID is
  /// strongly recommended.For CIMXML data files in RDF syntax conforming to IEC
  /// 61970-552, the mRID is mapped to rdf:ID or rdf:about attributes that
  /// identify CIM object elements.
  /// </summary>
  public string ? mRID
  {
    get => GetAttribute < string ? > (nameof (mRID));
    set => SetAttribute (nameof (mRID), value);
  }
  /// <summary>
  /// The name is any free human readable and possibly non unique text naming
  /// the object.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }

  /// <summary>
  /// All names of this identified object.
  /// </summary>
  public Name[] Names => GetAssoc1ToM<Name> (nameof (Names));
  public void AddToNames (Name assocObject) => AddAssoc1ToM (nameof (Names),
                                                             assocObject);
  public void RemoveFromNames (Name assocObject) => RemoveAssoc1ToM (
      nameof (Names), assocObject);
  public void RemoveAllFromNames () => RemoveAllAssocs1ToM (nameof (Names));
  /// <summary>
  ///
  /// </summary>
  public UserAttribute[] CustomAttributes => GetAssoc1ToM<UserAttribute> (
      nameof (CustomAttributes));
  public void AddToCustomAttributes (
      UserAttribute assocObject) => AddAssoc1ToM (nameof (CustomAttributes),
                                                  assocObject);
  public void RemoveFromCustomAttributes (
      UserAttribute assocObject) => RemoveAssoc1ToM (nameof (CustomAttributes),
                                                     assocObject);
  public void RemoveAllFromCustomAttributes () => RemoveAllAssocs1ToM (
      nameof (CustomAttributes));
  /// <summary>
  ///
  /// </summary>
  public OrganisationRole[] OrganisationRoles => GetAssoc1ToM<
      OrganisationRole> (nameof (OrganisationRoles));
  public void AddToOrganisationRoles (
      OrganisationRole assocObject) => AddAssoc1ToM (nameof (OrganisationRoles),
                                                     assocObject);
  public void RemoveFromOrganisationRoles (
      OrganisationRole
          assocObject) => RemoveAssoc1ToM (nameof (OrganisationRoles),
                                           assocObject);
  public void RemoveAllFromOrganisationRoles () => RemoveAllAssocs1ToM (
      nameof (OrganisationRoles));
}
/// <summary>
/// Dates associated with asset 'in use' status. May have multiple in use dates
/// for this device and a compound type allows a query to return multiple dates.
/// </summary>
[CimClass (ClassUri)]
public partial class InUseDate
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#InUseDate";

  /// <summary>
  /// Date asset was most recently put in use.
  /// </summary>
  public DateTime ? inUseDate
  {
    get => GetAttribute < DateTime ? > (nameof (inUseDate));
    set => SetAttribute (nameof (inUseDate), value);
  }
  /// <summary>
  /// Date of most recent asset transition to not ready for use state.
  /// </summary>
  public DateTime ? notReadyForUseDate
  {
    get => GetAttribute < DateTime ? > (nameof (notReadyForUseDate));
    set => SetAttribute (nameof (notReadyForUseDate), value);
  }
  /// <summary>
  /// Date of most recent asset transition to ready for use state.
  /// </summary>
  public DateTime ? readyForUseDate
  {
    get => GetAttribute < DateTime ? > (nameof (readyForUseDate));
    set => SetAttribute (nameof (readyForUseDate), value);
  }
}
/// <summary>
/// Time sequence of readings of the same reading type. Contained interval
/// readings may need conversion through the application of an offset and a
/// scalar defined in associated pending.Table 548 shows all association ends of
/// IntervalBlock with other classes.Table 548 – Association ends of
/// Metering::IntervalBlock with other classesAssociationsnamemult
/// totypedescription0..*PendingCalculation0..1PendingCalculationPending
/// calculation to apply to interval reading values contained by this block
/// (after which the resulting reading type is different than the original
/// because it reflects the conversion
/// result).0..*IntervalReadings0..*IntervalReadingInterval reading contained in
/// this block.0..*ReadingType0..1ReadingTypeType information for interval
/// reading values contained in this block.0..*MeterReading0..1MeterReadingMeter
/// reading containing this interval block.IntervalReadingData captured at
/// regular intervals of time. Interval data could be captured as incremental
/// data, absolute data, or relative data. The source for the data is usually a
/// tariff quantity or an engineering quantity. Data is typically captured in
/// time-tagged, uniform, fixed-length intervals of 5 min, 10 min, 15 min, 30
/// min, or 60 min.Note: Interval Data is sometimes also called "Interval Data
/// Readings" (IDR).
/// </summary>
[CimClass (ClassUri)]
public partial class IntervalBlock
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#IntervalBlock";

  /// <summary>
  /// Type information for interval reading values contained in this block.
  /// </summary>
  public ReadingType ? ReadingType
  {
    get => GetAssoc1To1<ReadingType> (nameof (ReadingType));
    set => SetAssoc1To1 (nameof (ReadingType), value);
  }

  /// <summary>
  /// Interval reading contained in this block.
  /// </summary>
  public IntervalReading[] IntervalReadings => GetAssoc1ToM<IntervalReading> (
      nameof (IntervalReadings));
  public void AddToIntervalReadings (
      IntervalReading assocObject) => AddAssoc1ToM (nameof (IntervalReadings),
                                                    assocObject);
  public void
  RemoveFromIntervalReadings (IntervalReading assocObject) => RemoveAssoc1ToM (
      nameof (IntervalReadings), assocObject);
  public void RemoveAllFromIntervalReadings () => RemoveAllAssocs1ToM (
      nameof (IntervalReadings));
}
/// <summary>
/// Data captured at regular intervals of time. Interval data could be captured
/// as incremental data, absolute data, or relative data. The source for the
/// data is usually a tariff quantity or an engineering quantity. Data is
/// typically captured in time-tagged, uniform, fixed-length intervals of 5 min,
/// 10 min, 15 min, 30 min, or 60 min.Note: Interval Data is sometimes also
/// called "Interval Data Readings" (IDR).
/// </summary>
[CimClass (ClassUri)]
public partial class IntervalReading
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : BaseReading (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#IntervalReading";
}
/// <summary>
/// A short section of conductor with negligible impedance which can be manually
/// removed and replaced if the circuit is de-energized. Note that
/// zero-impedance branches can potentially be modelled by other equipment
/// types.
/// </summary>
[CimClass (ClassUri)]
public partial class Jumper
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Switch (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Jumper";
}
/// <summary>
/// A point where one or more conducting equipments are connected with zero
/// resistance.
/// </summary>
[CimClass (ClassUri)]
public partial class Junction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Connector (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Junction";
}
/// <summary>
/// Dates for asset lifecycle state changes. May have multiple lifecycle dates
/// for this device and a compound type allows a query to return multiple dates.
/// </summary>
[CimClass (ClassUri)]
public partial class LifecycleDate
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#LifecycleDate";

  /// <summary>
  /// Date current installation was completed, which may not be the same as the
  /// in-service date. Asset may have been installed at other locations
  /// previously. Ignored if asset is (1) not currently installed (e.g., stored
  /// in a depot) or (2) not intended to be installed (e.g., vehicle, tool).
  /// </summary>
  public DateTime ? installationDate
  {
    get => GetAttribute < DateTime ? > (nameof (installationDate));
    set => SetAttribute (nameof (installationDate), value);
  }
  /// <summary>
  /// Date the asset was manufactured.
  /// </summary>
  public DateTime ? manufacturedDate
  {
    get => GetAttribute < DateTime ? > (nameof (manufacturedDate));
    set => SetAttribute (nameof (manufacturedDate), value);
  }
  /// <summary>
  /// Date when the asset was last removed from service. Ignored if (1) not
  /// intended to be in service, or (2) currently in service.
  /// </summary>
  public DateTime ? removalDate
  {
    get => GetAttribute < DateTime ? > (nameof (removalDate));
    set => SetAttribute (nameof (removalDate), value);
  }
  /// <summary>
  /// Date the asset is permanently retired from service and may be scheduled
  /// for disposal. Ignored if asset is (1) currently in service, or (2)
  /// permanently removed from service.
  /// </summary>
  public DateTime ? retiredDate
  {
    get => GetAttribute < DateTime ? > (nameof (retiredDate));
    set => SetAttribute (nameof (retiredDate), value);
  }
  /// <summary>
  ///
  /// </summary>
  public DateTime ? initialInServiceDate
  {
    get => GetAttribute < DateTime ? > (nameof (initialInServiceDate));
    set => SetAttribute (nameof (initialInServiceDate), value);
  }
}
/// <summary>
/// A limit calculation model used to compute an operational limit based on
/// external input such as temperature. These are intended to be shared among
/// operational limits with the same calculation form that apply to a piece of
/// equipment..
/// </summary>
[CimClass (ClassUri)]
public partial class LimitDependency
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#LimitDependency";

  /// <summary>
  /// The equipment for which this limit dependency model is organized under.
  /// </summary>
  public Equipment ? Equipment
  {
    get => GetAssoc1To1<Equipment> (nameof (Equipment));
    set => SetAssoc1To1 (nameof (Equipment), value);
  }

  /// <summary>
  /// The operational limits to which this limit dependency model applies.
  /// </summary>
  public OperationalLimit[] OperationalLimit => GetAssoc1ToM<OperationalLimit> (
      nameof (OperationalLimit));
  public void AddToOperationalLimit (
      OperationalLimit assocObject) => AddAssoc1ToM (nameof (OperationalLimit),
                                                     assocObject);
  public void
  RemoveFromOperationalLimit (OperationalLimit assocObject) => RemoveAssoc1ToM (
      nameof (OperationalLimit), assocObject);
  public void RemoveAllFromOperationalLimit () => RemoveAllAssocs1ToM (
      nameof (OperationalLimit));
}
/// <summary>
/// Specifies an operational  limit is calculated by scaling another operational
/// limit.
/// </summary>
[CimClass (ClassUri)]
public partial class LimitScalingLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : LimitDependency (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#LimitScalingLimit";

  /// <summary>
  /// The associated source limit is scaled by this value to compute the limit
  /// of the dependency model.
  /// </summary>
  public float ? limitScalingPercent
  {
    get => GetAttribute < float ? > (nameof (limitScalingPercent));
    set => SetAttribute (nameof (limitScalingPercent), value);
  }

  /// <summary>
  ///
  /// </summary>
  public OperationalLimit ? SourceOperationalLimit
  {
    get => GetAssoc1To1<OperationalLimit> (nameof (SourceOperationalLimit));
    set => SetAssoc1To1 (nameof (SourceOperationalLimit), value);
  }
}
/// <summary>
/// Contains equipment beyond a substation belonging to a power transmission
/// line.
/// </summary>
[CimClass (ClassUri)]
public partial class Line
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Line";

  /// <summary>
  /// The sub-geographical region of the line.
  /// </summary>
  public SubGeographicalRegion ? Region
  {
    get => GetAssoc1To1<SubGeographicalRegion> (nameof (Region));
    set => SetAssoc1To1 (nameof (Region), value);
  }
}
/// <summary>
/// A linear shunt compensator has banks or sections with equal admittance
/// values.
/// </summary>
[CimClass (ClassUri)]
public partial class LinearShuntCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntCompensator (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#LinearShuntCompensator";

  /// <summary>
  /// Zero sequence shunt (charging) susceptance per section.
  /// </summary>
  public float ? b0PerSection
  {
    get => GetAttribute < float ? > (nameof (b0PerSection));
    set => SetAttribute (nameof (b0PerSection), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) susceptance per section.
  /// </summary>
  public float ? bPerSection
  {
    get => GetAttribute < float ? > (nameof (bPerSection));
    set => SetAttribute (nameof (bPerSection), value);
  }
  /// <summary>
  /// Zero sequence shunt (charging) conductance per section.
  /// </summary>
  public float ? g0PerSection
  {
    get => GetAttribute < float ? > (nameof (g0PerSection));
    set => SetAttribute (nameof (g0PerSection), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) conductance per section.
  /// </summary>
  public float ? gPerSection
  {
    get => GetAttribute < float ? > (nameof (gPerSection));
    set => SetAttribute (nameof (gPerSection), value);
  }
}
/// <summary>
/// A mechanical switching device capable of making, carrying, and breaking
/// currents under normal operating conditions.
/// </summary>
[CimClass (ClassUri)]
public partial class LoadBreakSwitch
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ProtectedSwitch (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#LoadBreakSwitch";
}
/// <summary>
/// The place, scene, or point of something where someone or something has been,
/// is, and/or will be at a given moment in time. It can be defined with one or
/// more position points (coordinates) in a given coordinate system.
/// </summary>
[CimClass (ClassUri)]
public partial class Location
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Location";

  /// <summary>
  /// (if applicable) Direction that allows field crews to quickly find a given
  /// asset. For a given location, such as a street address, this is the
  /// relative direction in which to find the asset. For example, a streetlight
  /// may be located at the 'NW' (northwest) corner of the customer's site, or a
  /// usage point may be located on the second floor of an apartment building.
  /// </summary>
  public string ? direction
  {
    get => GetAttribute < string ? > (nameof (direction));
    set => SetAttribute (nameof (direction), value);
  }
  /// <summary>
  /// Electronic address.
  /// </summary>
  public ElectronicAddress ? electronicAddress
  {
    get => GetAttribute < ElectronicAddress ? > (nameof (electronicAddress));
    set => SetAttribute (nameof (electronicAddress), value);
  }
  /// <summary>
  /// (if applicable) Reference to geographical information source, often
  /// external to the utility.
  /// </summary>
  public string ? geoInfoReference
  {
    get => GetAttribute < string ? > (nameof (geoInfoReference));
    set => SetAttribute (nameof (geoInfoReference), value);
  }
  /// <summary>
  /// Main address of the location.
  /// </summary>
  public StreetAddress ? mainAddress
  {
    get => GetAttribute < StreetAddress ? > (nameof (mainAddress));
    set => SetAttribute (nameof (mainAddress), value);
  }
  /// <summary>
  /// Phone number.
  /// </summary>
  public TelephoneNumber ? phone1
  {
    get => GetAttribute < TelephoneNumber ? > (nameof (phone1));
    set => SetAttribute (nameof (phone1), value);
  }
  /// <summary>
  /// Additional phone number.
  /// </summary>
  public TelephoneNumber ? phone2
  {
    get => GetAttribute < TelephoneNumber ? > (nameof (phone2));
    set => SetAttribute (nameof (phone2), value);
  }
  /// <summary>
  /// Secondary address of the location. For example, PO Box address may have
  /// different ZIP code than that in the 'mainAddress'.
  /// </summary>
  public StreetAddress ? secondaryAddress
  {
    get => GetAttribute < StreetAddress ? > (nameof (secondaryAddress));
    set => SetAttribute (nameof (secondaryAddress), value);
  }
  /// <summary>
  /// Status of this location.
  /// </summary>
  public Status ? status
  {
    get => GetAttribute < Status ? > (nameof (status));
    set => SetAttribute (nameof (status), value);
  }
  /// <summary>
  /// Classification by utility's corporate standards and practices, relative to
  /// the location itself (e.g., geographical, functional accounting, etc., not
  /// a given property that happens to exist at that location).
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }

  /// <summary>
  /// Coordinate system used to describe position points of this location.
  /// </summary>
  public CoordinateSystem ? CoordinateSystem
  {
    get => GetAssoc1To1<CoordinateSystem> (nameof (CoordinateSystem));
    set => SetAssoc1To1 (nameof (CoordinateSystem), value);
  }

  /// <summary>
  /// All assets at this location.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
  /// <summary>
  /// All configuration events created for this location.
  /// </summary>
  public ConfigurationEvent[] ConfigurationEvents => GetAssoc1ToM<
      ConfigurationEvent> (nameof (ConfigurationEvents));
  public void
  AddToConfigurationEvents (ConfigurationEvent assocObject) => AddAssoc1ToM (
      nameof (ConfigurationEvents), assocObject);
  public void RemoveFromConfigurationEvents (
      ConfigurationEvent
          assocObject) => RemoveAssoc1ToM (nameof (ConfigurationEvents),
                                           assocObject);
  public void RemoveAllFromConfigurationEvents () => RemoveAllAssocs1ToM (
      nameof (ConfigurationEvents));
  /// <summary>
  /// Sequence of position points describing this location, expressed in
  /// coordinate system 'Location.CoordinateSystem'.
  /// </summary>
  public PositionPoint[] PositionPoints => GetAssoc1ToM<PositionPoint> (
      nameof (PositionPoints));
  public void AddToPositionPoints (PositionPoint assocObject) => AddAssoc1ToM (
      nameof (PositionPoints), assocObject);
  public void RemoveFromPositionPoints (
      PositionPoint assocObject) => RemoveAssoc1ToM (nameof (PositionPoints),
                                                     assocObject);
  public void RemoveAllFromPositionPoints () => RemoveAllAssocs1ToM (
      nameof (PositionPoints));
  /// <summary>
  /// All power system resources at this location.
  /// </summary>
  public PowerSystemResource[] PowerSystemResources => GetAssoc1ToM<
      PowerSystemResource> (nameof (PowerSystemResources));
  public void
  AddToPowerSystemResources (PowerSystemResource assocObject) => AddAssoc1ToM (
      nameof (PowerSystemResources), assocObject);
  public void RemoveFromPowerSystemResources (
      PowerSystemResource
          assocObject) => RemoveAssoc1ToM (nameof (PowerSystemResources),
                                           assocObject);
  public void RemoveAllFromPowerSystemResources () => RemoveAllAssocs1ToM (
      nameof (PowerSystemResources));
}
/// <summary>
/// Organisation that manufactures asset products.
/// </summary>
[CimClass (ClassUri)]
public partial class Manufacturer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OrganisationRole (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Manufacturer";

  /// <summary>
  /// All asset models by this manufacturer.
  /// </summary>
  public ProductAssetModel[] ProductAssetModels => GetAssoc1ToM<
      ProductAssetModel> (nameof (ProductAssetModels));
  public void
  AddToProductAssetModels (ProductAssetModel assocObject) => AddAssoc1ToM (
      nameof (ProductAssetModels), assocObject);
  public void RemoveFromProductAssetModels (
      ProductAssetModel
          assocObject) => RemoveAssoc1ToM (nameof (ProductAssetModels),
                                           assocObject);
  public void RemoveAllFromProductAssetModels () => RemoveAllAssocs1ToM (
      nameof (ProductAssetModels));
}
/// <summary>
/// A Measurement represents any measured, calculated or non-measured
/// non-calculated quantity. Any piece of equipment may contain Measurements,
/// e.g. a substation may have temperature measurements and door open
/// indications, a transformer may have oil temperature and tank pressure
/// measurements, a bay may contain a number of power flow measurements and a
/// Breaker may contain a switch status measurement. The PSR - Measurement
/// association is intended to capture this use of Measurement and is included
/// in the naming hierarchy based on EquipmentContainer. The naming hierarchy
/// typically has Measurements as leaves, e.g.
/// Substation-VoltageLevel-Bay-Switch-Measurement.Some Measurements represent
/// quantities related to a particular sensor location in the network, e.g. a
/// voltage transformer (VT) or potential transformer (PT) at a busbar or a
/// current transformer (CT) at the bar between a breaker and an isolator. The
/// sensing position is not captured in the PSR - Measurement association.
/// Instead it is captured by the Measurement - Terminal association that is
/// used to define the sensing location in the network topology. The location is
/// defined by the connection of the Terminal to ConductingEquipment. If both a
/// Terminal and PSR are associated, and the PSR is of type ConductingEquipment,
/// the associated Terminal should belong to that ConductingEquipment
/// instance.When the sensor location is needed both Measurement-PSR and
/// Measurement-Terminal are used. The Measurement-Terminal association is never
/// used alone.
/// </summary>
[CimClass (ClassUri)]
public partial class Measurement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Measurement";

  /// <summary>
  /// Specifies the type of measurement.  For example, this specifies if the
  /// measurement represents an indoor temperature, outdoor temperature, bus
  /// voltage, line flow, etc.When the measurementType is set to
  /// "Specialization", the type of Measurement is defined in more detail by the
  /// specialized class which inherits from Measurement.
  /// </summary>
  public string ? measurementType
  {
    get => GetAttribute < string ? > (nameof (measurementType));
    set => SetAttribute (nameof (measurementType), value);
  }
  /// <summary>
  /// Indicates to which phases the measurement applies and avoids the need to
  /// use 'measurementType' to also encode phase information (which would
  /// explode the types). The phase information in Measurement, along with
  /// 'measurementType' and 'phases' uniquely defines a Measurement for a
  /// device, based on normal network phase. Their meaning will not change when
  /// the computed energizing phasing is changed due to jumpers or other
  /// reasons.If the attribute is missing three phases (ABC) shall be assumed.
  /// </summary>
  public PhaseCode ? phases
  {
    get => GetAttribute < PhaseCode ? > (nameof (phases));
    set => SetAttribute (nameof (phases), value);
  }
  /// <summary>
  /// The unit multiplier of the measured quantity.
  /// </summary>
  public UnitMultiplier ? unitMultiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (unitMultiplier));
    set => SetAttribute (nameof (unitMultiplier), value);
  }
  /// <summary>
  /// The unit of measure of the measured quantity.
  /// </summary>
  public UnitSymbol ? unitSymbol
  {
    get => GetAttribute < UnitSymbol ? > (nameof (unitSymbol));
    set => SetAttribute (nameof (unitSymbol), value);
  }

  /// <summary>
  /// The power system resource that contains the measurement.
  /// </summary>
  public PowerSystemResource ? PowerSystemResource
  {
    get => GetAssoc1To1<PowerSystemResource> (nameof (PowerSystemResource));
    set => SetAssoc1To1 (nameof (PowerSystemResource), value);
  }
  /// <summary>
  /// One or more measurements may be associated with a terminal in the network.
  /// </summary>
  public ACDCTerminal ? Terminal
  {
    get => GetAssoc1To1<ACDCTerminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }
}
/// <summary>
/// The current state for a measurement. A state value is an instance of a
/// measurement from a specific source. Measurements can be associated with many
/// state values, each representing a different source for the measurement.
/// </summary>
[CimClass (ClassUri)]
public partial class MeasurementValue
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IOPoint (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#MeasurementValue";

  /// <summary>
  /// The time when the value was last updated.
  /// </summary>
  public DateTime ? timeStamp
  {
    get => GetAttribute < DateTime ? > (nameof (timeStamp));
    set => SetAttribute (nameof (timeStamp), value);
  }
}
/// <summary>
/// Physical asset that performs the metering role of the usage point. Used for
/// measuring consumption and detection of events.
/// </summary>
[CimClass (ClassUri)]
public partial class Meter
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EndDevice (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Meter";

  /// <summary>
  /// Meter form designation per ANSI C12.10 or other applicable standard. An
  /// alphanumeric designation denoting the circuit arrangement for which the
  /// meter is applicable and its specific terminal arrangement.
  /// </summary>
  public string ? formNumber
  {
    get => GetAttribute < string ? > (nameof (formNumber));
    set => SetAttribute (nameof (formNumber), value);
  }

  /// <summary>
  /// All multipliers applied at this meter.
  /// </summary>
  public MeterMultiplier[] MeterMultipliers => GetAssoc1ToM<MeterMultiplier> (
      nameof (MeterMultipliers));
  public void AddToMeterMultipliers (
      MeterMultiplier assocObject) => AddAssoc1ToM (nameof (MeterMultipliers),
                                                    assocObject);
  public void
  RemoveFromMeterMultipliers (MeterMultiplier assocObject) => RemoveAssoc1ToM (
      nameof (MeterMultipliers), assocObject);
  public void RemoveAllFromMeterMultipliers () => RemoveAllAssocs1ToM (
      nameof (MeterMultipliers));
  /// <summary>
  /// All meter readings provided by this meter.
  /// </summary>
  public MeterReading[] MeterReadings => GetAssoc1ToM<MeterReading> (
      nameof (MeterReadings));
  public void AddToMeterReadings (MeterReading assocObject) => AddAssoc1ToM (
      nameof (MeterReadings), assocObject);
  public void RemoveFromMeterReadings (
      MeterReading assocObject) => RemoveAssoc1ToM (nameof (MeterReadings),
                                                    assocObject);
  public void RemoveAllFromMeterReadings () => RemoveAllAssocs1ToM (
      nameof (MeterReadings));
}
/// <summary>
/// Multiplier applied at the meter.
/// </summary>
[CimClass (ClassUri)]
public partial class MeterMultiplier
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#MeterMultiplier";

  /// <summary>
  /// Kind of multiplier.
  /// </summary>
  public MeterMultiplierKind ? kind
  {
    get => GetAttribute < MeterMultiplierKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
  /// <summary>
  /// Multiplier value.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Set of values obtained from the meter.
/// </summary>
[CimClass (ClassUri)]
public partial class MeterReading
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#MeterReading";

  /// <summary>
  /// Date and time interval of the data items contained within this meter
  /// reading.
  /// </summary>
  public DateTimeInterval ? valuesInterval
  {
    get => GetAttribute < DateTimeInterval ? > (nameof (valuesInterval));
    set => SetAttribute (nameof (valuesInterval), value);
  }

  /// <summary>
  /// Meter providing this reading.
  /// </summary>
  public Meter ? Meter
  {
    get => GetAssoc1To1<Meter> (nameof (Meter));
    set => SetAssoc1To1 (nameof (Meter), value);
  }
  /// <summary>
  /// Usage point from which this meter reading (set of values) has been
  /// obtained.
  /// </summary>
  public UsagePoint ? UsagePoint
  {
    get => GetAssoc1To1<UsagePoint> (nameof (UsagePoint));
    set => SetAssoc1To1 (nameof (UsagePoint), value);
  }

  /// <summary>
  /// All end device events associated with this set of measured values.
  /// </summary>
  public EndDeviceEvent[] EndDeviceEvents => GetAssoc1ToM<EndDeviceEvent> (
      nameof (EndDeviceEvents));
  public void AddToEndDeviceEvents (
      EndDeviceEvent assocObject) => AddAssoc1ToM (nameof (EndDeviceEvents),
                                                   assocObject);
  public void RemoveFromEndDeviceEvents (
      EndDeviceEvent assocObject) => RemoveAssoc1ToM (nameof (EndDeviceEvents),
                                                      assocObject);
  public void RemoveAllFromEndDeviceEvents () => RemoveAllAssocs1ToM (
      nameof (EndDeviceEvents));
  /// <summary>
  /// All interval blocks contained in this meter reading.
  /// </summary>
  public IntervalBlock[] IntervalBlocks => GetAssoc1ToM<IntervalBlock> (
      nameof (IntervalBlocks));
  public void AddToIntervalBlocks (IntervalBlock assocObject) => AddAssoc1ToM (
      nameof (IntervalBlocks), assocObject);
  public void RemoveFromIntervalBlocks (
      IntervalBlock assocObject) => RemoveAssoc1ToM (nameof (IntervalBlocks),
                                                     assocObject);
  public void RemoveAllFromIntervalBlocks () => RemoveAllAssocs1ToM (
      nameof (IntervalBlocks));
  /// <summary>
  /// All reading values contained within this meter reading.
  /// </summary>
  public Reading[] Readings => GetAssoc1ToM<Reading> (nameof (Readings));
  public void AddToReadings (Reading assocObject) => AddAssoc1ToM (
      nameof (Readings), assocObject);
  public void RemoveFromReadings (Reading assocObject) => RemoveAssoc1ToM (
      nameof (Readings), assocObject);
  public void RemoveAllFromReadings () => RemoveAllAssocs1ToM (
      nameof (Readings));
}
/// <summary>
/// A specification of the metering requirements for a particular point within a
/// network.
/// </summary>
[CimClass (ClassUri)]
public partial class MetrologyRequirement
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#MetrologyRequirement";

  /// <summary>
  /// Reason for this metrology requirement being specified.
  /// </summary>
  public ReadingReasonKind ? reason
  {
    get => GetAttribute < ReadingReasonKind ? > (nameof (reason));
    set => SetAttribute (nameof (reason), value);
  }

  /// <summary>
  /// All reading types required to be collected by this metrology requirement.
  /// </summary>
  public ReadingType[] ReadingTypes => GetAssoc1ToM<ReadingType> (
      nameof (ReadingTypes));
  public void AddToReadingTypes (ReadingType assocObject) => AddAssoc1ToM (
      nameof (ReadingTypes), assocObject);
  public void RemoveFromReadingTypes (
      ReadingType assocObject) => RemoveAssoc1ToM (nameof (ReadingTypes),
                                                   assocObject);
  public void RemoveAllFromReadingTypes () => RemoveAllAssocs1ToM (
      nameof (ReadingTypes));
}
/// <summary>
/// This class represents the zero sequence line mutual coupling.
/// </summary>
[CimClass (ClassUri)]
public partial class MutualCoupling
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#MutualCoupling";

  /// <summary>
  /// Zero sequence mutual coupling shunt (charging) susceptance, uniformly
  /// distributed, of the entire line section.
  /// </summary>
  public float ? b0ch
  {
    get => GetAttribute < float ? > (nameof (b0ch));
    set => SetAttribute (nameof (b0ch), value);
  }
  /// <summary>
  /// Distance to the start of the coupled region from the first line's terminal
  /// having sequence number equal to 1.
  /// </summary>
  public float ? distance11
  {
    get => GetAttribute < float ? > (nameof (distance11));
    set => SetAttribute (nameof (distance11), value);
  }
  /// <summary>
  /// Distance to the end of the coupled region from the first line's terminal
  /// with sequence number equal to 1.
  /// </summary>
  public float ? distance12
  {
    get => GetAttribute < float ? > (nameof (distance12));
    set => SetAttribute (nameof (distance12), value);
  }
  /// <summary>
  /// Distance to the start of coupled region from the second line's terminal
  /// with sequence number equal to 1.
  /// </summary>
  public float ? distance21
  {
    get => GetAttribute < float ? > (nameof (distance21));
    set => SetAttribute (nameof (distance21), value);
  }
  /// <summary>
  /// Distance to the end of coupled region from the second line's terminal with
  /// sequence number equal to 1.
  /// </summary>
  public float ? distance22
  {
    get => GetAttribute < float ? > (nameof (distance22));
    set => SetAttribute (nameof (distance22), value);
  }
  /// <summary>
  /// Zero sequence mutual coupling shunt (charging) conductance, uniformly
  /// distributed, of the entire line section.
  /// </summary>
  public float ? g0ch
  {
    get => GetAttribute < float ? > (nameof (g0ch));
    set => SetAttribute (nameof (g0ch), value);
  }
  /// <summary>
  /// Zero sequence branch-to-branch mutual impedance coupling, resistance.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Zero sequence branch-to-branch mutual impedance coupling, reactance.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  /// The starting terminal for the calculation of distances along the first
  /// branch of the mutual coupling.  Normally MutualCoupling would only be used
  /// for terminals of AC line segments.  The first and second terminals of a
  /// mutual coupling should point to different AC line segments.
  /// </summary>
  public Terminal ? First_Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (First_Terminal));
    set => SetAssoc1To1 (nameof (First_Terminal), value);
  }
  /// <summary>
  /// The starting terminal for the calculation of distances along the second
  /// branch of the mutual coupling.
  /// </summary>
  public Terminal ? Second_Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (Second_Terminal));
    set => SetAssoc1To1 (nameof (Second_Terminal), value);
  }
}
/// <summary>
/// The Name class provides the means to define any number of human readable
/// names for an object. A name is <b>not</b> to be used for defining
/// inter-object relationships. For inter-object relationships instead use the
/// object identification 'mRID'.
/// </summary>
[CimClass (ClassUri)]
public partial class Name
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Name";

  /// <summary>
  /// Any free text that name the object.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }

  /// <summary>
  /// Identified object that this name designates.
  /// </summary>
  public IdentifiedObject ? IdentifiedObject
  {
    get => GetAssoc1To1<IdentifiedObject> (nameof (IdentifiedObject));
    set => SetAssoc1To1 (nameof (IdentifiedObject), value);
  }
  /// <summary>
  /// Type of this name.
  /// </summary>
  public NameType ? NameType
  {
    get => GetAssoc1To1<NameType> (nameof (NameType));
    set => SetAssoc1To1 (nameof (NameType), value);
  }
}
/// <summary>
/// Type of name. Possible values for attribute 'name' are implementation
/// dependent but standard profiles may specify types. An enterprise may have
/// multiple IT systems each having its own local name for the same object, e.g.
/// a planning system may have different names from an EMS. An object may also
/// have different names within the same IT system, e.g. localName as defined in
/// CIM version 14. The definition from CIM14 is:The localName is a human
/// readable name of the object. It is a free text name local to a node in a
/// naming hierarchy similar to a file directory structure. A power system
/// related naming hierarchy may be: Substation, VoltageLevel, Equipment etc.
/// Children of the same parent in such a hierarchy have names that typically
/// are unique among them.
/// </summary>
[CimClass (ClassUri)]
public partial class NameType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#NameType";

  /// <summary>
  /// Description of the name type.
  /// </summary>
  public string ? description
  {
    get => GetAttribute < string ? > (nameof (description));
    set => SetAttribute (nameof (description), value);
  }
  /// <summary>
  /// Name of the name type.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }

  /// <summary>
  /// All names of this type.
  /// </summary>
  public Name[] Names => GetAssoc1ToM<Name> (nameof (Names));
  public void AddToNames (Name assocObject) => AddAssoc1ToM (nameof (Names),
                                                             assocObject);
  public void RemoveFromNames (Name assocObject) => RemoveAssoc1ToM (
      nameof (Names), assocObject);
  public void RemoveAllFromNames () => RemoveAllAssocs1ToM (nameof (Names));
}
/// <summary>
/// No-load test results determine core admittance parameters. They include
/// exciting current and core loss measurements from applying voltage to one
/// winding. The excitation may be positive sequence or zero sequence. The test
/// may be repeated at different voltages to measure saturation.
/// </summary>
[CimClass (ClassUri)]
public partial class NoLoadTest
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TransformerTest (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#NoLoadTest";

  /// <summary>
  /// Voltage applied to the winding (end) during test.
  /// </summary>
  public float ? energisedEndVoltage
  {
    get => GetAttribute < float ? > (nameof (energisedEndVoltage));
    set => SetAttribute (nameof (energisedEndVoltage), value);
  }
  /// <summary>
  /// Exciting current measured from a positive-sequence or single-phase
  /// excitation test.
  /// </summary>
  public float ? excitingCurrent
  {
    get => GetAttribute < float ? > (nameof (excitingCurrent));
    set => SetAttribute (nameof (excitingCurrent), value);
  }
  /// <summary>
  /// Losses measured from a positive-sequence or single-phase excitation test.
  /// </summary>
  public float ? loss
  {
    get => GetAttribute < float ? > (nameof (loss));
    set => SetAttribute (nameof (loss), value);
  }

  /// <summary>
  /// Transformer end that current is applied to in this no-load test.
  /// </summary>
  public TransformerEndInfo ? EnergisedEnd
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (EnergisedEnd));
    set => SetAssoc1To1 (nameof (EnergisedEnd), value);
  }
}
/// <summary>
/// A non linear shunt compensator has bank or section admittance values that
/// differ. The attributes g, b, g0 and b0 of the associated
/// NonlinearShuntCompensatorPoint describe the total conductance and admittance
/// of a NonlinearShuntCompensatorPoint at a section number specified by
/// NonlinearShuntCompensatorPoint.sectionNumber.
/// </summary>
[CimClass (ClassUri)]
public partial class NonlinearShuntCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntCompensator (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#NonlinearShuntCompensator";
}
/// <summary>
/// A nuclear generating unit.
/// </summary>
[CimClass (ClassUri)]
public partial class NuclearGeneratingUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : GeneratingUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#NuclearGeneratingUnit";
}
/// <summary>
/// Properties of switch assets.
/// </summary>
[CimClass (ClassUri)]
public partial class OldSwitchInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SwitchInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#OldSwitchInfo";
}
/// <summary>
/// A value and normal value associated with a specific kind of limit. The sub
/// class value and normalValue attributes vary inversely to the associated
/// OperationalLimitType.acceptableDuration (acceptableDuration for short).  If
/// a particular piece of equipment has multiple operational limits of the same
/// kind (apparent power, current, etc.), the limit with the greatest
/// acceptableDuration shall have the smallest limit value and the limit with
/// the smallest acceptableDuration shall have the largest limit value.  Note: A
/// large current can only be allowed to flow through a piece of equipment for a
/// short duration without causing damage, but a lesser current can be allowed
/// to flow for a longer duration.
/// </summary>
[CimClass (ClassUri)]
public partial class OperationalLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#OperationalLimit";

  /// <summary>
  ///
  /// </summary>
  public OperationalLimitSet ? OperationalLimitSet
  {
    get => GetAssoc1To1<OperationalLimitSet> (nameof (OperationalLimitSet));
    set => SetAssoc1To1 (nameof (OperationalLimitSet), value);
  }
  /// <summary>
  /// The limit type associated with this limit.
  /// </summary>
  public OperationalLimitType ? OperationalLimitType
  {
    get => GetAssoc1To1<OperationalLimitType> (nameof (OperationalLimitType));
    set => SetAssoc1To1 (nameof (OperationalLimitType), value);
  }

  /// <summary>
  /// The limit dependency models which are used to calculate this limit.   If
  /// no limit dependencies are specified then the native limit value is used.
  /// </summary>
  public LimitDependency[] LimitDependencyModel => GetAssoc1ToM<
      LimitDependency> (nameof (LimitDependencyModel));
  public void
  AddToLimitDependencyModel (LimitDependency assocObject) => AddAssoc1ToM (
      nameof (LimitDependencyModel), assocObject);
  public void RemoveFromLimitDependencyModel (
      LimitDependency
          assocObject) => RemoveAssoc1ToM (nameof (LimitDependencyModel),
                                           assocObject);
  public void RemoveAllFromLimitDependencyModel () => RemoveAllAssocs1ToM (
      nameof (LimitDependencyModel));
  /// <summary>
  ///
  /// </summary>
  public LimitScalingLimit[] LimitScalingLimit => GetAssoc1ToM<
      LimitScalingLimit> (nameof (LimitScalingLimit));
  public void
  AddToLimitScalingLimit (LimitScalingLimit assocObject) => AddAssoc1ToM (
      nameof (LimitScalingLimit), assocObject);
  public void RemoveFromLimitScalingLimit (
      LimitScalingLimit
          assocObject) => RemoveAssoc1ToM (nameof (LimitScalingLimit),
                                           assocObject);
  public void RemoveAllFromLimitScalingLimit () => RemoveAllAssocs1ToM (
      nameof (LimitScalingLimit));
}
/// <summary>
/// A set of limits associated with equipment.  Sets of limits might apply to a
/// specific temperature, or season for example. A set of limits may contain
/// different severities of limit levels that would apply to the same equipment.
/// The set may contain limits of different types such as apparent power and
/// current limits or high and low voltage limits  that are logically applied
/// together as a set.
/// </summary>
[CimClass (ClassUri)]
public partial class OperationalLimitSet
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#OperationalLimitSet";

  /// <summary>
  /// The equipment to which the limit set applies.
  /// </summary>
  public Equipment ? Equipment
  {
    get => GetAssoc1To1<Equipment> (nameof (Equipment));
    set => SetAssoc1To1 (nameof (Equipment), value);
  }
  /// <summary>
  /// The terminal where the operational limit set apply.
  /// </summary>
  public ACDCTerminal ? Terminal
  {
    get => GetAssoc1To1<ACDCTerminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }

  /// <summary>
  ///
  /// </summary>
  public OperationalLimit[] OperationalLimitValue => GetAssoc1ToM<
      OperationalLimit> (nameof (OperationalLimitValue));
  public void
  AddToOperationalLimitValue (OperationalLimit assocObject) => AddAssoc1ToM (
      nameof (OperationalLimitValue), assocObject);
  public void RemoveFromOperationalLimitValue (
      OperationalLimit
          assocObject) => RemoveAssoc1ToM (nameof (OperationalLimitValue),
                                           assocObject);
  public void RemoveAllFromOperationalLimitValue () => RemoveAllAssocs1ToM (
      nameof (OperationalLimitValue));
}
/// <summary>
/// The operational meaning of a category of limits.
/// </summary>
[CimClass (ClassUri)]
public partial class OperationalLimitType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#OperationalLimitType";

  /// <summary>
  /// The nominal acceptable duration of the limit. Limits are commonly
  /// expressed in terms of the time limit for which the limit is normally
  /// acceptable. The actual acceptable duration of a specific limit may depend
  /// on other local factors such as temperature or wind speed. The attribute
  /// has meaning only if the flag isInfiniteDuration is set to false, hence it
  /// shall not be exchanged when isInfiniteDuration is set to true.
  /// </summary>
  public float ? acceptableDuration
  {
    get => GetAttribute < float ? > (nameof (acceptableDuration));
    set => SetAttribute (nameof (acceptableDuration), value);
  }
  /// <summary>
  /// The direction of the limit.
  /// </summary>
  public OperationalLimitDirectionKind ? direction
  {
    get => GetAttribute < OperationalLimitDirectionKind
        ? > (nameof (direction));
    set => SetAttribute (nameof (direction), value);
  }

  /// <summary>
  /// The operational limits associated with this type of limit.
  /// </summary>
  public OperationalLimit[] OperationalLimit => GetAssoc1ToM<OperationalLimit> (
      nameof (OperationalLimit));
  public void AddToOperationalLimit (
      OperationalLimit assocObject) => AddAssoc1ToM (nameof (OperationalLimit),
                                                     assocObject);
  public void
  RemoveFromOperationalLimit (OperationalLimit assocObject) => RemoveAssoc1ToM (
      nameof (OperationalLimit), assocObject);
  public void RemoveAllFromOperationalLimit () => RemoveAllAssocs1ToM (
      nameof (OperationalLimit));
}
/// <summary>
/// Organisation that might have roles as utility, contractor, supplier,
/// manufacturer, customer, etc.
/// </summary>
[CimClass (ClassUri)]
public partial class Organisation
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Organisation";

  /// <summary>
  /// Electronic address.
  /// </summary>
  public ElectronicAddress ? electronicAddress
  {
    get => GetAttribute < ElectronicAddress ? > (nameof (electronicAddress));
    set => SetAttribute (nameof (electronicAddress), value);
  }
  /// <summary>
  /// Phone number.
  /// </summary>
  public TelephoneNumber ? phone1
  {
    get => GetAttribute < TelephoneNumber ? > (nameof (phone1));
    set => SetAttribute (nameof (phone1), value);
  }
  /// <summary>
  /// Additional phone number.
  /// </summary>
  public TelephoneNumber ? phone2
  {
    get => GetAttribute < TelephoneNumber ? > (nameof (phone2));
    set => SetAttribute (nameof (phone2), value);
  }
  /// <summary>
  /// Postal address, potentially different than 'streetAddress' (e.g., another
  /// city).
  /// </summary>
  public StreetAddress ? postalAddress
  {
    get => GetAttribute < StreetAddress ? > (nameof (postalAddress));
    set => SetAttribute (nameof (postalAddress), value);
  }
  /// <summary>
  /// Street address.
  /// </summary>
  public StreetAddress ? streetAddress
  {
    get => GetAttribute < StreetAddress ? > (nameof (streetAddress));
    set => SetAttribute (nameof (streetAddress), value);
  }

  /// <summary>
  ///
  /// </summary>
  public Organisation ? ParentOrganisation
  {
    get => GetAssoc1To1<Organisation> (nameof (ParentOrganisation));
    set => SetAssoc1To1 (nameof (ParentOrganisation), value);
  }

  /// <summary>
  /// All roles of this organisation.
  /// </summary>
  public OrganisationRole[] Roles => GetAssoc1ToM<OrganisationRole> (
      nameof (Roles));
  public void AddToRoles (OrganisationRole assocObject) => AddAssoc1ToM (
      nameof (Roles), assocObject);
  public void RemoveFromRoles (
      OrganisationRole assocObject) => RemoveAssoc1ToM (nameof (Roles),
                                                        assocObject);
  public void RemoveAllFromRoles () => RemoveAllAssocs1ToM (nameof (Roles));
  /// <summary>
  ///
  /// </summary>
  public Organisation[] ChildOrganisations => GetAssoc1ToM<Organisation> (
      nameof (ChildOrganisations));
  public void AddToChildOrganisations (
      Organisation assocObject) => AddAssoc1ToM (nameof (ChildOrganisations),
                                                 assocObject);
  public void RemoveFromChildOrganisations (
      Organisation assocObject) => RemoveAssoc1ToM (nameof (ChildOrganisations),
                                                    assocObject);
  public void RemoveAllFromChildOrganisations () => RemoveAllAssocs1ToM (
      nameof (ChildOrganisations));
}
/// <summary>
/// Identifies a way in which an organisation may participate in the utility
/// enterprise (e.g., customer, manufacturer, etc).
/// </summary>
[CimClass (ClassUri)]
public partial class OrganisationRole
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#OrganisationRole";

  /// <summary>
  /// Organisation having this role.
  /// </summary>
  public Organisation ? Organisation
  {
    get => GetAssoc1To1<Organisation> (nameof (Organisation));
    set => SetAssoc1To1 (nameof (Organisation), value);
  }

  /// <summary>
  /// All configuration events created for this organisation role.
  /// </summary>
  public ConfigurationEvent[] ConfigurationEvents => GetAssoc1ToM<
      ConfigurationEvent> (nameof (ConfigurationEvents));
  public void
  AddToConfigurationEvents (ConfigurationEvent assocObject) => AddAssoc1ToM (
      nameof (ConfigurationEvents), assocObject);
  public void RemoveFromConfigurationEvents (
      ConfigurationEvent
          assocObject) => RemoveAssoc1ToM (nameof (ConfigurationEvents),
                                           assocObject);
  public void RemoveAllFromConfigurationEvents () => RemoveAllAssocs1ToM (
      nameof (ConfigurationEvents));
  /// <summary>
  ///
  /// </summary>
  public IdentifiedObject[] Objects => GetAssoc1ToM<IdentifiedObject> (
      nameof (Objects));
  public void AddToObjects (IdentifiedObject assocObject) => AddAssoc1ToM (
      nameof (Objects), assocObject);
  public void RemoveFromObjects (
      IdentifiedObject assocObject) => RemoveAssoc1ToM (nameof (Objects),
                                                        assocObject);
  public void RemoveAllFromObjects () => RemoveAllAssocs1ToM (nameof (Objects));
}
/// <summary>
/// Overhead wire data.
/// </summary>
[CimClass (ClassUri)]
public partial class OverheadWireInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : WireInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#OverheadWireInfo";
}
/// <summary>
/// Classifying instances of the same class, e.g. overhead and underground
/// ACLineSegments. This classification mechanism is intended to provide
/// flexibility outside the scope of this document, i.e. provide customisation
/// that is non standard.
/// </summary>
[CimClass (ClassUri)]
public partial class PSRType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#PSRType";

  /// <summary>
  /// Power system resources classified with this power system resource type.
  /// </summary>
  public PowerSystemResource[] PowerSystemResources => GetAssoc1ToM<
      PowerSystemResource> (nameof (PowerSystemResources));
  public void
  AddToPowerSystemResources (PowerSystemResource assocObject) => AddAssoc1ToM (
      nameof (PowerSystemResources), assocObject);
  public void RemoveFromPowerSystemResources (
      PowerSystemResource
          assocObject) => RemoveAssoc1ToM (nameof (PowerSystemResources),
                                           assocObject);
  public void RemoveAllFromPowerSystemResources () => RemoveAllAssocs1ToM (
      nameof (PowerSystemResources));
}
/// <summary>
/// Pressurized water reactor used as a steam supply to a steam turbine.
/// </summary>
[CimClass (ClassUri)]
public partial class PWRSteamSupply
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SteamSupply (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#PWRSteamSupply";
}
/// <summary>
/// Common type for per-length impedance electrical catalogues.
/// </summary>
[CimClass (ClassUri)]
public partial class PerLengthImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PerLengthLineParameter (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PerLengthImpedance";

  /// <summary>
  /// All line segments described by this per-length impedance.
  /// </summary>
  public ACLineSegment[] ACLineSegments => GetAssoc1ToM<ACLineSegment> (
      nameof (ACLineSegments));
  public void AddToACLineSegments (ACLineSegment assocObject) => AddAssoc1ToM (
      nameof (ACLineSegments), assocObject);
  public void RemoveFromACLineSegments (
      ACLineSegment assocObject) => RemoveAssoc1ToM (nameof (ACLineSegments),
                                                     assocObject);
  public void RemoveAllFromACLineSegments () => RemoveAllAssocs1ToM (
      nameof (ACLineSegments));
  /// <summary>
  ///
  /// </summary>
  public ACLineSeriesSection[] ACLineSeriesSection => GetAssoc1ToM<
      ACLineSeriesSection> (nameof (ACLineSeriesSection));
  public void
  AddToACLineSeriesSection (ACLineSeriesSection assocObject) => AddAssoc1ToM (
      nameof (ACLineSeriesSection), assocObject);
  public void RemoveFromACLineSeriesSection (
      ACLineSeriesSection
          assocObject) => RemoveAssoc1ToM (nameof (ACLineSeriesSection),
                                           assocObject);
  public void RemoveAllFromACLineSeriesSection () => RemoveAllAssocs1ToM (
      nameof (ACLineSeriesSection));
}
/// <summary>
/// Common type for per-length electrical catalogues describing line parameters.
/// </summary>
[CimClass (ClassUri)]
public partial class PerLengthLineParameter
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PerLengthLineParameter";

  /// <summary>
  /// A WireAssemblyInfo is used to compute the PerLengthParameter data in the
  /// Wires package
  /// </summary>
  public WireAssemblyInfo ? WireAssemblyInfo
  {
    get => GetAssoc1To1<WireAssemblyInfo> (nameof (WireAssemblyInfo));
    set => SetAssoc1To1 (nameof (WireAssemblyInfo), value);
  }
}
/// <summary>
/// Impedance and admittance parameters per unit length for n-wire unbalanced
/// lines, in matrix form.
/// </summary>
[CimClass (ClassUri)]
public partial class PerLengthPhaseImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PerLengthImpedance (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PerLengthPhaseImpedance";

  /// <summary>
  /// Number of phase, neutral, and other wires retained. Constrains the number
  /// of matrix elements and the phase codes that can be used with this matrix.
  /// </summary>
  public int ? conductorCount
  {
    get => GetAttribute < int ? > (nameof (conductorCount));
    set => SetAttribute (nameof (conductorCount), value);
  }

  /// <summary>
  /// All data that belong to this conductor phase impedance.
  /// </summary>
  public PhaseImpedanceData[] PhaseImpedanceData => GetAssoc1ToM<
      PhaseImpedanceData> (nameof (PhaseImpedanceData));
  public void
  AddToPhaseImpedanceData (PhaseImpedanceData assocObject) => AddAssoc1ToM (
      nameof (PhaseImpedanceData), assocObject);
  public void RemoveFromPhaseImpedanceData (
      PhaseImpedanceData
          assocObject) => RemoveAssoc1ToM (nameof (PhaseImpedanceData),
                                           assocObject);
  public void RemoveAllFromPhaseImpedanceData () => RemoveAllAssocs1ToM (
      nameof (PhaseImpedanceData));
}
/// <summary>
/// Sequence impedance and admittance parameters per unit length, for transposed
/// lines of 1, 2, or 3 phases. For 1-phase lines, define x=x0=xself. For
/// 2-phase lines, define x=xs-xm and x0=xs+xm.
/// </summary>
[CimClass (ClassUri)]
public partial class PerLengthSequenceImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PerLengthImpedance (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PerLengthSequenceImpedance";

  /// <summary>
  /// Zero sequence shunt (charging) susceptance, per unit of length.
  /// </summary>
  public float ? b0ch
  {
    get => GetAttribute < float ? > (nameof (b0ch));
    set => SetAttribute (nameof (b0ch), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) susceptance, per unit of length.
  /// </summary>
  public float ? bch
  {
    get => GetAttribute < float ? > (nameof (bch));
    set => SetAttribute (nameof (bch), value);
  }
  /// <summary>
  /// Zero sequence shunt (charging) conductance, per unit of length.
  /// </summary>
  public float ? g0ch
  {
    get => GetAttribute < float ? > (nameof (g0ch));
    set => SetAttribute (nameof (g0ch), value);
  }
  /// <summary>
  /// Positive sequence shunt (charging) conductance, per unit of length.
  /// </summary>
  public float ? gch
  {
    get => GetAttribute < float ? > (nameof (gch));
    set => SetAttribute (nameof (gch), value);
  }
  /// <summary>
  /// Positive sequence series resistance, per unit of length.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence series resistance, per unit of length.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Positive sequence series reactance, per unit of length.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero sequence series reactance, per unit of length.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }
}
/// <summary>
/// A variable impedance device normally used to offset line charging during
/// single line faults in an ungrounded section of network.
/// </summary>
[CimClass (ClassUri)]
public partial class PetersenCoil
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EarthFaultCompensator (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#PetersenCoil";

  /// <summary>
  /// The mode of operation of the Petersen coil.
  /// </summary>
  public PetersenCoilModeKind ? mode
  {
    get => GetAttribute < PetersenCoilModeKind ? > (nameof (mode));
    set => SetAttribute (nameof (mode), value);
  }
  /// <summary>
  /// The nominal voltage for which the coil is designed.
  /// </summary>
  public float ? nominalU
  {
    get => GetAttribute < float ? > (nameof (nominalU));
    set => SetAttribute (nameof (nominalU), value);
  }
  /// <summary>
  /// The offset current that the Petersen coil controller is operating from the
  /// resonant point.  This is normally a fixed amount for which the controller
  /// is configured and could be positive or negative.  Typically 0 to 60 A
  /// depending on voltage and resonance conditions.
  /// </summary>
  public float ? offsetCurrent
  {
    get => GetAttribute < float ? > (nameof (offsetCurrent));
    set => SetAttribute (nameof (offsetCurrent), value);
  }
  /// <summary>
  /// The maximum reactance.
  /// </summary>
  public float ? xGroundMax
  {
    get => GetAttribute < float ? > (nameof (xGroundMax));
    set => SetAttribute (nameof (xGroundMax), value);
  }
  /// <summary>
  /// The minimum reactance.
  /// </summary>
  public float ? xGroundMin
  {
    get => GetAttribute < float ? > (nameof (xGroundMin));
    set => SetAttribute (nameof (xGroundMin), value);
  }
  /// <summary>
  /// The nominal reactance.  This is the operating point (normally over
  /// compensation) that is defined based on the resonance point in the healthy
  /// network condition.  The impedance is calculated based on nominal voltage
  /// divided by position current.
  /// </summary>
  public float ? xGroundNominal
  {
    get => GetAttribute < float ? > (nameof (xGroundNominal));
    set => SetAttribute (nameof (xGroundNominal), value);
  }
}
/// <summary>
/// Impedance and conductance matrix element values. The diagonal elements are
/// described by the elements having the same toPhase and fromPhase value and
/// the off diagonal elements have different toPhase and fromPhase values.  The
/// matrix can also be stored in symmetric lower triangular format using the row
/// and column attributes, which map to ACLineSegmentPhase.sequenceNumber.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseImpedanceData
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseImpedanceData";

  /// <summary>
  /// Susceptance matrix element value, per length of unit.
  /// </summary>
  public float ? b
  {
    get => GetAttribute < float ? > (nameof (b));
    set => SetAttribute (nameof (b), value);
  }
  /// <summary>
  /// Refer to the class description.
  /// </summary>
  public SinglePhaseKind ? fromPhase
  {
    get => GetAttribute < SinglePhaseKind ? > (nameof (fromPhase));
    set => SetAttribute (nameof (fromPhase), value);
  }
  /// <summary>
  /// Conductance matrix element value, per length of unit.
  /// </summary>
  public float ? g
  {
    get => GetAttribute < float ? > (nameof (g));
    set => SetAttribute (nameof (g), value);
  }
  /// <summary>
  /// Resistance matrix element value, per length of unit.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Refer to the class description.
  /// </summary>
  public SinglePhaseKind ? toPhase
  {
    get => GetAttribute < SinglePhaseKind ? > (nameof (toPhase));
    set => SetAttribute (nameof (toPhase), value);
  }
  /// <summary>
  /// Reactance matrix element value, per length of unit.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }

  /// <summary>
  /// Conductor phase impedance to which this data belongs.
  /// </summary>
  public PerLengthPhaseImpedance ? PhaseImpedance
  {
    get => GetAssoc1To1<PerLengthPhaseImpedance> (nameof (PhaseImpedance));
    set => SetAssoc1To1 (nameof (PhaseImpedance), value);
  }
}
/// <summary>
/// A transformer phase shifting tap model that controls the phase angle
/// difference across the power transformer and potentially the active power
/// flow through the power transformer.  This phase tap model may also impact
/// the voltage magnitude.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChanger
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TapChanger (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChanger";

  /// <summary>
  /// Transformer end to which this phase tap changer belongs.
  /// </summary>
  public TransformerEnd ? TransformerEnd
  {
    get => GetAssoc1To1<TransformerEnd> (nameof (TransformerEnd));
    set => SetAssoc1To1 (nameof (TransformerEnd), value);
  }
}
/// <summary>
/// Describes the tap model for an asymmetrical phase shifting transformer in
/// which the difference voltage vector adds to the in-phase winding. The
/// out-of-phase winding is the transformer end where the tap changer is
/// located.  The angle between the in-phase and out-of-phase windings is named
/// the winding connection angle. The phase shift depends on both the difference
/// voltage magnitude and the winding connection angle.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerAsymmetrical
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PhaseTapChangerNonLinear (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerAsymmetrical";

  /// <summary>
  /// The phase angle between the in-phase winding and the out-of -phase winding
  /// used for creating phase shift. The out-of-phase winding produces what is
  /// known as the difference voltage.  Setting this angle to 90 degrees is not
  /// the same as a symmetrical transformer. The attribute can only be multiples
  /// of 30 degrees.  The allowed range is -150 degrees to 150 degrees excluding
  /// 0.
  /// </summary>
  public float ? windingConnectionAngle
  {
    get => GetAttribute < float ? > (nameof (windingConnectionAngle));
    set => SetAttribute (nameof (windingConnectionAngle), value);
  }
}
/// <summary>
/// Describes a tap changer with a linear relation between the tap step and the
/// phase angle difference across the transformer. This is a mathematical model
/// that is an approximation of a real phase tap changer.The phase angle is
/// computed as stepPhaseShiftIncrement times the tap position.The voltage
/// magnitude of both sides is the same.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerLinear
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PhaseTapChanger (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerLinear";

  /// <summary>
  /// Phase shift per step position. A positive value indicates a positive angle
  /// variation from the Terminal at the  PowerTransformerEnd,  where the
  /// TapChanger is located, into the transformer.The actual phase shift
  /// increment might be more accurately computed from the symmetrical or
  /// asymmetrical models or a tap step table lookup if those are available.
  /// </summary>
  public float ? stepPhaseShiftIncrement
  {
    get => GetAttribute < float ? > (nameof (stepPhaseShiftIncrement));
    set => SetAttribute (nameof (stepPhaseShiftIncrement), value);
  }
  /// <summary>
  /// The reactance depends on the tap position according to a "u" shaped curve.
  /// The maximum reactance (xMax) appears at the low and high tap positions.
  /// Depending on the “u” curve the attribute can be either higher or lower
  /// than PowerTransformerEnd.x.
  /// </summary>
  public float ? xMax
  {
    get => GetAttribute < float ? > (nameof (xMax));
    set => SetAttribute (nameof (xMax), value);
  }
  /// <summary>
  /// The reactance depends on the tap position according to a "u" shaped curve.
  /// The minimum reactance (xMin) appears at the mid tap position.
  /// PowerTransformerEnd.x shall be consistent with PhaseTapChangerLinear.xMin
  /// and PhaseTapChangerNonLinear.xMin. In case of inconsistency,
  /// PowerTransformerEnd.x shall be used.
  /// </summary>
  public float ? xMin
  {
    get => GetAttribute < float ? > (nameof (xMin));
    set => SetAttribute (nameof (xMin), value);
  }
}
/// <summary>
/// The non-linear phase tap changer describes the non-linear behaviour of a
/// phase tap changer. This is a base class for the symmetrical and asymmetrical
/// phase tap changer models. The details of these models can be found in IEC
/// 61970-301.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerNonLinear
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PhaseTapChanger (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerNonLinear";

  /// <summary>
  /// The voltage step increment on the out of phase winding (the
  /// PowerTransformerEnd where the TapChanger is located) specified in percent
  /// of rated voltage of the PowerTransformerEnd. A positive value means a
  /// positive voltage variation from the Terminal at the PowerTransformerEnd,
  /// where the TapChanger is located, into the transformer.When the increment
  /// is negative, the voltage decreases when the tap step increases.
  /// </summary>
  public float ? voltageStepIncrement
  {
    get => GetAttribute < float ? > (nameof (voltageStepIncrement));
    set => SetAttribute (nameof (voltageStepIncrement), value);
  }
  /// <summary>
  /// The reactance depends on the tap position according to a "u" shaped curve.
  /// The maximum reactance (xMax) appears at the low and high tap positions.
  /// Depending on the “u” curve the attribute can be either higher or lower
  /// than PowerTransformerEnd.x.
  /// </summary>
  public float ? xMax
  {
    get => GetAttribute < float ? > (nameof (xMax));
    set => SetAttribute (nameof (xMax), value);
  }
  /// <summary>
  /// The reactance depend on the tap position according to a "u" shaped curve.
  /// The minimum reactance (xMin) appear at the mid tap position.
  /// PowerTransformerEnd.x shall be consistent with PhaseTapChangerLinear.xMin
  /// and PhaseTapChangerNonLinear.xMin. In case of inconsistency,
  /// PowerTransformerEnd.x shall be used.
  /// </summary>
  public float ? xMin
  {
    get => GetAttribute < float ? > (nameof (xMin));
    set => SetAttribute (nameof (xMin), value);
  }
}
/// <summary>
/// Describes a symmetrical phase shifting transformer tap model in which the
/// voltage magnitude of both sides is the same. The difference voltage
/// magnitude is the base in an equal-sided triangle where the sides corresponds
/// to the primary and secondary voltages. The phase angle difference
/// corresponds to the top angle and can be expressed as twice the arctangent of
/// half the total difference voltage.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerSymmetrical
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PhaseTapChangerNonLinear (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerSymmetrical";
}
/// <summary>
/// Describes a tabular curve for how the phase angle difference and impedance
/// varies with the tap step.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerTable
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerTable";

  /// <summary>
  /// The points of this table.
  /// </summary>
  public PhaseTapChangerTablePoint[] PhaseTapChangerTablePoint => GetAssoc1ToM<
      PhaseTapChangerTablePoint> (nameof (PhaseTapChangerTablePoint));
  public void AddToPhaseTapChangerTablePoint (
      PhaseTapChangerTablePoint
          assocObject) => AddAssoc1ToM (nameof (PhaseTapChangerTablePoint),
                                        assocObject);
  public void RemoveFromPhaseTapChangerTablePoint (
      PhaseTapChangerTablePoint
          assocObject) => RemoveAssoc1ToM (nameof (PhaseTapChangerTablePoint),
                                           assocObject);
  public void RemoveAllFromPhaseTapChangerTablePoint () => RemoveAllAssocs1ToM (
      nameof (PhaseTapChangerTablePoint));
  /// <summary>
  /// The phase tap changers to which this phase tap table applies.
  /// </summary>
  public PhaseTapChangerTabular[] PhaseTapChangerTabular => GetAssoc1ToM<
      PhaseTapChangerTabular> (nameof (PhaseTapChangerTabular));
  public void AddToPhaseTapChangerTabular (
      PhaseTapChangerTabular
          assocObject) => AddAssoc1ToM (nameof (PhaseTapChangerTabular),
                                        assocObject);
  public void RemoveFromPhaseTapChangerTabular (
      PhaseTapChangerTabular
          assocObject) => RemoveAssoc1ToM (nameof (PhaseTapChangerTabular),
                                           assocObject);
  public void RemoveAllFromPhaseTapChangerTabular () => RemoveAllAssocs1ToM (
      nameof (PhaseTapChangerTabular));
}
/// <summary>
/// Describes each tap step in the phase tap changer tabular curve.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerTablePoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TapChangerTablePoint (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerTablePoint";

  /// <summary>
  /// The angle difference in degrees. A positive value indicates a positive
  /// angle variation from the Terminal at the  PowerTransformerEnd,  where the
  /// TapChanger is located, into the transformer.
  /// </summary>
  public float ? angle
  {
    get => GetAttribute < float ? > (nameof (angle));
    set => SetAttribute (nameof (angle), value);
  }

  /// <summary>
  /// The table of this point.
  /// </summary>
  public PhaseTapChangerTable ? PhaseTapChangerTable
  {
    get => GetAssoc1To1<PhaseTapChangerTable> (nameof (PhaseTapChangerTable));
    set => SetAssoc1To1 (nameof (PhaseTapChangerTable), value);
  }
}
/// <summary>
/// Describes a tap changer with a table defining the relation between the tap
/// step and the phase angle difference across the transformer.
/// </summary>
[CimClass (ClassUri)]
public partial class PhaseTapChangerTabular
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PhaseTapChanger (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhaseTapChangerTabular";

  /// <summary>
  /// The phase tap changer table for this phase tap changer.
  /// </summary>
  public PhaseTapChangerTable ? PhaseTapChangerTable
  {
    get => GetAssoc1To1<PhaseTapChangerTable> (nameof (PhaseTapChangerTable));
    set => SetAssoc1To1 (nameof (PhaseTapChangerTable), value);
  }
}
/// <summary>
/// A photovoltaic device or an aggregation of such devices.
/// </summary>
[CimClass (ClassUri)]
public partial class PhotoVoltaicUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerElectronicsUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PhotoVoltaicUnit";
}
/// <summary>
/// A Plant is a collection of equipment for purposes of generation.
/// </summary>
[CimClass (ClassUri)]
public partial class Plant
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Plant";

  /// <summary>
  ///
  /// </summary>
  public float ? ratedP
  {
    get => GetAttribute < float ? > (nameof (ratedP));
    set => SetAttribute (nameof (ratedP), value);
  }

  /// <summary>
  ///
  /// </summary>
  public SubGeographicalRegion ? Region
  {
    get => GetAssoc1To1<SubGeographicalRegion> (nameof (Region));
    set => SetAssoc1To1 (nameof (Region), value);
  }

  /// <summary>
  ///
  /// </summary>
  public Substation[] Substations => GetAssoc1ToM<Substation> (
      nameof (Substations));
  public void AddToSubstations (Substation assocObject) => AddAssoc1ToM (
      nameof (Substations), assocObject);
  public void RemoveFromSubstations (
      Substation assocObject) => RemoveAssoc1ToM (nameof (Substations),
                                                  assocObject);
  public void RemoveAllFromSubstations () => RemoveAllAssocs1ToM (
      nameof (Substations));
}
/// <summary>
/// Set of spatial coordinates that determine a point, defined in the coordinate
/// system specified in 'Location.CoordinateSystem'. Use a single position point
/// instance to describe a point-oriented location. Use a sequence of position
/// points to describe a line-oriented object (physical location of non-point
/// oriented objects like cables or lines), or area of an object (like a
/// substation or a geographical zone - in this case, have first and last
/// position point with the same values).
/// </summary>
[CimClass (ClassUri)]
public partial class PositionPoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#PositionPoint";

  /// <summary>
  /// Zero-relative sequence number of this group within a series of points;
  /// used when there is a need to express disjoint groups of points that are
  /// considered to be part of a single location.
  /// </summary>
  public int ? groupNumber
  {
    get => GetAttribute < int ? > (nameof (groupNumber));
    set => SetAttribute (nameof (groupNumber), value);
  }
  /// <summary>
  /// Zero-relative sequence number of this point within a series of points.
  /// </summary>
  public int ? sequenceNumber
  {
    get => GetAttribute < int ? > (nameof (sequenceNumber));
    set => SetAttribute (nameof (sequenceNumber), value);
  }
  /// <summary>
  /// X axis position.
  /// </summary>
  public string ? xPosition
  {
    get => GetAttribute < string ? > (nameof (xPosition));
    set => SetAttribute (nameof (xPosition), value);
  }
  /// <summary>
  /// Y axis position.
  /// </summary>
  public string ? yPosition
  {
    get => GetAttribute < string ? > (nameof (yPosition));
    set => SetAttribute (nameof (yPosition), value);
  }
  /// <summary>
  /// (if applicable) Z axis position.
  /// </summary>
  public string ? zPosition
  {
    get => GetAttribute < string ? > (nameof (zPosition));
    set => SetAttribute (nameof (zPosition), value);
  }

  /// <summary>
  /// Location described by this position point.
  /// </summary>
  public Location ? Location
  {
    get => GetAssoc1To1<Location> (nameof (Location));
    set => SetAssoc1To1 (nameof (Location), value);
  }
}
/// <summary>
/// Instrument transformer (also known as Voltage Transformer) used to measure
/// electrical qualities of the circuit that is being protected and/or
/// monitored. Typically used as voltage transducer for the purpose of metering,
/// protection, or sometimes auxiliary substation supply. A typical secondary
/// voltage rating would be 120V.
/// </summary>
[CimClass (ClassUri)]
public partial class PotentialTransformer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Sensor (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PotentialTransformer";

  /// <summary>
  /// PT accuracy classification.
  /// </summary>
  public string ? accuracyClass
  {
    get => GetAttribute < string ? > (nameof (accuracyClass));
    set => SetAttribute (nameof (accuracyClass), value);
  }
  /// <summary>
  /// Potential transformer construction type.
  /// </summary>
  public PotentialTransformerKind ? type
  {
    get => GetAttribute < PotentialTransformerKind ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? nominalVoltage
  {
    get => GetAttribute < float ? > (nameof (nominalVoltage));
    set => SetAttribute (nameof (nominalVoltage), value);
  }

  /// <summary>
  ///
  /// </summary>
  public PotentialTransformerWinding[] Windings => GetAssoc1ToM<
      PotentialTransformerWinding> (nameof (Windings));
  public void
  AddToWindings (PotentialTransformerWinding assocObject) => AddAssoc1ToM (
      nameof (Windings), assocObject);
  public void RemoveFromWindings (
      PotentialTransformerWinding
          assocObject) => RemoveAssoc1ToM (nameof (Windings), assocObject);
  public void RemoveAllFromWindings () => RemoveAllAssocs1ToM (
      nameof (Windings));
}
/// <summary>
/// Properties of potential transformer asset.
/// </summary>
[CimClass (ClassUri)]
public partial class PotentialTransformerInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PotentialTransformerInfo";

  /// <summary>
  /// Ratio for the primary winding tap changer.
  /// </summary>
  public Ratio ? primaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (primaryRatio));
    set => SetAttribute (nameof (primaryRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? ptClass
  {
    get => GetAttribute < string ? > (nameof (ptClass));
    set => SetAttribute (nameof (ptClass), value);
  }
  /// <summary>
  /// Rated voltage on the primary side.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
  /// <summary>
  /// Ratio for the secondary winding tap changer.
  /// </summary>
  public Ratio ? secondaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (secondaryRatio));
    set => SetAttribute (nameof (secondaryRatio), value);
  }
  /// <summary>
  /// Ratio for the tertiary winding tap changer.
  /// </summary>
  public Ratio ? tertiaryRatio
  {
    get => GetAttribute < Ratio ? > (nameof (tertiaryRatio));
    set => SetAttribute (nameof (tertiaryRatio), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class PotentialTransformerWinding
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SensorWinding (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#PotentialTransformerWinding";

  /// <summary>
  ///
  /// </summary>
  public float ? nominalRatio
  {
    get => GetAttribute < float ? > (nameof (nominalRatio));
    set => SetAttribute (nameof (nominalRatio), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? nominalVoltage
  {
    get => GetAttribute < float ? > (nameof (nominalVoltage));
    set => SetAttribute (nameof (nominalVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? shortCircuitVoltage
  {
    get => GetAttribute < float ? > (nameof (shortCircuitVoltage));
    set => SetAttribute (nameof (shortCircuitVoltage), value);
  }

  /// <summary>
  ///
  /// </summary>
  public PotentialTransformer ? Transformer
  {
    get => GetAssoc1To1<PotentialTransformer> (nameof (Transformer));
    set => SetAssoc1To1 (nameof (Transformer), value);
  }
}
/// <summary>
/// A connection to the AC network for energy production or consumption that
/// uses power electronics rather than rotating machines.
/// </summary>
[CimClass (ClassUri)]
public partial class PowerElectronicsConnection
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RegulatingCondEq (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerElectronicsConnection";

  /// <summary>
  /// Maximum reactive power limit. This is the maximum (nameplate) limit for
  /// the unit.
  /// </summary>
  public float ? maxQ
  {
    get => GetAttribute < float ? > (nameof (maxQ));
    set => SetAttribute (nameof (maxQ), value);
  }
  /// <summary>
  /// Minimum reactive power limit for the unit. This is the minimum (nameplate)
  /// limit for the unit.
  /// </summary>
  public float ? minQ
  {
    get => GetAttribute < float ? > (nameof (minQ));
    set => SetAttribute (nameof (minQ), value);
  }
  /// <summary>
  /// Nameplate apparent power rating for the unit.The attribute shall have a
  /// positive value.
  /// </summary>
  public float ? ratedS
  {
    get => GetAttribute < float ? > (nameof (ratedS));
    set => SetAttribute (nameof (ratedS), value);
  }
  /// <summary>
  /// Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
  /// for short circuit data exchange according to IEC 60909.The attribute shall
  /// be a positive value.
  /// </summary>
  public float ? ratedU
  {
    get => GetAttribute < float ? > (nameof (ratedU));
    set => SetAttribute (nameof (ratedU), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedPowerFactor
  {
    get => GetAttribute < float ? > (nameof (ratedPowerFactor));
    set => SetAttribute (nameof (ratedPowerFactor), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }

  /// <summary>
  ///
  /// </summary>
  public PowerElectronicsReactiveCapabilityCurve
      ? PowerElectronicsReactiveCapabilityCurve
  {
    get => GetAssoc1To1<PowerElectronicsReactiveCapabilityCurve> (
        nameof (PowerElectronicsReactiveCapabilityCurve));
    set => SetAssoc1To1 (nameof (PowerElectronicsReactiveCapabilityCurve),
                         value);
  }

  /// <summary>
  /// An AC network connection may have several power electronics units
  /// connecting through it.
  /// </summary>
  public PowerElectronicsUnit[] PowerElectronicsUnit => GetAssoc1ToM<
      PowerElectronicsUnit> (nameof (PowerElectronicsUnit));
  public void
  AddToPowerElectronicsUnit (PowerElectronicsUnit assocObject) => AddAssoc1ToM (
      nameof (PowerElectronicsUnit), assocObject);
  public void RemoveFromPowerElectronicsUnit (
      PowerElectronicsUnit
          assocObject) => RemoveAssoc1ToM (nameof (PowerElectronicsUnit),
                                           assocObject);
  public void RemoveAllFromPowerElectronicsUnit () => RemoveAllAssocs1ToM (
      nameof (PowerElectronicsUnit));
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class PowerElectronicsReactiveCapabilityCurve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Curve (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/"
        + "schema-cim01#PowerElectronicsReactiveCapabilityCurve";

  /// <summary>
  ///
  /// </summary>
  public PowerElectronicsConnection
  [] PowerElectronicsConnection => GetAssoc1ToM<PowerElectronicsConnection> (
      nameof (PowerElectronicsConnection));
  public void AddToPowerElectronicsConnection (
      PowerElectronicsConnection
          assocObject) => AddAssoc1ToM (nameof (PowerElectronicsConnection),
                                        assocObject);
  public void RemoveFromPowerElectronicsConnection (
      PowerElectronicsConnection
          assocObject) => RemoveAssoc1ToM (nameof (PowerElectronicsConnection),
                                           assocObject);
  public void
  RemoveAllFromPowerElectronicsConnection () => RemoveAllAssocs1ToM (
      nameof (PowerElectronicsConnection));
}
/// <summary>
/// A generating unit or battery or aggregation that connects to the AC network
/// using power electronics rather than rotating machines.
/// </summary>
[CimClass (ClassUri)]
public partial class PowerElectronicsUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerElectronicsUnit";

  /// <summary>
  /// Maximum active power limit. This is the maximum (nameplate) limit for the
  /// unit.
  /// </summary>
  public float ? maxP
  {
    get => GetAttribute < float ? > (nameof (maxP));
    set => SetAttribute (nameof (maxP), value);
  }
  /// <summary>
  /// Minimum active power limit. This is the minimum (nameplate) limit for the
  /// unit.
  /// </summary>
  public float ? minP
  {
    get => GetAttribute < float ? > (nameof (minP));
    set => SetAttribute (nameof (minP), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? deadband
  {
    get => GetAttribute < float ? > (nameof (deadband));
    set => SetAttribute (nameof (deadband), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? governorSCD
  {
    get => GetAttribute < float ? > (nameof (governorSCD));
    set => SetAttribute (nameof (governorSCD), value);
  }

  /// <summary>
  /// A power electronics unit has a connection to the AC network.
  /// </summary>
  public PowerElectronicsConnection ? PowerElectronicsConnection
  {
    get => GetAssoc1To1<PowerElectronicsConnection> (
        nameof (PowerElectronicsConnection));
    set => SetAssoc1To1 (nameof (PowerElectronicsConnection), value);
  }
}
/// <summary>
/// A wind generating unit that connects to the AC network with power
/// electronics rather than rotating machines or an aggregation of such units.
/// </summary>
[CimClass (ClassUri)]
public partial class PowerElectronicsWindUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerElectronicsUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerElectronicsWindUnit";
}
/// <summary>
/// A power system resource (PSR) can be an item of equipment such as a switch,
/// an equipment container containing many individual items of equipment such as
/// a substation, or an organisational entity such as sub-control area. Power
/// system resources can have measurements associated.
/// </summary>
[CimClass (ClassUri)]
public partial class PowerSystemResource
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerSystemResource";

  /// <summary>
  /// Datasheet information for this power system resource.
  /// </summary>
  public AssetInfo ? AssetDatasheet
  {
    get => GetAssoc1To1<AssetInfo> (nameof (AssetDatasheet));
    set => SetAssoc1To1 (nameof (AssetDatasheet), value);
  }
  /// <summary>
  /// Location of this power system resource.
  /// </summary>
  public Location ? Location
  {
    get => GetAssoc1To1<Location> (nameof (Location));
    set => SetAssoc1To1 (nameof (Location), value);
  }
  /// <summary>
  /// Custom classification for this power system resource.
  /// </summary>
  public PSRType ? PSRType
  {
    get => GetAssoc1To1<PSRType> (nameof (PSRType));
    set => SetAssoc1To1 (nameof (PSRType), value);
  }

  /// <summary>
  /// All assets represented by this power system resource. For example,
  /// multiple conductor assets are electrically modelled as a single AC line
  /// segment.
  /// </summary>
  public Asset[] Assets => GetAssoc1ToM<Asset> (nameof (Assets));
  public void AddToAssets (Asset assocObject) => AddAssoc1ToM (nameof (Assets),
                                                               assocObject);
  public void RemoveFromAssets (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Assets), assocObject);
  public void RemoveAllFromAssets () => RemoveAllAssocs1ToM (nameof (Assets));
  /// <summary>
  /// The measurements associated with this power system resource.
  /// </summary>
  public Measurement[] Measurements => GetAssoc1ToM<Measurement> (
      nameof (Measurements));
  public void AddToMeasurements (Measurement assocObject) => AddAssoc1ToM (
      nameof (Measurements), assocObject);
  public void RemoveFromMeasurements (
      Measurement assocObject) => RemoveAssoc1ToM (nameof (Measurements),
                                                   assocObject);
  public void RemoveAllFromMeasurements () => RemoveAllAssocs1ToM (
      nameof (Measurements));
}
/// <summary>
/// An electrical device consisting of  two or more coupled windings, with or
/// without a magnetic core, for introducing mutual coupling between electric
/// circuits. Transformers can be used to control voltage and phase shift
/// (active power flow).A power transformer may be composed of separate
/// transformer tanks that need not be identical.A power transformer can be
/// modelled with or without tanks and is intended for use in both balanced and
/// unbalanced representations.   A power transformer typically has two
/// terminals, but may have one (grounding), three or more terminals.The
/// inherited association ConductingEquipment.BaseVoltage should not be used.
/// The association from TransformerEnd to BaseVoltage should be used instead.
/// </summary>
[CimClass (ClassUri)]
public partial class PowerTransformer
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerTransformer";

  /// <summary>
  /// Vector group of the transformer for protective relaying, e.g., Dyn1. For
  /// unbalanced transformers, this may not be simply determined from the
  /// constituent winding connections and phase angle displacements.The
  /// vectorGroup string consists of the following components in the order
  /// listed: high voltage winding connection, mid voltage winding connection
  /// (for three winding transformers), phase displacement clock number from 0
  /// to 11,  low voltage winding connection phase displacement clock number
  /// from 0 to 11.   The winding connections are D (delta), Y (wye), YN (wye
  /// with neutral), Z (zigzag), ZN (zigzag with neutral), A (auto transformer).
  /// Upper case means the high voltage, lower case mid or low. The high voltage
  /// winding always has clock position 0 and is not included in the vector
  /// group string.  Some examples: YNy0 (two winding wye to wye with no phase
  /// displacement), YNd11 (two winding wye to delta with 330 degrees phase
  /// displacement), YNyn0d5 (three winding transformer wye with neutral high
  /// voltage, wye with neutral mid voltage and no phase displacement, delta low
  /// voltage with 150 degrees displacement).Phase displacement is defined as
  /// the angular difference between the phasors representing the voltages
  /// between the neutral point (real or imaginary) and the corresponding
  /// terminals of two windings, a positive sequence voltage system being
  /// applied to the high-voltage terminals, following each other in
  /// alphabetical sequence if they are lettered, or in numerical sequence if
  /// they are numbered: the phasors are assumed to rotate in a
  /// counter-clockwise sense.
  /// </summary>
  public string ? vectorGroup
  {
    get => GetAttribute < string ? > (nameof (vectorGroup));
    set => SetAttribute (nameof (vectorGroup), value);
  }

  /// <summary>
  /// The ends of this power transformer.
  /// </summary>
  public PowerTransformerEnd[] PowerTransformerEnd => GetAssoc1ToM<
      PowerTransformerEnd> (nameof (PowerTransformerEnd));
  public void
  AddToPowerTransformerEnd (PowerTransformerEnd assocObject) => AddAssoc1ToM (
      nameof (PowerTransformerEnd), assocObject);
  public void RemoveFromPowerTransformerEnd (
      PowerTransformerEnd
          assocObject) => RemoveAssoc1ToM (nameof (PowerTransformerEnd),
                                           assocObject);
  public void RemoveAllFromPowerTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (PowerTransformerEnd));
  /// <summary>
  /// All transformers that belong to this bank.
  /// </summary>
  public TransformerTank[] TransformerTanks => GetAssoc1ToM<TransformerTank> (
      nameof (TransformerTanks));
  public void AddToTransformerTanks (
      TransformerTank assocObject) => AddAssoc1ToM (nameof (TransformerTanks),
                                                    assocObject);
  public void
  RemoveFromTransformerTanks (TransformerTank assocObject) => RemoveAssoc1ToM (
      nameof (TransformerTanks), assocObject);
  public void RemoveAllFromTransformerTanks () => RemoveAllAssocs1ToM (
      nameof (TransformerTanks));
  /// <summary>
  ///
  /// </summary>
  public StabilizingWinding[] StabilizingWindings => GetAssoc1ToM<
      StabilizingWinding> (nameof (StabilizingWindings));
  public void
  AddToStabilizingWindings (StabilizingWinding assocObject) => AddAssoc1ToM (
      nameof (StabilizingWindings), assocObject);
  public void RemoveFromStabilizingWindings (
      StabilizingWinding
          assocObject) => RemoveAssoc1ToM (nameof (StabilizingWindings),
                                           assocObject);
  public void RemoveAllFromStabilizingWindings () => RemoveAllAssocs1ToM (
      nameof (StabilizingWindings));
}
/// <summary>
/// A PowerTransformerEnd is associated with each Terminal of a
/// PowerTransformer.The impedance values r, r0, x, and x0 of a
/// PowerTransformerEnd represents a star equivalent as follows.1) for a two
/// Terminal PowerTransformer the high voltage (TransformerEnd.endNumber=1)
/// PowerTransformerEnd has non zero values on r, r0, x, and x0 while the low
/// voltage (TransformerEnd.endNumber=2) PowerTransformerEnd has zero values for
/// r, r0, x, and x0.  Parameters are always provided, even if the
/// PowerTransformerEnds have the same rated voltage.  In this case, the
/// parameters are provided at the PowerTransformerEnd which has
/// TransformerEnd.endNumber equal to 1.2) for a three Terminal PowerTransformer
/// the three PowerTransformerEnds represent a star equivalent with each leg in
/// the star represented by r, r0, x, and x0 values.3) For a three Terminal
/// transformer each PowerTransformerEnd shall have g, g0, b and b0 values
/// corresponding to the no load losses distributed on the three
/// PowerTransformerEnds. The total no load loss shunt impedances may also be
/// placed at one of the PowerTransformerEnds, preferably the end numbered 1,
/// having the shunt values on end 1.  This is the preferred way.4) for a
/// PowerTransformer with more than three Terminals the PowerTransformerEnd
/// impedance values cannot be used. Instead use the TransformerMeshImpedance or
/// split the transformer into multiple PowerTransformers.Each
/// PowerTransformerEnd must be contained by a PowerTransformer. Because a
/// PowerTransformerEnd (or any other object) can not be contained by more than
/// one parent, a PowerTransformerEnd can not have an association to an
/// EquipmentContainer (Substation, VoltageLevel, etc).
/// </summary>
[CimClass (ClassUri)]
public partial class PowerTransformerEnd
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TransformerEnd (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PowerTransformerEnd";

  /// <summary>
  /// Magnetizing branch susceptance (B mag).  The value can be positive or
  /// negative.
  /// </summary>
  public float ? b
  {
    get => GetAttribute < float ? > (nameof (b));
    set => SetAttribute (nameof (b), value);
  }
  /// <summary>
  /// Zero sequence magnetizing branch susceptance.
  /// </summary>
  public float ? b0
  {
    get => GetAttribute < float ? > (nameof (b0));
    set => SetAttribute (nameof (b0), value);
  }
  /// <summary>
  /// Kind of connection.
  /// </summary>
  public WindingConnection ? connectionKind
  {
    get => GetAttribute < WindingConnection ? > (nameof (connectionKind));
    set => SetAttribute (nameof (connectionKind), value);
  }
  /// <summary>
  /// Magnetizing branch conductance.
  /// </summary>
  public float ? g
  {
    get => GetAttribute < float ? > (nameof (g));
    set => SetAttribute (nameof (g), value);
  }
  /// <summary>
  /// Zero sequence magnetizing branch conductance (star-model).
  /// </summary>
  public float ? g0
  {
    get => GetAttribute < float ? > (nameof (g0));
    set => SetAttribute (nameof (g0), value);
  }
  /// <summary>
  /// Terminal voltage phase angle displacement where 360 degrees are
  /// represented with clock hours. The valid values are 0 to 11. For example,
  /// for the secondary side end of a transformer with vector group code of
  /// 'Dyn11', specify the connection kind as wye with neutral and specify the
  /// phase angle of the clock as 11.  The clock value of the transformer end
  /// number specified as 1, is assumed to be zero.  Note the transformer end
  /// number is not assumed to be the same as the terminal sequence number.
  /// </summary>
  public int ? phaseAngleClock
  {
    get => GetAttribute < int ? > (nameof (phaseAngleClock));
    set => SetAttribute (nameof (phaseAngleClock), value);
  }
  /// <summary>
  /// Resistance (star-model) of the transformer end.The attribute shall be
  /// equal to or greater than zero for non-equivalent transformers.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence series resistance (star-model) of the transformer end.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Normal apparent power rating.The attribute shall be a positive value. For
  /// a two-winding transformer the values for the high and low voltage sides
  /// shall be identical.
  /// </summary>
  public float ? ratedS
  {
    get => GetAttribute < float ? > (nameof (ratedS));
    set => SetAttribute (nameof (ratedS), value);
  }
  /// <summary>
  /// Rated voltage: phase-phase for three-phase windings, and either
  /// phase-phase or phase-neutral for single-phase windings.A high voltage
  /// side, as given by TransformerEnd.endNumber, shall have a ratedU that is
  /// greater than or equal to ratedU for the lower voltage sides.The attribute
  /// shall be a positive value.
  /// </summary>
  public float ? ratedU
  {
    get => GetAttribute < float ? > (nameof (ratedU));
    set => SetAttribute (nameof (ratedU), value);
  }
  /// <summary>
  /// Positive sequence series reactance (star-model) of the transformer end.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero sequence series reactance of the transformer end.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  /// The power transformer of this power transformer end.
  /// </summary>
  public PowerTransformer ? PowerTransformer
  {
    get => GetAssoc1To1<PowerTransformer> (nameof (PowerTransformer));
    set => SetAssoc1To1 (nameof (PowerTransformer), value);
  }
  /// <summary>
  ///
  /// </summary>
  public TransformerEndInfo ? TransformerEndInfo
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (TransformerEndInfo));
    set => SetAssoc1To1 (nameof (TransformerEndInfo), value);
  }
}
/// <summary>
/// Grouping of pricing components and prices used in the creation of customer
/// charges and the eligibility criteria under which these terms may be offered
/// to a customer. The reasons for grouping include state, customer
/// classification, site characteristics, classification (i.e. fee price
/// structure, deposit price structure, electric service price structure, etc.)
/// and accounting requirements.
/// </summary>
[CimClass (ClassUri)]
public partial class PricingStructure
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Document (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#PricingStructure";

  /// <summary>
  /// Unique user-allocated key for this pricing structure, used by company
  /// representatives to identify the correct price structure for allocating to
  /// a customer. For rate schedules it is often prefixed by a state code.
  /// </summary>
  public string ? code
  {
    get => GetAttribute < string ? > (nameof (code));
    set => SetAttribute (nameof (code), value);
  }
}
/// <summary>
/// The machine used to develop mechanical energy used to drive a generator.
/// </summary>
[CimClass (ClassUri)]
public partial class PrimeMover
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#PrimeMover";

  /// <summary>
  ///
  /// </summary>
  public float ? ratedPower
  {
    get => GetAttribute < float ? > (nameof (ratedPower));
    set => SetAttribute (nameof (ratedPower), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotationSpeed
  {
    get => GetAttribute < float ? > (nameof (rotationSpeed));
    set => SetAttribute (nameof (rotationSpeed), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rotorGD2
  {
    get => GetAttribute < float ? > (nameof (rotorGD2));
    set => SetAttribute (nameof (rotorGD2), value);
  }

  /// <summary>
  ///
  /// </summary>
  public AsynchronousMachine ? AsynchronousMachine
  {
    get => GetAssoc1To1<AsynchronousMachine> (nameof (AsynchronousMachine));
    set => SetAssoc1To1 (nameof (AsynchronousMachine), value);
  }

  /// <summary>
  /// Synchronous machines this Prime mover drives.
  /// </summary>
  public SynchronousMachine[] SynchronousMachines => GetAssoc1ToM<
      SynchronousMachine> (nameof (SynchronousMachines));
  public void
  AddToSynchronousMachines (SynchronousMachine assocObject) => AddAssoc1ToM (
      nameof (SynchronousMachines), assocObject);
  public void RemoveFromSynchronousMachines (
      SynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (SynchronousMachines),
                                           assocObject);
  public void RemoveAllFromSynchronousMachines () => RemoveAllAssocs1ToM (
      nameof (SynchronousMachines));
}
/// <summary>
/// Asset model by a specific manufacturer.
/// </summary>
[CimClass (ClassUri)]
public partial class ProductAssetModel
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ProductAssetModel";

  /// <summary>
  /// Kind of corporate standard for this asset model.
  /// </summary>
  public CorporateStandardKind ? corporateStandardKind
  {
    get => GetAttribute < CorporateStandardKind
        ? > (nameof (corporateStandardKind));
    set => SetAttribute (nameof (corporateStandardKind), value);
  }
  /// <summary>
  /// Manufacturer's model number.
  /// </summary>
  public string ? modelNumber
  {
    get => GetAttribute < string ? > (nameof (modelNumber));
    set => SetAttribute (nameof (modelNumber), value);
  }
  /// <summary>
  /// Version number for product model, which indicates vintage of the product.
  /// </summary>
  public string ? modelVersion
  {
    get => GetAttribute < string ? > (nameof (modelVersion));
    set => SetAttribute (nameof (modelVersion), value);
  }
  /// <summary>
  /// Intended usage for this asset model.
  /// </summary>
  public AssetModelUsageKind ? usageKind
  {
    get => GetAttribute < AssetModelUsageKind ? > (nameof (usageKind));
    set => SetAttribute (nameof (usageKind), value);
  }

  /// <summary>
  /// Asset information (nameplate) for this product asset model.
  /// </summary>
  public AssetInfo ? AssetInfo
  {
    get => GetAssoc1To1<AssetInfo> (nameof (AssetInfo));
    set => SetAssoc1To1 (nameof (AssetInfo), value);
  }
  /// <summary>
  /// Manufacturer of this asset model.
  /// </summary>
  public Manufacturer ? Manufacturer
  {
    get => GetAssoc1To1<Manufacturer> (nameof (Manufacturer));
    set => SetAssoc1To1 (nameof (Manufacturer), value);
  }

  /// <summary>
  /// An asset of this model.
  /// </summary>
  public Asset[] Asset => GetAssoc1ToM<Asset> (nameof (Asset));
  public void AddToAsset (Asset assocObject) => AddAssoc1ToM (nameof (Asset),
                                                              assocObject);
  public void RemoveFromAsset (Asset assocObject) => RemoveAssoc1ToM (
      nameof (Asset), assocObject);
  public void RemoveAllFromAsset () => RemoveAllAssocs1ToM (nameof (Asset));
}
/// <summary>
/// A ProtectedSwitch is a switching device that can be operated by
/// ProtectionEquipment.
/// </summary>
[CimClass (ClassUri)]
public partial class ProtectedSwitch
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Switch (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ProtectedSwitch";

  /// <summary>
  /// The maximum fault current a breaking device can break safely under
  /// prescribed conditions of use.
  /// </summary>
  public float ? breakingCapacity
  {
    get => GetAttribute < float ? > (nameof (breakingCapacity));
    set => SetAttribute (nameof (breakingCapacity), value);
  }
}
/// <summary>
/// Fraction specified explicitly with a numerator and denominator, which can be
/// used to calculate the quotient.
/// </summary>
[CimClass (ClassUri)]
public partial class Ratio
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Ratio";

  /// <summary>
  /// The part of a fraction that is below the line and that functions as the
  /// divisor of the numerator.
  /// </summary>
  public float ? denominator
  {
    get => GetAttribute < float ? > (nameof (denominator));
    set => SetAttribute (nameof (denominator), value);
  }
  /// <summary>
  /// The part of a fraction that is above the line and signifies the number to
  /// be divided by the denominator.
  /// </summary>
  public float ? numerator
  {
    get => GetAttribute < float ? > (nameof (numerator));
    set => SetAttribute (nameof (numerator), value);
  }
}
/// <summary>
/// A tap changer that changes the voltage ratio impacting the voltage magnitude
/// but not the phase angle across the transformer.Angle sign convention
/// (general): Positive value indicates a positive phase shift from the winding
/// where the tap is located to the other winding (for a two-winding
/// transformer).
/// </summary>
[CimClass (ClassUri)]
public partial class RatioTapChanger
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TapChanger (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RatioTapChanger";

  /// <summary>
  /// Tap step increment, in per cent of rated voltage of the power transformer
  /// end, per step position.When the increment is negative, the voltage
  /// decreases when the tap step increases.
  /// </summary>
  public float ? stepVoltageIncrement
  {
    get => GetAttribute < float ? > (nameof (stepVoltageIncrement));
    set => SetAttribute (nameof (stepVoltageIncrement), value);
  }

  /// <summary>
  /// The tap ratio table for this ratio  tap changer.
  /// </summary>
  public RatioTapChangerTable ? RatioTapChangerTable
  {
    get => GetAssoc1To1<RatioTapChangerTable> (nameof (RatioTapChangerTable));
    set => SetAssoc1To1 (nameof (RatioTapChangerTable), value);
  }
  /// <summary>
  /// Transformer end to which this ratio tap changer belongs.
  /// </summary>
  public TransformerEnd ? TransformerEnd
  {
    get => GetAssoc1To1<TransformerEnd> (nameof (TransformerEnd));
    set => SetAssoc1To1 (nameof (TransformerEnd), value);
  }
  /// <summary>
  ///
  /// </summary>
  public TapChangerDependentLimitTable ? TapChangerDependentLimitTable
  {
    get => GetAssoc1To1<TapChangerDependentLimitTable> (
        nameof (TapChangerDependentLimitTable));
    set => SetAssoc1To1 (nameof (TapChangerDependentLimitTable), value);
  }
}
/// <summary>
/// Describes a curve for how the voltage magnitude and impedance varies with
/// the tap step.
/// </summary>
[CimClass (ClassUri)]
public partial class RatioTapChangerTable
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RatioTapChangerTable";

  /// <summary>
  /// The ratio tap changer of this tap ratio table.
  /// </summary>
  public RatioTapChanger[] RatioTapChanger => GetAssoc1ToM<RatioTapChanger> (
      nameof (RatioTapChanger));
  public void AddToRatioTapChanger (
      RatioTapChanger assocObject) => AddAssoc1ToM (nameof (RatioTapChanger),
                                                    assocObject);
  public void RemoveFromRatioTapChanger (
      RatioTapChanger assocObject) => RemoveAssoc1ToM (nameof (RatioTapChanger),
                                                       assocObject);
  public void RemoveAllFromRatioTapChanger () => RemoveAllAssocs1ToM (
      nameof (RatioTapChanger));
  /// <summary>
  /// Points of this table.
  /// </summary>
  public RatioTapChangerTablePoint[] RatioTapChangerTablePoint => GetAssoc1ToM<
      RatioTapChangerTablePoint> (nameof (RatioTapChangerTablePoint));
  public void AddToRatioTapChangerTablePoint (
      RatioTapChangerTablePoint
          assocObject) => AddAssoc1ToM (nameof (RatioTapChangerTablePoint),
                                        assocObject);
  public void RemoveFromRatioTapChangerTablePoint (
      RatioTapChangerTablePoint
          assocObject) => RemoveAssoc1ToM (nameof (RatioTapChangerTablePoint),
                                           assocObject);
  public void RemoveAllFromRatioTapChangerTablePoint () => RemoveAllAssocs1ToM (
      nameof (RatioTapChangerTablePoint));
}
/// <summary>
/// Describes each tap step in the ratio tap changer tabular curve.
/// </summary>
[CimClass (ClassUri)]
public partial class RatioTapChangerTablePoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TapChangerTablePoint (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RatioTapChangerTablePoint";

  /// <summary>
  /// Table of this point.
  /// </summary>
  public RatioTapChangerTable ? RatioTapChangerTable
  {
    get => GetAssoc1To1<RatioTapChangerTable> (nameof (RatioTapChangerTable));
    set => SetAssoc1To1 (nameof (RatioTapChangerTable), value);
  }
}
/// <summary>
/// Rational number = 'numerator' / 'denominator'.
/// </summary>
[CimClass (ClassUri)]
public partial class RationalNumber
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#RationalNumber";

  /// <summary>
  /// Denominator. Value 1 indicates the number is a simple integer.
  /// </summary>
  public int ? denominator
  {
    get => GetAttribute < int ? > (nameof (denominator));
    set => SetAttribute (nameof (denominator), value);
  }
  /// <summary>
  /// Numerator.
  /// </summary>
  public int ? numerator
  {
    get => GetAttribute < int ? > (nameof (numerator));
    set => SetAttribute (nameof (numerator), value);
  }
}
/// <summary>
/// Reactive power rating envelope versus the synchronous machine's active
/// power, in both the generating and motoring modes. For each active power
/// value there is a corresponding high and low reactive power limit  value.
/// Typically there will be a separate curve for each coolant condition, such as
/// hydrogen pressure.  The Y1 axis values represent reactive minimum and the Y2
/// axis values represent reactive maximum.
/// </summary>
[CimClass (ClassUri)]
public partial class ReactiveCapabilityCurve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Curve (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ReactiveCapabilityCurve";

  /// <summary>
  /// Synchronous machines using this curve as default.
  /// </summary>
  public SynchronousMachine
  [] InitiallyUsedBySynchronousMachines => GetAssoc1ToM<SynchronousMachine> (
      nameof (InitiallyUsedBySynchronousMachines));
  public void AddToInitiallyUsedBySynchronousMachines (
      SynchronousMachine
          assocObject) => AddAssoc1ToM (nameof (InitiallyUsedBySynchronousMachines),
                                        assocObject);
  public void RemoveFromInitiallyUsedBySynchronousMachines (
      SynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (InitiallyUsedBySynchronousMachines),
                                           assocObject);
  public void
  RemoveAllFromInitiallyUsedBySynchronousMachines () => RemoveAllAssocs1ToM (
      nameof (InitiallyUsedBySynchronousMachines));
  /// <summary>
  /// Synchronous machines using this curve.
  /// </summary>
  public SynchronousMachine[] SynchronousMachines => GetAssoc1ToM<
      SynchronousMachine> (nameof (SynchronousMachines));
  public void
  AddToSynchronousMachines (SynchronousMachine assocObject) => AddAssoc1ToM (
      nameof (SynchronousMachines), assocObject);
  public void RemoveFromSynchronousMachines (
      SynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (SynchronousMachines),
                                           assocObject);
  public void RemoveAllFromSynchronousMachines () => RemoveAllAssocs1ToM (
      nameof (SynchronousMachines));
}
/// <summary>
/// Specific value measured by a meter or other asset, or calculated by a
/// system. Each Reading is associated with a specific ReadingType.
/// </summary>
[CimClass (ClassUri)]
public partial class Reading
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : BaseReading (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Reading";

  /// <summary>
  /// Reason for this reading being taken.
  /// </summary>
  public ReadingReasonKind ? reason
  {
    get => GetAttribute < ReadingReasonKind ? > (nameof (reason));
    set => SetAttribute (nameof (reason), value);
  }

  /// <summary>
  /// Type information for this reading value.
  /// </summary>
  public ReadingType ? ReadingType
  {
    get => GetAssoc1To1<ReadingType> (nameof (ReadingType));
    set => SetAssoc1To1 (nameof (ReadingType), value);
  }
}
/// <summary>
/// Interharmonics are represented as a rational number 'numerator' /
/// 'denominator', and harmonics are represented using the same mechanism and
/// identified by 'denominator'=1.
/// </summary>
[CimClass (ClassUri)]
public partial class ReadingInterharmonic
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ReadingInterharmonic";

  /// <summary>
  /// Interharmonic denominator. Value 0 means not applicable. Value 2 is used
  /// in combination with 'numerator'=1 to represent interharmonic 1/2. Finally,
  /// value 1 indicates the harmonic of the order specified with 'numerator'.
  /// </summary>
  public int ? denominator
  {
    get => GetAttribute < int ? > (nameof (denominator));
    set => SetAttribute (nameof (denominator), value);
  }
  /// <summary>
  /// Interharmonic numerator. Value 0 means not applicable. Value 1 is used in
  /// combination with 'denominator'=2 to represent interharmonic 1/2, and with
  /// 'denominator'=1 it represents fundamental frequency. Finally, values
  /// greater than 1 indicate the harmonic of that order (e.g., 'numerator'=5 is
  /// the fifth harmonic).
  /// </summary>
  public int ? numerator
  {
    get => GetAttribute < int ? > (nameof (numerator));
    set => SetAttribute (nameof (numerator), value);
  }
}
/// <summary>
/// Quality of a specific reading value or interval reading value. Note that
/// more than one quality may be applicable to a given reading. Typically not
/// used unless problems or unusual conditions occur (i.e., quality for each
/// reading is assumed to be good unless stated otherwise in associated reading
/// quality type). It can also be used with the corresponding reading quality
/// type to indicate that the validation has been performed and succeeded.
/// </summary>
[CimClass (ClassUri)]
public partial class ReadingQuality
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ReadingQuality";

  /// <summary>
  /// Elaboration on the quality code.
  /// </summary>
  public string ? comment
  {
    get => GetAttribute < string ? > (nameof (comment));
    set => SetAttribute (nameof (comment), value);
  }
  /// <summary>
  /// System acting as the source of the quality code.
  /// </summary>
  public string ? source
  {
    get => GetAttribute < string ? > (nameof (source));
    set => SetAttribute (nameof (source), value);
  }
  /// <summary>
  /// Date and time at which the quality code was assigned or ascertained.
  /// </summary>
  public DateTime ? timeStamp
  {
    get => GetAttribute < DateTime ? > (nameof (timeStamp));
    set => SetAttribute (nameof (timeStamp), value);
  }

  /// <summary>
  /// Type of this reading quality.
  /// </summary>
  public ReadingQualityType ? ReadingQualityType
  {
    get => GetAssoc1To1<ReadingQualityType> (nameof (ReadingQualityType));
    set => SetAssoc1To1 (nameof (ReadingQualityType), value);
  }
}
/// <summary>
/// Detailed description for a quality of a reading value, produced by an end
/// device or a system. Values in attributes allow for creation of the
/// recommended codes to be used for identifying reading value quality codes as
/// follows: <systemId>.<category>.<subCategory>.
/// </summary>
[CimClass (ClassUri)]
public partial class ReadingQualityType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ReadingQualityType";

  /// <summary>
  /// High-level nature of the reading value quality.
  /// </summary>
  public string ? category
  {
    get => GetAttribute < string ? > (nameof (category));
    set => SetAttribute (nameof (category), value);
  }
  /// <summary>
  /// More specific nature of the reading value quality, as a further
  /// sub-categorisation of 'category'.
  /// </summary>
  public string ? subCategory
  {
    get => GetAttribute < string ? > (nameof (subCategory));
    set => SetAttribute (nameof (subCategory), value);
  }
  /// <summary>
  /// Identification of the system which has declared the issue with the data or
  /// provided commentary on the data.
  /// </summary>
  public string ? systemId
  {
    get => GetAttribute < string ? > (nameof (systemId));
    set => SetAttribute (nameof (systemId), value);
  }
}
/// <summary>
/// Detailed description for a type of a reading value. Values in attributes
/// allow for the creation of recommended codes to be used for identifying
/// reading value types as follows:
/// <macroPeriod>.<aggregate>.<measuringPeriod>.<accumulation>.<flowDirection>.<commodity>.<measurementKind>.<interharmonic.numerator>.<interharmonic.denominator>.<argument.numerator>.<argument.denominator>.<tou>.<cpp>.<consumptionTier>.<phases>.<multiplier>.<unit>.<currency>.
/// </summary>
[CimClass (ClassUri)]
public partial class ReadingType
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#ReadingType";

  /// <summary>
  /// Accumulation behaviour of a reading over time, usually 'measuringPeriod',
  /// to be used with individual endpoints (as opposed to 'macroPeriod' and
  /// 'aggregate' that are used to describe aggregations of data from individual
  /// endpoints).
  /// </summary>
  public AccumulationKind ? accumulation
  {
    get => GetAttribute < AccumulationKind ? > (nameof (accumulation));
    set => SetAttribute (nameof (accumulation), value);
  }
  /// <summary>
  /// Salient attribute of the reading data aggregated from individual
  /// endpoints. This is mainly used to define a mathematical operation carried
  /// out over 'macroPeriod', but may also be used to describe an attribute of
  /// the data when the 'macroPeriod' is not defined.
  /// </summary>
  public AggregateKind ? aggregate
  {
    get => GetAttribute < AggregateKind ? > (nameof (aggregate));
    set => SetAttribute (nameof (aggregate), value);
  }
  /// <summary>
  /// Argument used to introduce numbers into the unit of measure description
  /// where they are needed (e.g., 4 where the measure needs an argument such as
  /// CEMI(n=4)). Most arguments used in practice however will be integers
  /// (i.e., 'denominator'=1).Value 0 in 'numerator' and 'denominator' means not
  /// applicable.
  /// </summary>
  public RationalNumber ? argument
  {
    get => GetAttribute < RationalNumber ? > (nameof (argument));
    set => SetAttribute (nameof (argument), value);
  }
  /// <summary>
  /// Commodity being measured.
  /// </summary>
  public CommodityKind ? commodity
  {
    get => GetAttribute < CommodityKind ? > (nameof (commodity));
    set => SetAttribute (nameof (commodity), value);
  }
  /// <summary>
  /// In case of common flat-rate pricing for power, in which all purchases are
  /// at a given rate, 'consumptionTier'=0. Otherwise, the value indicates the
  /// consumption tier, which can be used in conjunction with TOU or CPP
  /// pricing.Consumption tier pricing refers to the method of billing in which
  /// a certain "block" of energy is purchased/sold at one price, after which
  /// the next block of energy is purchased at another price, and so on, all
  /// throughout a defined period. At the start of the defined period,
  /// consumption is initially zero, and any usage is measured against the first
  /// consumption tier ('consumptionTier'=1). If this block of energy is
  /// consumed before the end of the period, energy consumption moves to be
  /// reconed against the second consumption tier ('consumptionTier'=2), and so
  /// on. At the end of the defined period, the consumption accumulator is
  /// reset, and usage within the 'consumptionTier'=1 restarts.
  /// </summary>
  public int ? consumptionTier
  {
    get => GetAttribute < int ? > (nameof (consumptionTier));
    set => SetAttribute (nameof (consumptionTier), value);
  }
  /// <summary>
  /// Critical peak period (CPP) bucket the reading value is attributed to.
  /// Value 0 means not applicable. Even though CPP is usually considered a
  /// specialised form of time of use 'tou', this attribute is defined
  /// explicitly for flexibility.
  /// </summary>
  public int ? cpp
  {
    get => GetAttribute < int ? > (nameof (cpp));
    set => SetAttribute (nameof (cpp), value);
  }
  /// <summary>
  /// Metering-specific currency.
  /// </summary>
  public Currency ? currency
  {
    get => GetAttribute < Currency ? > (nameof (currency));
    set => SetAttribute (nameof (currency), value);
  }
  /// <summary>
  /// Flow direction for a reading where the direction of flow of the commodity
  /// is important (for electricity measurements this includes current, energy,
  /// power, and demand).
  /// </summary>
  public FlowDirectionKind ? flowDirection
  {
    get => GetAttribute < FlowDirectionKind ? > (nameof (flowDirection));
    set => SetAttribute (nameof (flowDirection), value);
  }
  /// <summary>
  /// Indication of a "harmonic" or "interharmonic" basis for the measurement.
  /// Value 0 in 'numerator' and 'denominator' means not applicable.
  /// </summary>
  public ReadingInterharmonic ? interharmonic
  {
    get => GetAttribute < ReadingInterharmonic ? > (nameof (interharmonic));
    set => SetAttribute (nameof (interharmonic), value);
  }
  /// <summary>
  /// Time period of interest that reflects how the reading is viewed or
  /// captured over a long period of time.
  /// </summary>
  public MacroPeriodKind ? macroPeriod
  {
    get => GetAttribute < MacroPeriodKind ? > (nameof (macroPeriod));
    set => SetAttribute (nameof (macroPeriod), value);
  }
  /// <summary>
  /// Identifies "what" is being measured, as refinement of 'commodity'. When
  /// combined with 'unit', it provides detail to the unit of measure. For
  /// example, 'energy' with a unit of measure of 'kWh' indicates to the user
  /// that active energy is being measured, while with 'kVAh' or 'kVArh', it
  /// indicates apparent energy and reactive energy, respectively. 'power' can
  /// be combined in a similar way with various power units of measure:
  /// Distortion power ('distortionVoltAmperes') with 'kVA' is different from
  /// 'power' with 'kVA'.
  /// </summary>
  public MeasurementKind ? measurementKind
  {
    get => GetAttribute < MeasurementKind ? > (nameof (measurementKind));
    set => SetAttribute (nameof (measurementKind), value);
  }
  /// <summary>
  /// Time attribute inherent or fundamental to the reading value (as opposed to
  /// 'macroPeriod' that supplies an "adjective" to describe aspects of a time
  /// period with regard to the measurement). It refers to the way the value was
  /// originally measured and not to the frequency at which it is reported or
  /// presented. For example, an hourly interval of consumption data would have
  /// value 'hourly' as an attribute. However in the case of an hourly sampled
  /// voltage value, the meterReadings schema would carry the 'hourly' interval
  /// size information.It is common for meters to report demand in a form that
  /// is measured over the course of a portion of an hour, while enterprise
  /// applications however commonly assume the demand (in kW or kVAr) normalised
  /// to 1 hour. The system that receives readings directly from the meter
  /// therefore shall perform this transformation before publishing readings for
  /// use by the other enterprise systems. The scalar used is chosen based on
  /// the block size (not any sub-interval size).
  /// </summary>
  public MeasuringPeriodKind ? measuringPeriod
  {
    get => GetAttribute < MeasuringPeriodKind ? > (nameof (measuringPeriod));
    set => SetAttribute (nameof (measuringPeriod), value);
  }
  /// <summary>
  /// Metering-specific phase code.
  /// </summary>
  public PhaseCode ? phases
  {
    get => GetAttribute < PhaseCode ? > (nameof (phases));
    set => SetAttribute (nameof (phases), value);
  }
  /// <summary>
  /// Time of use (TOU) bucket the reading value is attributed to. Value 0 means
  /// not applicable.
  /// </summary>
  public int ? tou
  {
    get => GetAttribute < int ? > (nameof (tou));
    set => SetAttribute (nameof (tou), value);
  }
  /// <summary>
  /// Metering-specific unit.
  /// </summary>
  public UnitSymbol ? unit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (unit));
    set => SetAttribute (nameof (unit), value);
  }
}
/// <summary>
/// Pole-mounted fault interrupter with built-in phase and ground relays,
/// current transformer (CT), and supplemental controls.
/// </summary>
[CimClass (ClassUri)]
public partial class Recloser
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ProtectedSwitch (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Recloser";
}
/// <summary>
/// A device that indicates or records units of the commodity or other quantity
/// measured.
/// </summary>
[CimClass (ClassUri)]
public partial class Register
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Register";

  /// <summary>
  /// If true, the data it produces is  calculated or measured by a device other
  /// than a physical end device/meter. Otherwise, any data streams it produces
  /// are measured by the hardware of the end device/meter itself.
  /// </summary>
  public bool ? isVirtual
  {
    get => GetAttribute < bool ? > (nameof (isVirtual));
    set => SetAttribute (nameof (isVirtual), value);
  }
  /// <summary>
  /// Number of digits (dials on a mechanical meter) to the left of the decimal
  /// place; default is normally 5.
  /// </summary>
  public int ? leftDigitCount
  {
    get => GetAttribute < int ? > (nameof (leftDigitCount));
    set => SetAttribute (nameof (leftDigitCount), value);
  }
  /// <summary>
  /// Number of digits (dials on a mechanical meter) to the right of the decimal
  /// place.
  /// </summary>
  public int ? rightDigitCount
  {
    get => GetAttribute < int ? > (nameof (rightDigitCount));
    set => SetAttribute (nameof (rightDigitCount), value);
  }
  /// <summary>
  /// Clock time interval for register to beging/cease accumulating time of
  /// usage (e.g., start at 8:00 am, stop at 5:00 pm).
  /// </summary>
  public TimeInterval ? touTier
  {
    get => GetAttribute < TimeInterval ? > (nameof (touTier));
    set => SetAttribute (nameof (touTier), value);
  }
  /// <summary>
  /// Name used for the time of use tier (also known as bin or bucket).  For
  /// example, "peak", "off-peak", "TOU Category A", etc.
  /// </summary>
  public string ? touTierName
  {
    get => GetAttribute < string ? > (nameof (touTierName));
    set => SetAttribute (nameof (touTierName), value);
  }

  /// <summary>
  /// All channels that collect/report values from this register.
  /// </summary>
  public Channel[] Channels => GetAssoc1ToM<Channel> (nameof (Channels));
  public void AddToChannels (Channel assocObject) => AddAssoc1ToM (
      nameof (Channels), assocObject);
  public void RemoveFromChannels (Channel assocObject) => RemoveAssoc1ToM (
      nameof (Channels), assocObject);
  public void RemoveAllFromChannels () => RemoveAllAssocs1ToM (
      nameof (Channels));
}
/// <summary>
/// A type of conducting equipment that can regulate a quantity (i.e. voltage or
/// flow) at a specific point in the network.
/// </summary>
[CimClass (ClassUri)]
public partial class RegulatingCondEq
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RegulatingCondEq";

  /// <summary>
  /// The regulating control scheme in which this equipment participates.
  /// </summary>
  public RegulatingControl ? RegulatingControl
  {
    get => GetAssoc1To1<RegulatingControl> (nameof (RegulatingControl));
    set => SetAssoc1To1 (nameof (RegulatingControl), value);
  }
}
/// <summary>
/// Specifies a set of equipment that works together to control a power system
/// quantity such as voltage or flow. Remote bus voltage control is possible by
/// specifying the controlled terminal located at some place remote from the
/// controlling equipment.The specified terminal shall be associated with the
/// connectivity node of the controlled point.  The most specific subtype of
/// RegulatingControl shall be used in case such equipment participate in the
/// control, e.g. TapChangerControl for tap changers.For flow control, load sign
/// convention is used, i.e. positive sign means flow out from a TopologicalNode
/// (bus) into the conducting equipment.The attribute minAllowedTargetValue and
/// maxAllowedTargetValue are required in the following cases:- For a power
/// generating module operated in power factor control mode to specify maximum
/// and minimum power factor values;- Whenever it is necessary to have an off
/// center target voltage for the tap changer regulator. For instance, due to
/// long cables to off shore wind farms and the need to have a simpler setup at
/// the off shore transformer platform, the voltage is controlled from the land
/// at the connection point for the off shore wind farm. Since there usually is
/// a voltage rise along the cable, there is typical and overvoltage of up 3-4
/// kV compared to the on shore station. Thus in normal operation the tap
/// changer on the on shore station is operated with a target set point, which
/// is in the lower parts of the dead band.The attributes minAllowedTargetValue
/// and maxAllowedTargetValue are not related to the attribute targetDeadband
/// and thus they are not treated as an alternative of the targetDeadband. They
/// are needed due to limitations in the local substation controller. The
/// attribute targetDeadband is used to prevent the power flow from move the tap
/// position in circles (hunting) that is to be used regardless of the
/// attributes minAllowedTargetValue and maxAllowedTargetValue.
/// </summary>
[CimClass (ClassUri)]
public partial class RegulatingControl
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RegulatingControl";

  /// <summary>
  /// The flag tells if regulation is enabled.
  /// </summary>
  public bool ? enabled
  {
    get => GetAttribute < bool ? > (nameof (enabled));
    set => SetAttribute (nameof (enabled), value);
  }
  /// <summary>
  /// The regulating control mode presently available.  This specification
  /// allows for determining the kind of regulation without need for obtaining
  /// the units from a schedule.
  /// </summary>
  public RegulatingControlModeKind ? mode
  {
    get => GetAttribute < RegulatingControlModeKind ? > (nameof (mode));
    set => SetAttribute (nameof (mode), value);
  }

  /// <summary>
  /// The terminal associated with this regulating control.  The terminal is
  /// associated instead of a node, since the terminal could connect into either
  /// a topological node or a connectivity node.  Sometimes it is useful to
  /// model regulation at a terminal of a bus bar object.
  /// </summary>
  public Terminal ? Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }

  /// <summary>
  /// The equipment that participates in this regulating control scheme.
  /// </summary>
  public RegulatingCondEq[] RegulatingCondEq => GetAssoc1ToM<RegulatingCondEq> (
      nameof (RegulatingCondEq));
  public void AddToRegulatingCondEq (
      RegulatingCondEq assocObject) => AddAssoc1ToM (nameof (RegulatingCondEq),
                                                     assocObject);
  public void
  RemoveFromRegulatingCondEq (RegulatingCondEq assocObject) => RemoveAssoc1ToM (
      nameof (RegulatingCondEq), assocObject);
  public void RemoveAllFromRegulatingCondEq () => RemoveAllAssocs1ToM (
      nameof (RegulatingCondEq));
}
/// <summary>
/// Details of remote connect and disconnect function.
/// </summary>
[CimClass (ClassUri)]
public partial class RemoteConnectDisconnectInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RemoteConnectDisconnectInfo";

  /// <summary>
  /// Setting of the timeout elapsed time.
  /// </summary>
  public float ? armedTimeout
  {
    get => GetAttribute < float ? > (nameof (armedTimeout));
    set => SetAttribute (nameof (armedTimeout), value);
  }
  /// <summary>
  /// Voltage limit on customer side of RCD switch above which the connect
  /// should not be made.
  /// </summary>
  public float ? customerVoltageLimit
  {
    get => GetAttribute < float ? > (nameof (customerVoltageLimit));
    set => SetAttribute (nameof (customerVoltageLimit), value);
  }
  /// <summary>
  /// Limit of energy before disconnect.
  /// </summary>
  public float ? energyLimit
  {
    get => GetAttribute < float ? > (nameof (energyLimit));
    set => SetAttribute (nameof (energyLimit), value);
  }
  /// <summary>
  /// Start date and time to accumulate energy for energy usage limiting.
  /// </summary>
  public DateTime ? energyUsageStartDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (energyUsageStartDateTime));
    set => SetAttribute (nameof (energyUsageStartDateTime), value);
  }
  /// <summary>
  /// Warning energy limit, used to trigger event code that energy usage is
  /// nearing limit.
  /// </summary>
  public float ? energyUsageWarning
  {
    get => GetAttribute < float ? > (nameof (energyUsageWarning));
    set => SetAttribute (nameof (energyUsageWarning), value);
  }
  /// <summary>
  /// True if the RCD switch has to be armed before a connect action can be
  /// initiated.
  /// </summary>
  public bool ? isArmConnect
  {
    get => GetAttribute < bool ? > (nameof (isArmConnect));
    set => SetAttribute (nameof (isArmConnect), value);
  }
  /// <summary>
  /// True if the RCD switch has to be armed before a disconnect action can be
  /// initiated.
  /// </summary>
  public bool ? isArmDisconnect
  {
    get => GetAttribute < bool ? > (nameof (isArmDisconnect));
    set => SetAttribute (nameof (isArmDisconnect), value);
  }
  /// <summary>
  /// True if the energy usage is limited and the customer will be disconnected
  /// if they go over the limit.
  /// </summary>
  public bool ? isEnergyLimiting
  {
    get => GetAttribute < bool ? > (nameof (isEnergyLimiting));
    set => SetAttribute (nameof (isEnergyLimiting), value);
  }
  /// <summary>
  /// True if load limit has to be checked to issue an immediate disconnect
  /// (after a connect) if load is over the limit.
  /// </summary>
  public bool ? needsPowerLimitCheck
  {
    get => GetAttribute < bool ? > (nameof (needsPowerLimitCheck));
    set => SetAttribute (nameof (needsPowerLimitCheck), value);
  }
  /// <summary>
  /// True if voltage limit has to be checked to prevent connect if voltage is
  /// over the limit.
  /// </summary>
  public bool ? needsVoltageLimitCheck
  {
    get => GetAttribute < bool ? > (nameof (needsVoltageLimitCheck));
    set => SetAttribute (nameof (needsVoltageLimitCheck), value);
  }
  /// <summary>
  /// Load limit above which the connect should either not take place or should
  /// cause an immediate disconnect.
  /// </summary>
  public float ? powerLimit
  {
    get => GetAttribute < float ? > (nameof (powerLimit));
    set => SetAttribute (nameof (powerLimit), value);
  }
  /// <summary>
  /// True if pushbutton has to be used for connect.
  /// </summary>
  public bool ? usePushbutton
  {
    get => GetAttribute < bool ? > (nameof (usePushbutton));
    set => SetAttribute (nameof (usePushbutton), value);
  }
}
/// <summary>
/// A rotating machine which may be used as a generator or motor.
/// </summary>
[CimClass (ClassUri)]
public partial class RotatingMachine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RegulatingCondEq (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RotatingMachine";

  /// <summary>
  /// Power factor (nameplate data). It is primarily used for short circuit data
  /// exchange according to IEC 60909. The attribute cannot be a negative value.
  /// </summary>
  public float ? ratedPowerFactor
  {
    get => GetAttribute < float ? > (nameof (ratedPowerFactor));
    set => SetAttribute (nameof (ratedPowerFactor), value);
  }
  /// <summary>
  /// Nameplate apparent power rating for the unit.The attribute shall have a
  /// positive value.
  /// </summary>
  public float ? ratedS
  {
    get => GetAttribute < float ? > (nameof (ratedS));
    set => SetAttribute (nameof (ratedS), value);
  }
  /// <summary>
  /// Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
  /// for short circuit data exchange according to IEC 60909.The attribute shall
  /// be a positive value.
  /// </summary>
  public float ? ratedU
  {
    get => GetAttribute < float ? > (nameof (ratedU));
    set => SetAttribute (nameof (ratedU), value);
  }

  /// <summary>
  /// A synchronous machine may operate as a generator and as such becomes a
  /// member of a generating unit.
  /// </summary>
  public GeneratingUnit ? GeneratingUnit
  {
    get => GetAssoc1To1<GeneratingUnit> (nameof (GeneratingUnit));
    set => SetAssoc1To1 (nameof (GeneratingUnit), value);
  }
}
/// <summary>
/// Abstract parent class for all synchronous and asynchronous machine standard
/// models.
/// </summary>
[CimClass (ClassUri)]
public partial class RotatingMachineDynamics
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : DynamicsFunctionBlock (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#RotatingMachineDynamics";

  /// <summary>
  /// Inertia constant of generator or motor and mechanical load (<i>H</i>)
  /// (&gt; 0).  This is the specification for the stored energy in the rotating
  /// mass when operating at rated speed.  For a generator, this includes the
  /// generator plus all other elements (turbine, exciter) on the same shaft and
  /// has units of MW x s.  For a motor, it includes the motor plus its
  /// mechanical load. Conventional units are PU on the generator MVA base,
  /// usually expressed as MW x s / MVA or just s. This value is used in the
  /// accelerating power reference frame for operator training simulator
  /// solutions.  Typical value = 3.
  /// </summary>
  public float ? inertia
  {
    get => GetAttribute < float ? > (nameof (inertia));
    set => SetAttribute (nameof (inertia), value);
  }
  /// <summary>
  /// Stator leakage reactance (<i>Xl</i>) (&gt;= 0). Typical value = 0,15.
  /// </summary>
  public float ? statorLeakageReactance
  {
    get => GetAttribute < float ? > (nameof (statorLeakageReactance));
    set => SetAttribute (nameof (statorLeakageReactance), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class RotatingMachineInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#RotatingMachineInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? rotorGD2
  {
    get => GetAttribute < float ? > (nameof (rotorGD2));
    set => SetAttribute (nameof (rotorGD2), value);
  }
}
/// <summary>
/// Physically controls access to AssetContainers.
/// </summary>
[CimClass (ClassUri)]
public partial class Seal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Seal";

  /// <summary>
  /// Date and time this seal has been applied.
  /// </summary>
  public DateTime ? appliedDateTime
  {
    get => GetAttribute < DateTime ? > (nameof (appliedDateTime));
    set => SetAttribute (nameof (appliedDateTime), value);
  }
  /// <summary>
  /// Condition of seal.
  /// </summary>
  public SealConditionKind ? condition
  {
    get => GetAttribute < SealConditionKind ? > (nameof (condition));
    set => SetAttribute (nameof (condition), value);
  }
  /// <summary>
  /// Kind of seal.
  /// </summary>
  public SealKind ? kind
  {
    get => GetAttribute < SealKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
  /// <summary>
  /// (reserved word) Seal number.
  /// </summary>
  public string ? sealNumber
  {
    get => GetAttribute < string ? > (nameof (sealNumber));
    set => SetAttribute (nameof (sealNumber), value);
  }
}
/// <summary>
/// This class describe devices that transform a measured quantity into signals
/// that can be presented at displays, used in control or be recorded.
/// </summary>
[CimClass (ClassUri)]
public partial class Sensor
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AuxiliaryEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Sensor";
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class SensorWinding
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#SensorWinding";

  /// <summary>
  ///
  /// </summary>
  public string ? accuracyClass
  {
    get => GetAttribute < string ? > (nameof (accuracyClass));
    set => SetAttribute (nameof (accuracyClass), value);
  }
  /// <summary>
  ///
  /// </summary>
  public WindingConnection ? connectionKind
  {
    get => GetAttribute < WindingConnection ? > (nameof (connectionKind));
    set => SetAttribute (nameof (connectionKind), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedS
  {
    get => GetAttribute < float ? > (nameof (ratedS));
    set => SetAttribute (nameof (ratedS), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class SeriesCapacitorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SeriesCompensatorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#SeriesCapacitorInfo";

  /// <summary>
  ///
  /// </summary>
  public object ? capacitorsInChainCount
  {
    get => GetAttribute < object ? > (nameof (capacitorsInChainCount));
    set => SetAttribute (nameof (capacitorsInChainCount), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? capacitorsInChainType
  {
    get => GetAttribute < string ? > (nameof (capacitorsInChainType));
    set => SetAttribute (nameof (capacitorsInChainType), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? chainCapacitorsCount
  {
    get => GetAttribute < object ? > (nameof (chainCapacitorsCount));
    set => SetAttribute (nameof (chainCapacitorsCount), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedCapacitance
  {
    get => GetAttribute < float ? > (nameof (ratedCapacitance));
    set => SetAttribute (nameof (ratedCapacitance), value);
  }
}
/// <summary>
/// A Series Compensator is a series capacitor or reactor or an AC transmission
/// line without charging susceptance.  It is a two terminal device.
/// </summary>
[CimClass (ClassUri)]
public partial class SeriesCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SeriesCompensator";

  /// <summary>
  /// Positive sequence resistance.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence resistance.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Positive sequence reactance.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero sequence reactance.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? couplingCoefficient
  {
    get => GetAttribute < float ? > (nameof (couplingCoefficient));
    set => SetAttribute (nameof (couplingCoefficient), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class SeriesCompensatorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#SeriesCompensatorInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? loss
  {
    get => GetAttribute < float ? > (nameof (loss));
    set => SetAttribute (nameof (loss), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxVoltage
  {
    get => GetAttribute < float ? > (nameof (maxVoltage));
    set => SetAttribute (nameof (maxVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedReactivePower
  {
    get => GetAttribute < float ? > (nameof (ratedReactivePower));
    set => SetAttribute (nameof (ratedReactivePower), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class SeriesVarCapacitorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SeriesCapacitorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#SeriesVarCapacitorInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? boosrMaxTime
  {
    get => GetAttribute < float ? > (nameof (boosrMaxTime));
    set => SetAttribute (nameof (boosrMaxTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? boostReactivePower
  {
    get => GetAttribute < float ? > (nameof (boostReactivePower));
    set => SetAttribute (nameof (boostReactivePower), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? boostX
  {
    get => GetAttribute < float ? > (nameof (boostX));
    set => SetAttribute (nameof (boostX), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? bypassCurrentThreshold
  {
    get => GetAttribute < float ? > (nameof (bypassCurrentThreshold));
    set => SetAttribute (nameof (bypassCurrentThreshold), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxReactivePower
  {
    get => GetAttribute < float ? > (nameof (maxReactivePower));
    set => SetAttribute (nameof (maxReactivePower), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? minReactivePower
  {
    get => GetAttribute < float ? > (nameof (minReactivePower));
    set => SetAttribute (nameof (minReactivePower), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedRegulatingTime
  {
    get => GetAttribute < float ? > (nameof (ratedRegulatingTime));
    set => SetAttribute (nameof (ratedRegulatingTime), value);
  }
}
/// <summary>
/// Category of service provided to the customer.
/// </summary>
[CimClass (ClassUri)]
public partial class ServiceCategory
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ServiceCategory";

  /// <summary>
  /// Kind of service.
  /// </summary>
  public ServiceKind ? kind
  {
    get => GetAttribute < ServiceKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
}
/// <summary>
/// A real estate location, commonly referred to as premises.
/// </summary>
[CimClass (ClassUri)]
public partial class ServiceLocation
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Location (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ServiceLocation";

  /// <summary>
  /// Method for the service person to access this service location. For
  /// example, a description of where to obtain a key if the facility is
  /// unmanned and secured.
  /// </summary>
  public string ? accessMethod
  {
    get => GetAttribute < string ? > (nameof (accessMethod));
    set => SetAttribute (nameof (accessMethod), value);
  }
  /// <summary>
  /// True if inspection is needed of facilities at this service location. This
  /// could be requested by a customer, due to suspected tampering,
  /// environmental concerns (e.g., a fire in the vicinity), or to correct
  /// incompatible data.
  /// </summary>
  public bool ? needsInspection
  {
    get => GetAttribute < bool ? > (nameof (needsInspection));
    set => SetAttribute (nameof (needsInspection), value);
  }
  /// <summary>
  /// Problems previously encountered when visiting or performing work on this
  /// location. Examples include: bad dog, violent customer, verbally abusive
  /// occupant, obstructions, safety hazards, etc.
  /// </summary>
  public string ? siteAccessProblem
  {
    get => GetAttribute < string ? > (nameof (siteAccessProblem));
    set => SetAttribute (nameof (siteAccessProblem), value);
  }
}
/// <summary>
/// Multiplier applied at the usage point.
/// </summary>
[CimClass (ClassUri)]
public partial class ServiceMultiplier
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ServiceMultiplier";

  /// <summary>
  /// Kind of multiplier.
  /// </summary>
  public ServiceMultiplierKind ? kind
  {
    get => GetAttribute < ServiceMultiplierKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
  /// <summary>
  /// Multiplier value.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Organisation that provides services to customers.
/// </summary>
[CimClass (ClassUri)]
public partial class ServiceSupplier
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OrganisationRole (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ServiceSupplier";

  /// <summary>
  /// Unique transaction reference prefix number issued to an entity by the
  /// International Organization for Standardization for the purpose of tagging
  /// onto electronic financial transactions, as defined in ISO/IEC 7812-1 and
  /// ISO/IEC 7812-2.
  /// </summary>
  public string ? issuerIdentificationNumber
  {
    get => GetAttribute < string ? > (nameof (issuerIdentificationNumber));
    set => SetAttribute (nameof (issuerIdentificationNumber), value);
  }
  /// <summary>
  /// Kind of supplier.
  /// </summary>
  public SupplierKind ? kind
  {
    get => GetAttribute < SupplierKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
}
/// <summary>
/// Short-circuit test results determine mesh impedance parameters. They include
/// load losses and leakage impedances. For three-phase windings, the excitation
/// can be a positive sequence (the default) or a zero sequence. There shall be
/// at least one grounded winding.
/// </summary>
[CimClass (ClassUri)]
public partial class ShortCircuitTest
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : TransformerTest (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ShortCircuitTest";

  /// <summary>
  /// Tap step number for the energised end of the test pair.
  /// </summary>
  public int ? energisedEndStep
  {
    get => GetAttribute < int ? > (nameof (energisedEndStep));
    set => SetAttribute (nameof (energisedEndStep), value);
  }
  /// <summary>
  /// Tap step number for the grounded end of the test pair.
  /// </summary>
  public int ? groundedEndStep
  {
    get => GetAttribute < int ? > (nameof (groundedEndStep));
    set => SetAttribute (nameof (groundedEndStep), value);
  }
  /// <summary>
  /// Load losses from a positive-sequence or single-phase short-circuit test.
  /// </summary>
  public float ? loss
  {
    get => GetAttribute < float ? > (nameof (loss));
    set => SetAttribute (nameof (loss), value);
  }
  /// <summary>
  /// Short circuit voltage..
  /// </summary>
  public float ? voltage
  {
    get => GetAttribute < float ? > (nameof (voltage));
    set => SetAttribute (nameof (voltage), value);
  }

  /// <summary>
  /// Transformer end that voltage is applied to in this short-circuit test. The
  /// test voltage is chosen to induce rated current in the energised end.
  /// </summary>
  public TransformerEndInfo ? EnergisedEnd
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (EnergisedEnd));
    set => SetAssoc1To1 (nameof (EnergisedEnd), value);
  }

  /// <summary>
  /// All ends short-circuited in this short-circuit test.
  /// </summary>
  public TransformerEndInfo[] GroundedEnds => GetAssoc1ToM<TransformerEndInfo> (
      nameof (GroundedEnds));
  public void AddToGroundedEnds (
      TransformerEndInfo assocObject) => AddAssoc1ToM (nameof (GroundedEnds),
                                                       assocObject);
  public void RemoveFromGroundedEnds (
      TransformerEndInfo assocObject) => RemoveAssoc1ToM (nameof (GroundedEnds),
                                                          assocObject);
  public void RemoveAllFromGroundedEnds () => RemoveAllAssocs1ToM (
      nameof (GroundedEnds));
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ShuntCapacitorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntCompensatorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ShuntCapacitorInfo";

  /// <summary>
  ///
  /// </summary>
  public object ? capacitorsInChainCount
  {
    get => GetAttribute < object ? > (nameof (capacitorsInChainCount));
    set => SetAttribute (nameof (capacitorsInChainCount), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? capacitorsInChainType
  {
    get => GetAttribute < string ? > (nameof (capacitorsInChainType));
    set => SetAttribute (nameof (capacitorsInChainType), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? chainCapacitorsCount
  {
    get => GetAttribute < object ? > (nameof (chainCapacitorsCount));
    set => SetAttribute (nameof (chainCapacitorsCount), value);
  }
}
/// <summary>
/// A shunt capacitor or reactor or switchable bank of shunt capacitors or
/// reactors. A section of a shunt compensator is an individual capacitor or
/// reactor. A negative value for bPerSection indicates that the compensator is
/// a reactor. ShuntCompensator is a single terminal device.  Ground is implied.
/// </summary>
[CimClass (ClassUri)]
public partial class ShuntCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RegulatingCondEq (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ShuntCompensator";

  /// <summary>
  /// Used for Yn and Zn connections. True if the neutral is solidly grounded.
  /// </summary>
  public bool ? grounded
  {
    get => GetAttribute < bool ? > (nameof (grounded));
    set => SetAttribute (nameof (grounded), value);
  }
  /// <summary>
  /// The maximum number of sections that may be switched in.
  /// </summary>
  public int ? maximumSections
  {
    get => GetAttribute < int ? > (nameof (maximumSections));
    set => SetAttribute (nameof (maximumSections), value);
  }
  /// <summary>
  /// The voltage at which the nominal reactive power may be calculated. This
  /// should normally be within 10% of the voltage at which the capacitor is
  /// connected to the network.
  /// </summary>
  public float ? nomU
  {
    get => GetAttribute < float ? > (nameof (nomU));
    set => SetAttribute (nameof (nomU), value);
  }
  /// <summary>
  /// The type of phase connection, such as wye or delta.
  /// </summary>
  public PhaseShuntConnectionKind ? phaseConnection
  {
    get => GetAttribute < PhaseShuntConnectionKind
        ? > (nameof (phaseConnection));
    set => SetAttribute (nameof (phaseConnection), value);
  }
}
/// <summary>
/// Properties of shunt capacitor, shunt reactor or switchable bank of shunt
/// capacitor or reactor assets.
/// </summary>
[CimClass (ClassUri)]
public partial class ShuntCompensatorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ShuntCompensatorInfo";

  /// <summary>
  /// Maximum allowed apparent power loss.
  /// </summary>
  public float ? maxPowerLoss
  {
    get => GetAttribute < float ? > (nameof (maxPowerLoss));
    set => SetAttribute (nameof (maxPowerLoss), value);
  }
  /// <summary>
  /// Rated current.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Rated reactive power.
  /// </summary>
  public float ? ratedReactivePower
  {
    get => GetAttribute < float ? > (nameof (ratedReactivePower));
    set => SetAttribute (nameof (ratedReactivePower), value);
  }
  /// <summary>
  /// Rated voltage.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? loss
  {
    get => GetAttribute < float ? > (nameof (loss));
    set => SetAttribute (nameof (loss), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class ShuntReactorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntCompensatorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#ShuntReactorInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? groundResistorEnergy
  {
    get => GetAttribute < float ? > (nameof (groundResistorEnergy));
    set => SetAttribute (nameof (groundResistorEnergy), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? neutralResistance
  {
    get => GetAttribute < float ? > (nameof (neutralResistance));
    set => SetAttribute (nameof (neutralResistance), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? neutralResistanceTime
  {
    get => GetAttribute < float ? > (nameof (neutralResistanceTime));
    set => SetAttribute (nameof (neutralResistanceTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedNeutralInsulationVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedNeutralInsulationVoltage));
    set => SetAttribute (nameof (ratedNeutralInsulationVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedNeutralVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedNeutralVoltage));
    set => SetAttribute (nameof (ratedNeutralVoltage), value);
  }
}
/// <summary>
/// Simple end device function distinguished by 'kind'. Use this class for
/// instances that cannot be represented by another end device function
/// specialisations.
/// </summary>
[CimClass (ClassUri)]
public partial class SimpleEndDeviceFunction
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EndDeviceFunction (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SimpleEndDeviceFunction";

  /// <summary>
  /// Kind of this function.
  /// </summary>
  public EndDeviceFunctionKind ? kind
  {
    get => GetAttribute < EndDeviceFunctionKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class StabilizingWinding
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#StabilizingWinding";

  /// <summary>
  ///
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedS
  {
    get => GetAttribute < float ? > (nameof (ratedS));
    set => SetAttribute (nameof (ratedS), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedU
  {
    get => GetAttribute < float ? > (nameof (ratedU));
    set => SetAttribute (nameof (ratedU), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }

  /// <summary>
  ///
  /// </summary>
  public PowerTransformer ? PowerTransformer
  {
    get => GetAssoc1To1<PowerTransformer> (nameof (PowerTransformer));
    set => SetAssoc1To1 (nameof (PowerTransformer), value);
  }
  /// <summary>
  ///
  /// </summary>
  public TransformerEndInfo ? TransformerEndInfo
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (TransformerEndInfo));
    set => SetAssoc1To1 (nameof (TransformerEndInfo), value);
  }
}
/// <summary>
/// A facility for providing variable and controllable shunt reactive power. The
/// SVC typically consists of a stepdown transformer, filter,
/// thyristor-controlled reactor, and thyristor-switched capacitor arms.The SVC
/// may operate in fixed MVar output mode or in voltage control mode. When in
/// voltage control mode, the output of the SVC will be proportional to the
/// deviation of voltage at the controlled bus from the voltage setpoint.  The
/// SVC characteristic slope defines the proportion.  If the voltage at the
/// controlled bus is equal to the voltage setpoint, the SVC MVar output is
/// zero.
/// </summary>
[CimClass (ClassUri)]
public partial class StaticVarCompensator
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RegulatingCondEq (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#StaticVarCompensator";

  /// <summary>
  /// Capacitive reactance at maximum capacitive reactive power.  Shall always
  /// be positive.
  /// </summary>
  public float ? capacitiveRating
  {
    get => GetAttribute < float ? > (nameof (capacitiveRating));
    set => SetAttribute (nameof (capacitiveRating), value);
  }
  /// <summary>
  /// Inductive reactance at maximum inductive reactive power.  Shall always be
  /// negative.
  /// </summary>
  public float ? inductiveRating
  {
    get => GetAttribute < float ? > (nameof (inductiveRating));
    set => SetAttribute (nameof (inductiveRating), value);
  }
  /// <summary>
  /// The characteristics slope of an SVC defines how the reactive power output
  /// changes in proportion to the difference between the regulated bus voltage
  /// and the voltage setpoint.The attribute shall be a positive value or zero.
  /// </summary>
  public float ? slope
  {
    get => GetAttribute < float ? > (nameof (slope));
    set => SetAttribute (nameof (slope), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxQ
  {
    get => GetAttribute < float ? > (nameof (maxQ));
    set => SetAttribute (nameof (maxQ), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? minQ
  {
    get => GetAttribute < float ? > (nameof (minQ));
    set => SetAttribute (nameof (minQ), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class StaticVarCompensatorInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ShuntCompensatorInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#StaticVarCompensatorInfo";

  /// <summary>
  ///
  /// </summary>
  public float ? maxSlope
  {
    get => GetAttribute < float ? > (nameof (maxSlope));
    set => SetAttribute (nameof (maxSlope), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? minSlope
  {
    get => GetAttribute < float ? > (nameof (minSlope));
    set => SetAttribute (nameof (minSlope), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedRegulatingTime
  {
    get => GetAttribute < float ? > (nameof (ratedRegulatingTime));
    set => SetAttribute (nameof (ratedRegulatingTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? regulatingSpeed
  {
    get => GetAttribute < float ? > (nameof (regulatingSpeed));
    set => SetAttribute (nameof (regulatingSpeed), value);
  }
}
/// <summary>
/// Current status information relevant to an entity.
/// </summary>
[CimClass (ClassUri)]
public partial class Status
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Status";

  /// <summary>
  /// Date and time for which status 'value' applies.
  /// </summary>
  public DateTime ? dateTime
  {
    get => GetAttribute < DateTime ? > (nameof (dateTime));
    set => SetAttribute (nameof (dateTime), value);
  }
  /// <summary>
  /// Reason code or explanation for why an object went to the current status
  /// 'value'.
  /// </summary>
  public string ? reason
  {
    get => GetAttribute < string ? > (nameof (reason));
    set => SetAttribute (nameof (reason), value);
  }
  /// <summary>
  /// Pertinent information regarding the current 'value', as free form text.
  /// </summary>
  public string ? remark
  {
    get => GetAttribute < string ? > (nameof (remark));
    set => SetAttribute (nameof (remark), value);
  }
  /// <summary>
  /// Status value at 'dateTime'; prior status changes may have been kept in
  /// instances of activity records associated with the object to which this
  /// status applies.
  /// </summary>
  public string ? value
  {
    get => GetAttribute < string ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Steam supply for steam turbine.
/// </summary>
[CimClass (ClassUri)]
public partial class SteamSupply
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#SteamSupply";

  /// <summary>
  /// Steam turbines may have steam supplied by a steam supply.
  /// </summary>
  public SteamTurbine[] SteamTurbines => GetAssoc1ToM<SteamTurbine> (
      nameof (SteamTurbines));
  public void AddToSteamTurbines (SteamTurbine assocObject) => AddAssoc1ToM (
      nameof (SteamTurbines), assocObject);
  public void RemoveFromSteamTurbines (
      SteamTurbine assocObject) => RemoveAssoc1ToM (nameof (SteamTurbines),
                                                    assocObject);
  public void RemoveAllFromSteamTurbines () => RemoveAllAssocs1ToM (
      nameof (SteamTurbines));
}
/// <summary>
/// Steam turbine.
/// </summary>
[CimClass (ClassUri)]
public partial class SteamTurbine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PrimeMover (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#SteamTurbine";

  /// <summary>
  /// Steam turbines may have steam supplied by a steam supply.
  /// </summary>
  public SteamSupply[] SteamSupplys => GetAssoc1ToM<SteamSupply> (
      nameof (SteamSupplys));
  public void AddToSteamSupplys (SteamSupply assocObject) => AddAssoc1ToM (
      nameof (SteamSupplys), assocObject);
  public void RemoveFromSteamSupplys (
      SteamSupply assocObject) => RemoveAssoc1ToM (nameof (SteamSupplys),
                                                   assocObject);
  public void RemoveAllFromSteamSupplys () => RemoveAllAssocs1ToM (
      nameof (SteamSupplys));
}
/// <summary>
/// General purpose street and postal address information.
/// </summary>
[CimClass (ClassUri)]
public partial class StreetAddress
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#StreetAddress";

  /// <summary>
  /// Postal code for the address.
  /// </summary>
  public string ? postalCode
  {
    get => GetAttribute < string ? > (nameof (postalCode));
    set => SetAttribute (nameof (postalCode), value);
  }
  /// <summary>
  /// Street detail.
  /// </summary>
  public StreetDetail ? streetDetail
  {
    get => GetAttribute < StreetDetail ? > (nameof (streetDetail));
    set => SetAttribute (nameof (streetDetail), value);
  }
  /// <summary>
  /// Town detail.
  /// </summary>
  public TownDetail ? townDetail
  {
    get => GetAttribute < TownDetail ? > (nameof (townDetail));
    set => SetAttribute (nameof (townDetail), value);
  }
}
/// <summary>
/// Street details, in the context of address.
/// </summary>
[CimClass (ClassUri)]
public partial class StreetDetail
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#StreetDetail";

  /// <summary>
  /// (if applicable) In certain cases the physical location of the place of
  /// interest does not have a direct point of entry from the street, but may be
  /// located inside a larger structure such as a building, complex, office
  /// block, apartment, etc.
  /// </summary>
  public string ? buildingName
  {
    get => GetAttribute < string ? > (nameof (buildingName));
    set => SetAttribute (nameof (buildingName), value);
  }
  /// <summary>
  /// The identification by name or number, expressed as text, of the floor in
  /// the building as part of this address.
  /// </summary>
  public string ? floorIdentification
  {
    get => GetAttribute < string ? > (nameof (floorIdentification));
    set => SetAttribute (nameof (floorIdentification), value);
  }
  /// <summary>
  /// Name of the street.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }
  /// <summary>
  /// Designator of the specific location on the street.
  /// </summary>
  public string ? number
  {
    get => GetAttribute < string ? > (nameof (number));
    set => SetAttribute (nameof (number), value);
  }
  /// <summary>
  /// Number of the apartment or suite.
  /// </summary>
  public string ? suiteNumber
  {
    get => GetAttribute < string ? > (nameof (suiteNumber));
    set => SetAttribute (nameof (suiteNumber), value);
  }
  /// <summary>
  /// Type of street. Examples include: street, circle, boulevard, avenue, road,
  /// drive, etc.
  /// </summary>
  public string ? type
  {
    get => GetAttribute < string ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
}
/// <summary>
/// Quantity with string value (when it is not important whether it is an
/// integral or a floating point number) and associated unit information.
/// </summary>
[CimClass (ClassUri)]
public partial class StringQuantity
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#StringQuantity";

  /// <summary>
  /// Unit multiplier of this quantity.
  /// </summary>
  public UnitMultiplier ? multiplier
  {
    get => GetAttribute < UnitMultiplier ? > (nameof (multiplier));
    set => SetAttribute (nameof (multiplier), value);
  }
  /// <summary>
  /// Unit of this quantity.
  /// </summary>
  public UnitSymbol ? unit
  {
    get => GetAttribute < UnitSymbol ? > (nameof (unit));
    set => SetAttribute (nameof (unit), value);
  }
  /// <summary>
  /// Value of this quantity.
  /// </summary>
  public string ? value
  {
    get => GetAttribute < string ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// Construction holding assets such as conductors, transformers, switchgear,
/// etc. Where applicable, number of conductors can be derived from the number
/// of associated wire spacing instances.
/// </summary>
[CimClass (ClassUri)]
public partial class Structure
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Structure";

  /// <summary>
  /// Maximum rated voltage of the equipment that can be mounted on/contained
  /// within the structure.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? rEarth
  {
    get => GetAttribute < float ? > (nameof (rEarth));
    set => SetAttribute (nameof (rEarth), value);
  }

  /// <summary>
  ///
  /// </summary>
  public WireSpacingInfo[] WireSpacingInfos => GetAssoc1ToM<WireSpacingInfo> (
      nameof (WireSpacingInfos));
  public void AddToWireSpacingInfos (
      WireSpacingInfo assocObject) => AddAssoc1ToM (nameof (WireSpacingInfos),
                                                    assocObject);
  public void
  RemoveFromWireSpacingInfos (WireSpacingInfo assocObject) => RemoveAssoc1ToM (
      nameof (WireSpacingInfos), assocObject);
  public void RemoveAllFromWireSpacingInfos () => RemoveAllAssocs1ToM (
      nameof (WireSpacingInfos));
}
/// <summary>
/// A subset of a geographical region of a power system network model.
/// </summary>
[CimClass (ClassUri)]
public partial class SubGeographicalRegion
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SubGeographicalRegion";

  /// <summary>
  /// The geographical region which this sub-geographical region is within.
  /// </summary>
  public GeographicalRegion ? Region
  {
    get => GetAssoc1To1<GeographicalRegion> (nameof (Region));
    set => SetAssoc1To1 (nameof (Region), value);
  }

  /// <summary>
  /// The lines within the sub-geographical region.
  /// </summary>
  public Line[] Lines => GetAssoc1ToM<Line> (nameof (Lines));
  public void AddToLines (Line assocObject) => AddAssoc1ToM (nameof (Lines),
                                                             assocObject);
  public void RemoveFromLines (Line assocObject) => RemoveAssoc1ToM (
      nameof (Lines), assocObject);
  public void RemoveAllFromLines () => RemoveAllAssocs1ToM (nameof (Lines));
  /// <summary>
  /// The substations in this sub-geographical region.
  /// </summary>
  public Substation[] Substations => GetAssoc1ToM<Substation> (
      nameof (Substations));
  public void AddToSubstations (Substation assocObject) => AddAssoc1ToM (
      nameof (Substations), assocObject);
  public void RemoveFromSubstations (
      Substation assocObject) => RemoveAssoc1ToM (nameof (Substations),
                                                  assocObject);
  public void RemoveAllFromSubstations () => RemoveAllAssocs1ToM (
      nameof (Substations));
  /// <summary>
  ///
  /// </summary>
  public Plant[] Plants => GetAssoc1ToM<Plant> (nameof (Plants));
  public void AddToPlants (Plant assocObject) => AddAssoc1ToM (nameof (Plants),
                                                               assocObject);
  public void RemoveFromPlants (Plant assocObject) => RemoveAssoc1ToM (
      nameof (Plants), assocObject);
  public void RemoveAllFromPlants () => RemoveAllAssocs1ToM (nameof (Plants));
}
/// <summary>
/// Once-through subcritical boiler.
/// </summary>
[CimClass (ClassUri)]
public partial class Subcritical
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : FossilSteamSupply (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Subcritical";
}
/// <summary>
/// A collection of equipment for purposes other than generation or utilization,
/// through which electric energy in bulk is passed for the purposes of
/// switching or modifying its characteristics.
/// </summary>
[CimClass (ClassUri)]
public partial class Substation
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Substation";

  /// <summary>
  /// The SubGeographicalRegion containing the substation.
  /// </summary>
  public SubGeographicalRegion ? Region
  {
    get => GetAssoc1To1<SubGeographicalRegion> (nameof (Region));
    set => SetAssoc1To1 (nameof (Region), value);
  }
  /// <summary>
  ///
  /// </summary>
  public Plant ? Plant
  {
    get => GetAssoc1To1<Plant> (nameof (Plant));
    set => SetAssoc1To1 (nameof (Plant), value);
  }

  /// <summary>
  /// The voltage levels within this substation.
  /// </summary>
  public VoltageLevel[] VoltageLevels => GetAssoc1ToM<VoltageLevel> (
      nameof (VoltageLevels));
  public void AddToVoltageLevels (VoltageLevel assocObject) => AddAssoc1ToM (
      nameof (VoltageLevels), assocObject);
  public void RemoveFromVoltageLevels (
      VoltageLevel assocObject) => RemoveAssoc1ToM (nameof (VoltageLevels),
                                                    assocObject);
  public void RemoveAllFromVoltageLevels () => RemoveAllAssocs1ToM (
      nameof (VoltageLevels));
}
/// <summary>
/// Once-through supercritical boiler.
/// </summary>
[CimClass (ClassUri)]
public partial class Supercritical
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : FossilSteamSupply (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Supercritical";
}
/// <summary>
/// Shunt device, installed on the network, usually in the proximity of
/// electrical equipment in order to protect the said equipment against
/// transient voltage transients caused by lightning or switching activity.
/// </summary>
[CimClass (ClassUri)]
public partial class SurgeArrester
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AuxiliaryEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#SurgeArrester";
}
/// <summary>
/// A generic device designed to close, or open, or both, one or more electric
/// circuits.  All switches are two terminal devices including grounding
/// switches. The ACDCTerminal.connected at the two sides of the switch shall
/// not be considered for assessing switch connectivity, i.e. only Switch.open,
/// .normalOpen and .locked are relevant.
/// </summary>
[CimClass (ClassUri)]
public partial class Switch
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ConductingEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Switch";

  /// <summary>
  /// The attribute is used in cases when no Measurement for the status value is
  /// present. If the Switch has a status measurement the Discrete.normalValue
  /// is expected to match with the Switch.normalOpen.
  /// </summary>
  public bool ? normalOpen
  {
    get => GetAttribute < bool ? > (nameof (normalOpen));
    set => SetAttribute (nameof (normalOpen), value);
  }
  /// <summary>
  /// The maximum continuous current carrying capacity in amps governed by the
  /// device material and construction.The attribute shall be a positive value.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? differenceInTransitTime
  {
    get => GetAttribute < float ? > (nameof (differenceInTransitTime));
    set => SetAttribute (nameof (differenceInTransitTime), value);
  }
}
/// <summary>
/// <was Switch data.>Switch datasheet information.
/// </summary>
[CimClass (ClassUri)]
public partial class SwitchInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#SwitchInfo";

  /// <summary>
  /// The maximum fault current a breaking device can break safely under
  /// prescribed conditions of use.
  /// </summary>
  public float ? breakingCapacity
  {
    get => GetAttribute < float ? > (nameof (breakingCapacity));
    set => SetAttribute (nameof (breakingCapacity), value);
  }
  /// <summary>
  /// If true, it is a single phase switch.
  /// </summary>
  public bool ? isSinglePhase
  {
    get => GetAttribute < bool ? > (nameof (isSinglePhase));
    set => SetAttribute (nameof (isSinglePhase), value);
  }
  /// <summary>
  /// If true, the switch is not ganged (i.e., a switch phase may be operated
  /// separately from other phases).
  /// </summary>
  public bool ? isUnganged
  {
    get => GetAttribute < bool ? > (nameof (isUnganged));
    set => SetAttribute (nameof (isUnganged), value);
  }
  /// <summary>
  /// Rated current.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Switch rated interrupting time in seconds.
  /// </summary>
  public float ? ratedInterruptingTime
  {
    get => GetAttribute < float ? > (nameof (ratedInterruptingTime));
    set => SetAttribute (nameof (ratedInterruptingTime), value);
  }
  /// <summary>
  /// Rated voltage.
  /// </summary>
  public float ? ratedVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedVoltage));
    set => SetAttribute (nameof (ratedVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? isUngangedControl
  {
    get => GetAttribute < bool ? > (nameof (isUngangedControl));
    set => SetAttribute (nameof (isUngangedControl), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedInTransitTime
  {
    get => GetAttribute < float ? > (nameof (ratedInTransitTime));
    set => SetAttribute (nameof (ratedInTransitTime), value);
  }
}
/// <summary>
/// An electromechanical device that operates with shaft rotating synchronously
/// with the network. It is a single machine operating either as a generator or
/// synchronous condenser or pump.
/// </summary>
[CimClass (ClassUri)]
public partial class SynchronousMachine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RotatingMachine (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SynchronousMachine";

  /// <summary>
  /// Active power consumed when in condenser mode operation.
  /// </summary>
  public float ? condenserP
  {
    get => GetAttribute < float ? > (nameof (condenserP));
    set => SetAttribute (nameof (condenserP), value);
  }
  /// <summary>
  /// Method of cooling the machine.
  /// </summary>
  public CoolantType ? coolantType
  {
    get => GetAttribute < CoolantType ? > (nameof (coolantType));
    set => SetAttribute (nameof (coolantType), value);
  }
  /// <summary>
  /// Indicates whether or not the generator is earthed. Used for short circuit
  /// data exchange according to IEC 60909.
  /// </summary>
  public bool ? earthing
  {
    get => GetAttribute < bool ? > (nameof (earthing));
    set => SetAttribute (nameof (earthing), value);
  }
  /// <summary>
  /// Generator star point earthing resistance (Re). Used for short circuit data
  /// exchange according to IEC 60909.
  /// </summary>
  public float ? earthingStarPointR
  {
    get => GetAttribute < float ? > (nameof (earthingStarPointR));
    set => SetAttribute (nameof (earthingStarPointR), value);
  }
  /// <summary>
  /// Generator star point earthing reactance (Xe). Used for short circuit data
  /// exchange according to IEC 60909.
  /// </summary>
  public float ? earthingStarPointX
  {
    get => GetAttribute < float ? > (nameof (earthingStarPointX));
    set => SetAttribute (nameof (earthingStarPointX), value);
  }
  /// <summary>
  /// Maximum reactive power limit. This is the maximum (nameplate) limit for
  /// the unit.
  /// </summary>
  public float ? maxQ
  {
    get => GetAttribute < float ? > (nameof (maxQ));
    set => SetAttribute (nameof (maxQ), value);
  }
  /// <summary>
  /// Maximum voltage limit for the unit.
  /// </summary>
  public float ? maxU
  {
    get => GetAttribute < float ? > (nameof (maxU));
    set => SetAttribute (nameof (maxU), value);
  }
  /// <summary>
  /// Minimum reactive power limit for the unit.
  /// </summary>
  public float ? minQ
  {
    get => GetAttribute < float ? > (nameof (minQ));
    set => SetAttribute (nameof (minQ), value);
  }
  /// <summary>
  /// Minimum voltage  limit for the unit.
  /// </summary>
  public float ? minU
  {
    get => GetAttribute < float ? > (nameof (minU));
    set => SetAttribute (nameof (minU), value);
  }
  /// <summary>
  /// Current mode of operation.
  /// </summary>
  public SynchronousMachineOperatingMode ? operatingMode
  {
    get => GetAttribute < SynchronousMachineOperatingMode
        ? > (nameof (operatingMode));
    set => SetAttribute (nameof (operatingMode), value);
  }
  /// <summary>
  /// Equivalent resistance (RG) of generator. RG is considered for the
  /// calculation of all currents, except for the calculation of the peak
  /// current ip. Used for short circuit data exchange according to IEC 60909.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence resistance of the synchronous machine.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Negative sequence resistance.
  /// </summary>
  public float ? r2
  {
    get => GetAttribute < float ? > (nameof (r2));
    set => SetAttribute (nameof (r2), value);
  }
  /// <summary>
  /// Direct-axis subtransient reactance saturated, also known as Xd"sat.
  /// </summary>
  public float ? satDirectSubtransX
  {
    get => GetAttribute < float ? > (nameof (satDirectSubtransX));
    set => SetAttribute (nameof (satDirectSubtransX), value);
  }
  /// <summary>
  /// Modes that this synchronous machine can operate in.
  /// </summary>
  public SynchronousMachineKind ? type
  {
    get => GetAttribute < SynchronousMachineKind ? > (nameof (type));
    set => SetAttribute (nameof (type), value);
  }
  /// <summary>
  /// Zero sequence reactance of the synchronous machine.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }
  /// <summary>
  /// Negative sequence reactance.
  /// </summary>
  public float ? x2
  {
    get => GetAttribute < float ? > (nameof (x2));
    set => SetAttribute (nameof (x2), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }

  /// <summary>
  /// The default reactive capability curve for use by a synchronous machine.
  /// </summary>
  public ReactiveCapabilityCurve ? InitialReactiveCapabilityCurve
  {
    get => GetAssoc1To1<ReactiveCapabilityCurve> (
        nameof (InitialReactiveCapabilityCurve));
    set => SetAssoc1To1 (nameof (InitialReactiveCapabilityCurve), value);
  }
  /// <summary>
  /// Synchronous machine dynamics model used to describe dynamic behaviour of
  /// this synchronous machine.
  /// </summary>
  public SynchronousMachineDynamics ? SynchronousMachineDynamics
  {
    get => GetAssoc1To1<SynchronousMachineDynamics> (
        nameof (SynchronousMachineDynamics));
    set => SetAssoc1To1 (nameof (SynchronousMachineDynamics), value);
  }

  /// <summary>
  /// Prime movers that drive this SynchronousMachine.
  /// </summary>
  public PrimeMover[] PrimeMovers => GetAssoc1ToM<PrimeMover> (
      nameof (PrimeMovers));
  public void AddToPrimeMovers (PrimeMover assocObject) => AddAssoc1ToM (
      nameof (PrimeMovers), assocObject);
  public void RemoveFromPrimeMovers (
      PrimeMover assocObject) => RemoveAssoc1ToM (nameof (PrimeMovers),
                                                  assocObject);
  public void RemoveAllFromPrimeMovers () => RemoveAllAssocs1ToM (
      nameof (PrimeMovers));
  /// <summary>
  /// All available reactive capability curves for this synchronous machine.
  /// </summary>
  public ReactiveCapabilityCurve[] ReactiveCapabilityCurves => GetAssoc1ToM<
      ReactiveCapabilityCurve> (nameof (ReactiveCapabilityCurves));
  public void AddToReactiveCapabilityCurves (
      ReactiveCapabilityCurve
          assocObject) => AddAssoc1ToM (nameof (ReactiveCapabilityCurves),
                                        assocObject);
  public void RemoveFromReactiveCapabilityCurves (
      ReactiveCapabilityCurve
          assocObject) => RemoveAssoc1ToM (nameof (ReactiveCapabilityCurves),
                                           assocObject);
  public void RemoveAllFromReactiveCapabilityCurves () => RemoveAllAssocs1ToM (
      nameof (ReactiveCapabilityCurves));
  /// <summary>
  ///
  /// </summary>
  public ExcitationSystem[] ExcitationSystem => GetAssoc1ToM<ExcitationSystem> (
      nameof (ExcitationSystem));
  public void AddToExcitationSystem (
      ExcitationSystem assocObject) => AddAssoc1ToM (nameof (ExcitationSystem),
                                                     assocObject);
  public void
  RemoveFromExcitationSystem (ExcitationSystem assocObject) => RemoveAssoc1ToM (
      nameof (ExcitationSystem), assocObject);
  public void RemoveAllFromExcitationSystem () => RemoveAllAssocs1ToM (
      nameof (ExcitationSystem));
}
/// <summary>
/// All synchronous machine detailed types use a subset of the same data
/// parameters and input/output variables.  The several variations differ in the
/// following ways:- the number of  equivalent windings that are included;- the
/// way in which saturation is incorporated into the model;- whether or not
/// “subtransient saliency” (<i>X''q</i> not = <i>X''d</i>) is represented.It is
/// not necessary for each simulation tool to have separate models for each of
/// the model types.  The same model can often be used for several types by
/// alternative logic within the model.  Also, differences in saturation
/// representation might not result in significant model performance differences
/// so model substitutions are often acceptable.
/// </summary>
[CimClass (ClassUri)]
public partial class SynchronousMachineDetailed
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SynchronousMachineDynamics (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SynchronousMachineDetailed";
}
/// <summary>
/// Synchronous machine whose behaviour is described by reference to a standard
/// model expressed in one of the following forms:- simplified (or classical),
/// where a group of generators or motors is not modelled in detail;- detailed,
/// in equivalent circuit form;- detailed, in time constant reactance form;
/// or<font color="#0f0f0f">- by definition of a user-defined model.</font><font
/// color="#0f0f0f">It is a common practice to represent small generators by a
/// negative load rather than by a dynamic generator model when performing
/// dynamics simulations. In this case, a SynchronousMachine in the static model
/// is not represented by anything in the dynamics model, instead it is treated
/// as an ordinary load.</font><font color="#0f0f0f">Parameter
/// details:</font><ol>	<li><font color="#0f0f0f">Synchronous machine parameters
/// such as <i>Xl, Xd, Xp</i> etc. are actually used as inductances in the
/// models,</font> but are commonly referred to as reactances since, at nominal
/// frequency, the PU values are the same. However, some references use the
/// symbol <i>L</i> instead of <i>X</i>.</li></ol>
/// </summary>
[CimClass (ClassUri)]
public partial class SynchronousMachineDynamics
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RotatingMachineDynamics (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SynchronousMachineDynamics";

  /// <summary>
  /// Synchronous machine to which synchronous machine dynamics model applies.
  /// </summary>
  public SynchronousMachine ? SynchronousMachine
  {
    get => GetAssoc1To1<SynchronousMachine> (nameof (SynchronousMachine));
    set => SetAssoc1To1 (nameof (SynchronousMachine), value);
  }
}
/// <summary>
/// Synchronous machine detailed modelling types are defined by the combination
/// of the attributes SynchronousMachineTimeConstantReactance.modelType and
/// SynchronousMachineTimeConstantReactance.rotorType.  Parameter details:<ol>
/// <li>The “p” in the time-related attribute names is a substitution for a
/// “prime” in the usual parameter notation, e.g. tpdo refers to
/// <i>T'do</i>.</li>	<li>The parameters used for models expressed in time
/// constant reactance form include:</li></ol>- RotatingMachine.ratedS
/// (<i>MVAbase</i>);- RotatingMachineDynamics.damping (<i>D</i>);-
/// RotatingMachineDynamics.inertia (<i>H</i>);-
/// RotatingMachineDynamics.saturationFactor (<i>S1</i>);-
/// RotatingMachineDynamics.saturationFactor120 (<i>S12</i>);-
/// RotatingMachineDynamics.statorLeakageReactance (<i>Xl</i>);-
/// RotatingMachineDynamics.statorResistance (<i>Rs</i>);-
/// SynchronousMachineTimeConstantReactance.ks (<i>Ks</i>);-
/// SynchronousMachineDetailed.saturationFactorQAxis (<i>S1q</i>);-
/// SynchronousMachineDetailed.saturationFactor120QAxis (<i>S12q</i>);-
/// SynchronousMachineDetailed.efdBaseRatio;-
/// SynchronousMachineDetailed.ifdBaseType;- .xDirectSync (<i>Xd</i>);-
/// .xDirectTrans (<i>X'd</i>);- .xDirectSubtrans (<i>X''d</i>);- .xQuadSync
/// (<i>Xq</i>);- .xQuadTrans (<i>X'q</i>);- .xQuadSubtrans (<i>X''q</i>);-
/// .tpdo (<i>T'do</i>);- .tppdo (<i>T''do</i>);- .tpqo (<i>T'qo</i>);- .tppqo
/// (<i>T''qo</i>);- .tc.
/// </summary>
[CimClass (ClassUri)]
public partial class SynchronousMachineTimeConstantReactance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : SynchronousMachineDetailed (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#SynchronousMachineTimeConstantReactance";

  /// <summary>
  /// Type of rotor on physical machine.
  /// </summary>
  public RotorKind ? rotorType
  {
    get => GetAttribute < RotorKind ? > (nameof (rotorType));
    set => SetAttribute (nameof (rotorType), value);
  }
  /// <summary>
  /// Direct-axis transient rotor time constant (<i>T'do</i>) (&gt;
  /// SynchronousMachineTimeConstantReactance.tppdo).  Typical value = 5.
  /// </summary>
  public float ? tpdo
  {
    get => GetAttribute < float ? > (nameof (tpdo));
    set => SetAttribute (nameof (tpdo), value);
  }
  /// <summary>
  /// Direct-axis subtransient rotor time constant (<i>T''do</i>) (&gt; 0).
  /// Typical value = 0,03.
  /// </summary>
  public float ? tppdo
  {
    get => GetAttribute < float ? > (nameof (tppdo));
    set => SetAttribute (nameof (tppdo), value);
  }
  /// <summary>
  /// Quadrature-axis subtransient rotor time constant (<i>T''qo</i>) (&gt; 0).
  /// Typical value = 0,03.
  /// </summary>
  public float ? tppqo
  {
    get => GetAttribute < float ? > (nameof (tppqo));
    set => SetAttribute (nameof (tppqo), value);
  }
  /// <summary>
  /// Quadrature-axis transient rotor time constant (<i>T'qo</i>) (&gt;
  /// SynchronousMachineTimeConstantReactance.tppqo). Typical value = 0,5.
  /// </summary>
  public float ? tpqo
  {
    get => GetAttribute < float ? > (nameof (tpqo));
    set => SetAttribute (nameof (tpqo), value);
  }
  /// <summary>
  /// Direct-axis subtransient reactance (unsaturated) (<i>X''d</i>) (&gt;
  /// RotatingMachineDynamics.statorLeakageReactance).  Typical value = 0,2.
  /// </summary>
  public float ? xDirectSubtrans
  {
    get => GetAttribute < float ? > (nameof (xDirectSubtrans));
    set => SetAttribute (nameof (xDirectSubtrans), value);
  }
  /// <summary>
  /// Direct-axis synchronous reactance (<i>Xd</i>) (&gt;=
  /// SynchronousMachineTimeConstantReactance.xDirectTrans). The quotient of a
  /// sustained value of that AC component of armature voltage that is produced
  /// by the total direct-axis flux due to direct-axis armature current and the
  /// value of the AC component of this current, the machine running at rated
  /// speed.  Typical value = 1,8.
  /// </summary>
  public float ? xDirectSync
  {
    get => GetAttribute < float ? > (nameof (xDirectSync));
    set => SetAttribute (nameof (xDirectSync), value);
  }
  /// <summary>
  /// Direct-axis transient reactance (unsaturated) (<i>X'd</i>) (&gt;=
  /// SynchronousMachineTimeConstantReactance.xDirectSubtrans).  Typical value =
  /// 0,5.
  /// </summary>
  public float ? xDirectTrans
  {
    get => GetAttribute < float ? > (nameof (xDirectTrans));
    set => SetAttribute (nameof (xDirectTrans), value);
  }
  /// <summary>
  /// Quadrature-axis subtransient reactance (<i>X''q</i>) (&gt;
  /// RotatingMachineDynamics.statorLeakageReactance).  Typical value = 0,2.
  /// </summary>
  public float ? xQuadSubtrans
  {
    get => GetAttribute < float ? > (nameof (xQuadSubtrans));
    set => SetAttribute (nameof (xQuadSubtrans), value);
  }
  /// <summary>
  /// Quadrature-axis synchronous reactance (<i>Xq</i>) (&gt;=
  /// SynchronousMachineTimeConstantReactance.xQuadTrans).The ratio of the
  /// component of reactive armature voltage, due to the quadrature-axis
  /// component of armature current, to this component of current, under steady
  /// state conditions and at rated frequency.  Typical value = 1,6.
  /// </summary>
  public float ? xQuadSync
  {
    get => GetAttribute < float ? > (nameof (xQuadSync));
    set => SetAttribute (nameof (xQuadSync), value);
  }
  /// <summary>
  /// Quadrature-axis transient reactance (<i>X'q</i>) (&gt;=
  /// SynchronousMachineTimeConstantReactance.xQuadSubtrans).  Typical value =
  /// 0,3.
  /// </summary>
  public float ? xQuadTrans
  {
    get => GetAttribute < float ? > (nameof (xQuadTrans));
    set => SetAttribute (nameof (xQuadTrans), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? tdo
  {
    get => GetAttribute < float ? > (nameof (tdo));
    set => SetAttribute (nameof (tdo), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? tpd
  {
    get => GetAttribute < float ? > (nameof (tpd));
    set => SetAttribute (nameof (tpd), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? tppd
  {
    get => GetAttribute < float ? > (nameof (tppd));
    set => SetAttribute (nameof (tppd), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? tppq
  {
    get => GetAttribute < float ? > (nameof (tppq));
    set => SetAttribute (nameof (tppq), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class SynchronousMachinelnfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RotatingMachineInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#SynchronousMachinelnfo";

  /// <summary>
  ///
  /// </summary>
  public float ? asyncModeAllowedTime
  {
    get => GetAttribute < float ? > (nameof (asyncModeAllowedTime));
    set => SetAttribute (nameof (asyncModeAllowedTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? generatorGD2
  {
    get => GetAttribute < float ? > (nameof (generatorGD2));
    set => SetAttribute (nameof (generatorGD2), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? isAsyncModeAdmissibility
  {
    get => GetAttribute < bool ? > (nameof (isAsyncModeAdmissibility));
    set => SetAttribute (nameof (isAsyncModeAdmissibility), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxLoadExcCurrent
  {
    get => GetAttribute < float ? > (nameof (maxLoadExcCurrent));
    set => SetAttribute (nameof (maxLoadExcCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? maxLoadExcVoltage
  {
    get => GetAttribute < float ? > (nameof (maxLoadExcVoltage));
    set => SetAttribute (nameof (maxLoadExcVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? noLoadExcCurrent
  {
    get => GetAttribute < float ? > (nameof (noLoadExcCurrent));
    set => SetAttribute (nameof (noLoadExcCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? noLoadExcVoltage
  {
    get => GetAttribute < float ? > (nameof (noLoadExcVoltage));
    set => SetAttribute (nameof (noLoadExcVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? nominalRotationSpeed
  {
    get => GetAttribute < float ? > (nameof (nominalRotationSpeed));
    set => SetAttribute (nameof (nominalRotationSpeed), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedExcCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedExcCurrent));
    set => SetAttribute (nameof (ratedExcCurrent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? ratedExcVoltage
  {
    get => GetAttribute < float ? > (nameof (ratedExcVoltage));
    set => SetAttribute (nameof (ratedExcVoltage), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? shortCircuitExcCurrent
  {
    get => GetAttribute < float ? > (nameof (shortCircuitExcCurrent));
    set => SetAttribute (nameof (shortCircuitExcCurrent), value);
  }
}
/// <summary>
/// Mechanism for changing transformer winding tap positions.
/// </summary>
[CimClass (ClassUri)]
public partial class TapChanger
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PowerSystemResource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#TapChanger";

  /// <summary>
  /// Specifies the regulation status of the equipment.  True is regulating,
  /// false is not regulating.
  /// </summary>
  public bool ? controlEnabled
  {
    get => GetAttribute < bool ? > (nameof (controlEnabled));
    set => SetAttribute (nameof (controlEnabled), value);
  }
  /// <summary>
  /// Highest possible tap step position, advance from neutral.The attribute
  /// shall be greater than lowStep.
  /// </summary>
  public int ? highStep
  {
    get => GetAttribute < int ? > (nameof (highStep));
    set => SetAttribute (nameof (highStep), value);
  }
  /// <summary>
  /// Lowest possible tap step position, retard from neutral.
  /// </summary>
  public int ? lowStep
  {
    get => GetAttribute < int ? > (nameof (lowStep));
    set => SetAttribute (nameof (lowStep), value);
  }
  /// <summary>
  /// Specifies whether or not a TapChanger has load tap changing capabilities.
  /// </summary>
  public bool ? ltcFlag
  {
    get => GetAttribute < bool ? > (nameof (ltcFlag));
    set => SetAttribute (nameof (ltcFlag), value);
  }
  /// <summary>
  /// The neutral tap step position for this winding.The attribute shall be
  /// equal to or greater than lowStep and equal or less than highStep.It is the
  /// step position where the voltage is neutralU when the other terminals of
  /// the transformer are at the ratedU.  If there are other tap changers on the
  /// transformer those taps are kept constant at their neutralStep.
  /// </summary>
  public int ? neutralStep
  {
    get => GetAttribute < int ? > (nameof (neutralStep));
    set => SetAttribute (nameof (neutralStep), value);
  }
  /// <summary>
  /// The tap step position used in "normal" network operation for this winding.
  /// For a "Fixed" tap changer indicates the current physical tap setting.The
  /// attribute shall be equal to or greater than lowStep and equal to or less
  /// than highStep.
  /// </summary>
  public int ? normalStep
  {
    get => GetAttribute < int ? > (nameof (normalStep));
    set => SetAttribute (nameof (normalStep), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? neutralStepCount
  {
    get => GetAttribute < object ? > (nameof (neutralStepCount));
    set => SetAttribute (nameof (neutralStepCount), value);
  }

  /// <summary>
  /// The regulating control scheme in which this tap changer participates.
  /// </summary>
  public TapChangerControl ? TapChangerControl
  {
    get => GetAssoc1To1<TapChangerControl> (nameof (TapChangerControl));
    set => SetAssoc1To1 (nameof (TapChangerControl), value);
  }
}
/// <summary>
/// Describes behaviour specific to tap changers, e.g. how the voltage at the
/// end of a line varies with the load level and compensation of the voltage
/// drop by tap adjustment.
/// </summary>
[CimClass (ClassUri)]
public partial class TapChangerControl
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : RegulatingControl (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TapChangerControl";

  /// <summary>
  /// The tap changers that participates in this regulating tap control scheme.
  /// </summary>
  public TapChanger[] TapChanger => GetAssoc1ToM<TapChanger> (
      nameof (TapChanger));
  public void AddToTapChanger (TapChanger assocObject) => AddAssoc1ToM (
      nameof (TapChanger), assocObject);
  public void RemoveFromTapChanger (TapChanger assocObject) => RemoveAssoc1ToM (
      nameof (TapChanger), assocObject);
  public void RemoveAllFromTapChanger () => RemoveAllAssocs1ToM (
      nameof (TapChanger));
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class TapChangerDependentLimitPoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#TapChangerDependentLimitPoint";

  /// <summary>
  ///
  /// </summary>
  public float ? limitPercent
  {
    get => GetAttribute < float ? > (nameof (limitPercent));
    set => SetAttribute (nameof (limitPercent), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? step
  {
    get => GetAttribute < object ? > (nameof (step));
    set => SetAttribute (nameof (step), value);
  }

  /// <summary>
  ///
  /// </summary>
  public TapChangerDependentLimitTable ? TapChangerDependentLimitTable
  {
    get => GetAssoc1To1<TapChangerDependentLimitTable> (
        nameof (TapChangerDependentLimitTable));
    set => SetAssoc1To1 (nameof (TapChangerDependentLimitTable), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class TapChangerDependentLimitTable
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : LimitDependency (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#TapChangerDependentLimitTable";

  /// <summary>
  ///
  /// </summary>
  public RatioTapChanger[] RatioTapChanger => GetAssoc1ToM<RatioTapChanger> (
      nameof (RatioTapChanger));
  public void AddToRatioTapChanger (
      RatioTapChanger assocObject) => AddAssoc1ToM (nameof (RatioTapChanger),
                                                    assocObject);
  public void RemoveFromRatioTapChanger (
      RatioTapChanger assocObject) => RemoveAssoc1ToM (nameof (RatioTapChanger),
                                                       assocObject);
  public void RemoveAllFromRatioTapChanger () => RemoveAllAssocs1ToM (
      nameof (RatioTapChanger));
  /// <summary>
  ///
  /// </summary>
  public TapChangerDependentLimitPoint
  [] TapChangerDependentLimitPoints => GetAssoc1ToM<
      TapChangerDependentLimitPoint> (nameof (TapChangerDependentLimitPoints));
  public void AddToTapChangerDependentLimitPoints (
      TapChangerDependentLimitPoint
          assocObject) => AddAssoc1ToM (nameof (TapChangerDependentLimitPoints),
                                        assocObject);
  public void RemoveFromTapChangerDependentLimitPoints (
      TapChangerDependentLimitPoint
          assocObject) => RemoveAssoc1ToM (nameof (TapChangerDependentLimitPoints),
                                           assocObject);
  public void
  RemoveAllFromTapChangerDependentLimitPoints () => RemoveAllAssocs1ToM (
      nameof (TapChangerDependentLimitPoints));
}
/// <summary>
/// Describes each tap step in the tabular curve.
/// </summary>
[CimClass (ClassUri)]
public partial class TapChangerTablePoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TapChangerTablePoint";

  /// <summary>
  /// The magnetizing branch susceptance deviation as a percentage of nominal
  /// value. The actual susceptance is calculated as follows:calculated
  /// magnetizing susceptance = b(nominal) * (1 + b(from this class)/100).   The
  /// b(nominal) is defined as the static magnetizing susceptance on the
  /// associated power transformer end or ends.  This model assumes the star
  /// impedance (pi model) form.
  /// </summary>
  public float ? b
  {
    get => GetAttribute < float ? > (nameof (b));
    set => SetAttribute (nameof (b), value);
  }
  /// <summary>
  /// The magnetizing branch conductance deviation as a percentage of nominal
  /// value. The actual conductance is calculated as follows:calculated
  /// magnetizing conductance = g(nominal) * (1 + g(from this class)/100).   The
  /// g(nominal) is defined as the static magnetizing conductance on the
  /// associated power transformer end or ends.  This model assumes the star
  /// impedance (pi model) form.
  /// </summary>
  public float ? g
  {
    get => GetAttribute < float ? > (nameof (g));
    set => SetAttribute (nameof (g), value);
  }
  /// <summary>
  /// The resistance deviation as a percentage of nominal value. The actual
  /// reactance is calculated as follows:calculated resistance = r(nominal) * (1
  /// + r(from this class)/100).   The r(nominal) is defined as the static
  /// resistance on the associated power transformer end or ends.  This model
  /// assumes the star impedance (pi model) form.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// The voltage at the tap step divided by rated voltage of the transformer
  /// end having the tap changer. Hence this is a value close to one.For
  /// example, if the ratio at step 1 is 1.01, and the rated voltage of the
  /// transformer end is 110kV, then the voltage obtained by setting the tap
  /// changer to step 1 to is 111.1kV.
  /// </summary>
  public float ? ratio
  {
    get => GetAttribute < float ? > (nameof (ratio));
    set => SetAttribute (nameof (ratio), value);
  }
  /// <summary>
  /// The tap step.
  /// </summary>
  public int ? step
  {
    get => GetAttribute < int ? > (nameof (step));
    set => SetAttribute (nameof (step), value);
  }
  /// <summary>
  /// The series reactance deviation as a percentage of nominal value. The
  /// actual reactance is calculated as follows:calculated reactance =
  /// x(nominal) * (1 + x(from this class)/100).   The x(nominal) is defined as
  /// the static series reactance on the associated power transformer end or
  /// ends.  This model assumes the star impedance (pi model) form.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
}
/// <summary>
/// Tape shield cable data.
/// </summary>
[CimClass (ClassUri)]
public partial class TapeShieldCableInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : CableInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TapeShieldCableInfo";

  /// <summary>
  /// Percentage of the tape shield width that overlaps in each wrap, typically
  /// 10% to 25%.
  /// </summary>
  public float ? tapeLap
  {
    get => GetAttribute < float ? > (nameof (tapeLap));
    set => SetAttribute (nameof (tapeLap), value);
  }
  /// <summary>
  /// Thickness of the tape shield, before wrapping.
  /// </summary>
  public float ? tapeThickness
  {
    get => GetAttribute < float ? > (nameof (tapeThickness));
    set => SetAttribute (nameof (tapeThickness), value);
  }
}
/// <summary>
/// Telephone number.
/// </summary>
[CimClass (ClassUri)]
public partial class TelephoneNumber
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TelephoneNumber";

  /// <summary>
  /// City code.
  /// </summary>
  public string ? cityCode
  {
    get => GetAttribute < string ? > (nameof (cityCode));
    set => SetAttribute (nameof (cityCode), value);
  }
  /// <summary>
  /// Country code.
  /// </summary>
  public string ? countryCode
  {
    get => GetAttribute < string ? > (nameof (countryCode));
    set => SetAttribute (nameof (countryCode), value);
  }
  /// <summary>
  /// (if applicable) Extension for this telephone number.
  /// </summary>
  public string ? extension
  {
    get => GetAttribute < string ? > (nameof (extension));
    set => SetAttribute (nameof (extension), value);
  }
  /// <summary>
  /// Main (local) part of this telephone number.
  /// </summary>
  public string ? localNumber
  {
    get => GetAttribute < string ? > (nameof (localNumber));
    set => SetAttribute (nameof (localNumber), value);
  }
}
/// <summary>
/// A point on a table of limit verses temperature.
/// </summary>
[CimClass (ClassUri)]
public partial class TemperatureDependentLimitPoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TemperatureDependentLimitPoint";

  /// <summary>
  /// The scaling of the operational limit in percent.
  /// </summary>
  public float ? limitPercent
  {
    get => GetAttribute < float ? > (nameof (limitPercent));
    set => SetAttribute (nameof (limitPercent), value);
  }
  /// <summary>
  /// The temperature of the table point.
  /// </summary>
  public float ? temperature
  {
    get => GetAttribute < float ? > (nameof (temperature));
    set => SetAttribute (nameof (temperature), value);
  }
  /// <summary>
  ///
  /// </summary>
  public bool ? interpolation
  {
    get => GetAttribute < bool ? > (nameof (interpolation));
    set => SetAttribute (nameof (interpolation), value);
  }

  /// <summary>
  ///
  /// </summary>
  public TemperatureDependentLimitTable ? TemperatureDependentLimitTable
  {
    get => GetAssoc1To1<TemperatureDependentLimitTable> (
        nameof (TemperatureDependentLimitTable));
    set => SetAssoc1To1 (nameof (TemperatureDependentLimitTable), value);
  }
}
/// <summary>
/// This is a table lookup that provides limit values corresponding to a
/// temperature input.
/// </summary>
[CimClass (ClassUri)]
public partial class TemperatureDependentLimitTable
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EnvironmentalDependentLimit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TemperatureDependentLimitTable";

  /// <summary>
  ///
  /// </summary>
  public TemperatureDependentLimitPoint
  [] TemperatureLimitTablePoint => GetAssoc1ToM<
      TemperatureDependentLimitPoint> (nameof (TemperatureLimitTablePoint));
  public void AddToTemperatureLimitTablePoint (
      TemperatureDependentLimitPoint
          assocObject) => AddAssoc1ToM (nameof (TemperatureLimitTablePoint),
                                        assocObject);
  public void RemoveFromTemperatureLimitTablePoint (
      TemperatureDependentLimitPoint
          assocObject) => RemoveAssoc1ToM (nameof (TemperatureLimitTablePoint),
                                           assocObject);
  public void
  RemoveAllFromTemperatureLimitTablePoint () => RemoveAllAssocs1ToM (
      nameof (TemperatureLimitTablePoint));
}
/// <summary>
/// An AC electrical connection point to a piece of conducting equipment.
/// Terminals are connected at physical connection points called connectivity
/// nodes.
/// </summary>
[CimClass (ClassUri)]
public partial class Terminal
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ACDCTerminal (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Terminal";

  /// <summary>
  /// Represents the normal network phasing condition. If the attribute is
  /// missing, three phases (ABC) shall be assumed, except for terminals of
  /// grounding classes (specializations of EarthFaultCompensator,
  /// GroundDisconnector, and Ground) which will be assumed to be N. Therefore,
  /// phase code ABCN is explicitly declared when needed, e.g. for star point
  /// grounding equipment.The phase code on terminals connecting same
  /// ConnectivityNode or same TopologicalNode as well as for equipment between
  /// two terminals shall be consistent.
  /// </summary>
  public PhaseCode ? phases
  {
    get => GetAttribute < PhaseCode ? > (nameof (phases));
    set => SetAttribute (nameof (phases), value);
  }

  /// <summary>
  /// The conducting equipment of the terminal.  Conducting equipment have
  /// terminals that may be connected to other conducting equipment terminals
  /// via connectivity nodes or topological nodes.
  /// </summary>
  public ConductingEquipment ? ConductingEquipment
  {
    get => GetAssoc1To1<ConductingEquipment> (nameof (ConductingEquipment));
    set => SetAssoc1To1 (nameof (ConductingEquipment), value);
  }
  /// <summary>
  /// The connectivity node to which this terminal connects with zero impedance.
  /// </summary>
  public ConnectivityNode ? ConnectivityNode
  {
    get => GetAssoc1To1<ConnectivityNode> (nameof (ConnectivityNode));
    set => SetAssoc1To1 (nameof (ConnectivityNode), value);
  }

  /// <summary>
  /// The auxiliary equipment connected to the terminal.
  /// </summary>
  public AuxiliaryEquipment[] AuxiliaryEquipment => GetAssoc1ToM<
      AuxiliaryEquipment> (nameof (AuxiliaryEquipment));
  public void
  AddToAuxiliaryEquipment (AuxiliaryEquipment assocObject) => AddAssoc1ToM (
      nameof (AuxiliaryEquipment), assocObject);
  public void RemoveFromAuxiliaryEquipment (
      AuxiliaryEquipment
          assocObject) => RemoveAssoc1ToM (nameof (AuxiliaryEquipment),
                                           assocObject);
  public void RemoveAllFromAuxiliaryEquipment () => RemoveAllAssocs1ToM (
      nameof (AuxiliaryEquipment));
  /// <summary>
  /// Mutual couplings associated with the branch as the first branch.
  /// </summary>
  public MutualCoupling[] HasFirstMutualCoupling => GetAssoc1ToM<
      MutualCoupling> (nameof (HasFirstMutualCoupling));
  public void
  AddToHasFirstMutualCoupling (MutualCoupling assocObject) => AddAssoc1ToM (
      nameof (HasFirstMutualCoupling), assocObject);
  public void RemoveFromHasFirstMutualCoupling (
      MutualCoupling
          assocObject) => RemoveAssoc1ToM (nameof (HasFirstMutualCoupling),
                                           assocObject);
  public void RemoveAllFromHasFirstMutualCoupling () => RemoveAllAssocs1ToM (
      nameof (HasFirstMutualCoupling));
  /// <summary>
  /// Mutual couplings with the branch associated as the first branch.
  /// </summary>
  public MutualCoupling[] HasSecondMutualCoupling => GetAssoc1ToM<
      MutualCoupling> (nameof (HasSecondMutualCoupling));
  public void
  AddToHasSecondMutualCoupling (MutualCoupling assocObject) => AddAssoc1ToM (
      nameof (HasSecondMutualCoupling), assocObject);
  public void RemoveFromHasSecondMutualCoupling (
      MutualCoupling
          assocObject) => RemoveAssoc1ToM (nameof (HasSecondMutualCoupling),
                                           assocObject);
  public void RemoveAllFromHasSecondMutualCoupling () => RemoveAllAssocs1ToM (
      nameof (HasSecondMutualCoupling));
  /// <summary>
  /// The controls regulating this terminal.
  /// </summary>
  public RegulatingControl[] RegulatingControl => GetAssoc1ToM<
      RegulatingControl> (nameof (RegulatingControl));
  public void
  AddToRegulatingControl (RegulatingControl assocObject) => AddAssoc1ToM (
      nameof (RegulatingControl), assocObject);
  public void RemoveFromRegulatingControl (
      RegulatingControl
          assocObject) => RemoveAssoc1ToM (nameof (RegulatingControl),
                                           assocObject);
  public void RemoveAllFromRegulatingControl () => RemoveAllAssocs1ToM (
      nameof (RegulatingControl));
  /// <summary>
  /// All transformer ends connected at this terminal.
  /// </summary>
  public TransformerEnd[] TransformerEnd => GetAssoc1ToM<TransformerEnd> (
      nameof (TransformerEnd));
  public void AddToTransformerEnd (TransformerEnd assocObject) => AddAssoc1ToM (
      nameof (TransformerEnd), assocObject);
  public void RemoveFromTransformerEnd (
      TransformerEnd assocObject) => RemoveAssoc1ToM (nameof (TransformerEnd),
                                                      assocObject);
  public void RemoveAllFromTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (TransformerEnd));
  /// <summary>
  ///
  /// </summary>
  public ACLineSeriesSection[] ACLineSeriesSection => GetAssoc1ToM<
      ACLineSeriesSection> (nameof (ACLineSeriesSection));
  public void
  AddToACLineSeriesSection (ACLineSeriesSection assocObject) => AddAssoc1ToM (
      nameof (ACLineSeriesSection), assocObject);
  public void RemoveFromACLineSeriesSection (
      ACLineSeriesSection
          assocObject) => RemoveAssoc1ToM (nameof (ACLineSeriesSection),
                                           assocObject);
  public void RemoveAllFromACLineSeriesSection () => RemoveAllAssocs1ToM (
      nameof (ACLineSeriesSection));
}
/// <summary>
/// A generating unit whose prime mover could be a steam turbine, combustion
/// turbine, or diesel engine.
/// </summary>
[CimClass (ClassUri)]
public partial class ThermalGeneratingUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : GeneratingUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#ThermalGeneratingUnit";

  /// <summary>
  /// A thermal generating unit may be a member of a cogeneration plant.
  /// </summary>
  public CogenerationPlant ? CogenerationPlant
  {
    get => GetAssoc1To1<CogenerationPlant> (nameof (CogenerationPlant));
    set => SetAssoc1To1 (nameof (CogenerationPlant), value);
  }
  /// <summary>
  /// A thermal generating unit may be a member of a combined cycle plant.
  /// </summary>
  public CombinedCyclePlant ? CombinedCyclePlant
  {
    get => GetAssoc1To1<CombinedCyclePlant> (nameof (CombinedCyclePlant));
    set => SetAssoc1To1 (nameof (CombinedCyclePlant), value);
  }

  /// <summary>
  /// A thermal generating unit may have one or more fossil fuels.
  /// </summary>
  public FossilFuel[] FossilFuels => GetAssoc1ToM<FossilFuel> (
      nameof (FossilFuels));
  public void AddToFossilFuels (FossilFuel assocObject) => AddAssoc1ToM (
      nameof (FossilFuels), assocObject);
  public void RemoveFromFossilFuels (
      FossilFuel assocObject) => RemoveAssoc1ToM (nameof (FossilFuels),
                                                  assocObject);
  public void RemoveAllFromFossilFuels () => RemoveAllAssocs1ToM (
      nameof (FossilFuels));
  /// <summary>
  ///
  /// </summary>
  public CapacityConfiguration[] CapacityConfiguration => GetAssoc1ToM<
      CapacityConfiguration> (nameof (CapacityConfiguration));
  public void AddToCapacityConfiguration (
      CapacityConfiguration
          assocObject) => AddAssoc1ToM (nameof (CapacityConfiguration),
                                        assocObject);
  public void RemoveFromCapacityConfiguration (
      CapacityConfiguration
          assocObject) => RemoveAssoc1ToM (nameof (CapacityConfiguration),
                                           assocObject);
  public void RemoveAllFromCapacityConfiguration () => RemoveAllAssocs1ToM (
      nameof (CapacityConfiguration));
}
/// <summary>
/// Interval between two times.
/// </summary>
[CimClass (ClassUri)]
public partial class TimeInterval
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#TimeInterval";

  /// <summary>
  /// End time of this interval.
  /// </summary>
  public DateTime ? end
  {
    get => GetAttribute < DateTime ? > (nameof (end));
    set => SetAttribute (nameof (end), value);
  }
  /// <summary>
  /// Start time of this interval.
  /// </summary>
  public DateTime ? start
  {
    get => GetAttribute < DateTime ? > (nameof (start));
    set => SetAttribute (nameof (start), value);
  }
}
/// <summary>
/// Description of anything that changes through time. Time schedule is used to
/// perform a single-valued function of time. Use inherited 'type' attribute to
/// give additional information on this schedule, such as: periodic (hourly,
/// daily, weekly, monthly, etc.), day of the month, by date, calendar (specific
/// times and dates).
/// </summary>
[CimClass (ClassUri)]
public partial class TimeSchedule
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Document (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#TimeSchedule";

  /// <summary>
  /// Schedule date and time interval.
  /// </summary>
  public DateTimeInterval ? scheduleInterval
  {
    get => GetAttribute < DateTimeInterval ? > (nameof (scheduleInterval));
    set => SetAttribute (nameof (scheduleInterval), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class TorqueSpeedCurve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Curve (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#TorqueSpeedCurve";

  /// <summary>
  ///
  /// </summary>
  public AsynchronousMachine[] AsynchronousMachine => GetAssoc1ToM<
      AsynchronousMachine> (nameof (AsynchronousMachine));
  public void
  AddToAsynchronousMachine (AsynchronousMachine assocObject) => AddAssoc1ToM (
      nameof (AsynchronousMachine), assocObject);
  public void RemoveFromAsynchronousMachine (
      AsynchronousMachine
          assocObject) => RemoveAssoc1ToM (nameof (AsynchronousMachine),
                                           assocObject);
  public void RemoveAllFromAsynchronousMachine () => RemoveAllAssocs1ToM (
      nameof (AsynchronousMachine));
}
/// <summary>
/// Tower asset. Dimensions of the Tower are specified in associated
/// DimensionsInfo class.When used for planning purposes, a transmission tower
/// carrying two 3-phase circuits will have 2 instances of Connection, each of
/// which will have 3 MountingPoint instances, one for each phase all with
/// coordinates relative to a common origin on the tower. (It may also have a
/// 3rd Connection with a single MountingPoint for the Neutral line).
/// </summary>
[CimClass (ClassUri)]
public partial class Tower
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Structure (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#Tower";

  /// <summary>
  /// Construction structure on the tower.
  /// </summary>
  public TowerConstructionKind ? constructionKind
  {
    get => GetAttribute < TowerConstructionKind ? > (nameof (constructionKind));
    set => SetAttribute (nameof (constructionKind), value);
  }
  /// <summary>
  ///
  /// </summary>
  public string ? groundingMode
  {
    get => GetAttribute < string ? > (nameof (groundingMode));
    set => SetAttribute (nameof (groundingMode), value);
  }
}
/// <summary>
/// Town details, in the context of address.
/// </summary>
[CimClass (ClassUri)]
public partial class TownDetail
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#TownDetail";

  /// <summary>
  /// Town code.
  /// </summary>
  public string ? code
  {
    get => GetAttribute < string ? > (nameof (code));
    set => SetAttribute (nameof (code), value);
  }
  /// <summary>
  /// Name of the country.
  /// </summary>
  public string ? country
  {
    get => GetAttribute < string ? > (nameof (country));
    set => SetAttribute (nameof (country), value);
  }
  /// <summary>
  /// Town name.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }
  /// <summary>
  /// Town section. For example, it is common for there to be 36 sections per
  /// township.
  /// </summary>
  public string ? section
  {
    get => GetAttribute < string ? > (nameof (section));
    set => SetAttribute (nameof (section), value);
  }
  /// <summary>
  /// Name of the state or province.
  /// </summary>
  public string ? stateOrProvince
  {
    get => GetAttribute < string ? > (nameof (stateOrProvince));
    set => SetAttribute (nameof (stateOrProvince), value);
  }
}
/// <summary>
/// The transformer core admittance.  Used to specify the core admittance of a
/// transformer in a manner that can be shared among power transformers.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerCoreAdmittance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerCoreAdmittance";

  /// <summary>
  /// Magnetizing branch susceptance (B mag).  The value can be positive or
  /// negative.
  /// </summary>
  public float ? b
  {
    get => GetAttribute < float ? > (nameof (b));
    set => SetAttribute (nameof (b), value);
  }
  /// <summary>
  /// Zero sequence magnetizing branch susceptance.
  /// </summary>
  public float ? b0
  {
    get => GetAttribute < float ? > (nameof (b0));
    set => SetAttribute (nameof (b0), value);
  }
  /// <summary>
  /// Magnetizing branch conductance (G mag).
  /// </summary>
  public float ? g
  {
    get => GetAttribute < float ? > (nameof (g));
    set => SetAttribute (nameof (g), value);
  }
  /// <summary>
  ///
  /// </summary>
  public WindingConnection ? connectionKind
  {
    get => GetAttribute < WindingConnection ? > (nameof (connectionKind));
    set => SetAttribute (nameof (connectionKind), value);
  }

  /// <summary>
  /// Transformer end datasheet used to calculate this core admittance.
  /// </summary>
  public TransformerEndInfo ? TransformerEndInfo
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (TransformerEndInfo));
    set => SetAssoc1To1 (nameof (TransformerEndInfo), value);
  }

  /// <summary>
  /// All transformer ends having this core admittance.
  /// </summary>
  public TransformerEnd[] TransformerEnd => GetAssoc1ToM<TransformerEnd> (
      nameof (TransformerEnd));
  public void AddToTransformerEnd (TransformerEnd assocObject) => AddAssoc1ToM (
      nameof (TransformerEnd), assocObject);
  public void RemoveFromTransformerEnd (
      TransformerEnd assocObject) => RemoveAssoc1ToM (nameof (TransformerEnd),
                                                      assocObject);
  public void RemoveAllFromTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (TransformerEnd));
}
/// <summary>
/// A conducting connection point of a power transformer. It corresponds to a
/// physical transformer winding terminal.  In earlier CIM versions, the
/// TransformerWinding class served a similar purpose, but this class is more
/// flexible because it associates to terminal but is not a specialization of
/// ConductingEquipment.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerEnd
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#TransformerEnd";

  /// <summary>
  /// Number for this transformer end, corresponding to the end's order in the
  /// power transformer vector group or phase angle clock number.  Highest
  /// voltage winding should be 1.  Each end within a power transformer should
  /// have a unique subsequent end number.   Note the transformer end number
  /// need not match the terminal sequence number.
  /// </summary>
  public int ? endNumber
  {
    get => GetAttribute < int ? > (nameof (endNumber));
    set => SetAttribute (nameof (endNumber), value);
  }
  /// <summary>
  /// (for Yn and Zn connections) True if the neutral is solidly grounded.
  /// </summary>
  public bool ? grounded
  {
    get => GetAttribute < bool ? > (nameof (grounded));
    set => SetAttribute (nameof (grounded), value);
  }
  /// <summary>
  /// (for Yn and Zn connections) Resistance part of neutral impedance where
  /// 'grounded' is true.
  /// </summary>
  public float ? rground
  {
    get => GetAttribute < float ? > (nameof (rground));
    set => SetAttribute (nameof (rground), value);
  }
  /// <summary>
  /// (for Yn and Zn connections) Reactive part of neutral impedance where
  /// 'grounded' is true.
  /// </summary>
  public float ? xground
  {
    get => GetAttribute < float ? > (nameof (xground));
    set => SetAttribute (nameof (xground), value);
  }

  /// <summary>
  /// Base voltage of the transformer end.  This is essential for PU
  /// calculation.
  /// </summary>
  public BaseVoltage ? BaseVoltage
  {
    get => GetAssoc1To1<BaseVoltage> (nameof (BaseVoltage));
    set => SetAssoc1To1 (nameof (BaseVoltage), value);
  }
  /// <summary>
  /// Core admittance of this transformer end, representing magnetising current
  /// and core losses. The full values of the transformer should be supplied for
  /// one transformer end only.
  /// </summary>
  public TransformerCoreAdmittance ? CoreAdmittance
  {
    get => GetAssoc1To1<TransformerCoreAdmittance> (nameof (CoreAdmittance));
    set => SetAssoc1To1 (nameof (CoreAdmittance), value);
  }
  /// <summary>
  /// Phase tap changer associated with this transformer end.
  /// </summary>
  public PhaseTapChanger ? PhaseTapChanger
  {
    get => GetAssoc1To1<PhaseTapChanger> (nameof (PhaseTapChanger));
    set => SetAssoc1To1 (nameof (PhaseTapChanger), value);
  }
  /// <summary>
  /// Ratio tap changer associated with this transformer end.
  /// </summary>
  public RatioTapChanger ? RatioTapChanger
  {
    get => GetAssoc1To1<RatioTapChanger> (nameof (RatioTapChanger));
    set => SetAssoc1To1 (nameof (RatioTapChanger), value);
  }
  /// <summary>
  /// (accurate for 2- or 3-winding transformers only) Pi-model impedances of
  /// this transformer end. By convention, for a two winding transformer, the
  /// full values of the transformer should be entered on the high voltage end
  /// (endNumber=1).
  /// </summary>
  public TransformerStarImpedance ? StarImpedance
  {
    get => GetAssoc1To1<TransformerStarImpedance> (nameof (StarImpedance));
    set => SetAssoc1To1 (nameof (StarImpedance), value);
  }
  /// <summary>
  /// Terminal of the power transformer to which this transformer end belongs.
  /// </summary>
  public Terminal ? Terminal
  {
    get => GetAssoc1To1<Terminal> (nameof (Terminal));
    set => SetAssoc1To1 (nameof (Terminal), value);
  }

  /// <summary>
  /// All mesh impedances between this 'to' and other 'from' transformer ends.
  /// </summary>
  public TransformerMeshImpedance[] FromMeshImpedance => GetAssoc1ToM<
      TransformerMeshImpedance> (nameof (FromMeshImpedance));
  public void AddToFromMeshImpedance (
      TransformerMeshImpedance
          assocObject) => AddAssoc1ToM (nameof (FromMeshImpedance),
                                        assocObject);
  public void RemoveFromFromMeshImpedance (
      TransformerMeshImpedance
          assocObject) => RemoveAssoc1ToM (nameof (FromMeshImpedance),
                                           assocObject);
  public void RemoveAllFromFromMeshImpedance () => RemoveAllAssocs1ToM (
      nameof (FromMeshImpedance));
  /// <summary>
  /// All mesh impedances between this 'from' and other 'to' transformer ends.
  /// </summary>
  public TransformerMeshImpedance[] ToMeshImpedance => GetAssoc1ToM<
      TransformerMeshImpedance> (nameof (ToMeshImpedance));
  public void
  AddToToMeshImpedance (TransformerMeshImpedance assocObject) => AddAssoc1ToM (
      nameof (ToMeshImpedance), assocObject);
  public void RemoveFromToMeshImpedance (
      TransformerMeshImpedance
          assocObject) => RemoveAssoc1ToM (nameof (ToMeshImpedance),
                                           assocObject);
  public void RemoveAllFromToMeshImpedance () => RemoveAllAssocs1ToM (
      nameof (ToMeshImpedance));
}
/// <summary>
/// Transformer end data.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerEndInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerEndInfo";

  /// <summary>
  /// Number for this transformer end, corresponding to the end's order in the
  /// PowerTransformer.vectorGroup attribute. Highest voltage winding should
  /// be 1.
  /// </summary>
  public int ? endNumber
  {
    get => GetAttribute < int ? > (nameof (endNumber));
    set => SetAttribute (nameof (endNumber), value);
  }
  /// <summary>
  /// Rated voltage: phase-phase for three-phase windings, and either
  /// phase-phase or phase-neutral for single-phase windings.
  /// </summary>
  public float ? ratedU
  {
    get => GetAttribute < float ? > (nameof (ratedU));
    set => SetAttribute (nameof (ratedU), value);
  }

  /// <summary>
  /// Core admittance calculated from this transformer end datasheet,
  /// representing magnetising current and core losses. The full values of the
  /// transformer should be supplied for one transformer end info only.
  /// </summary>
  public TransformerCoreAdmittance ? CoreAdmittance
  {
    get => GetAssoc1To1<TransformerCoreAdmittance> (nameof (CoreAdmittance));
    set => SetAssoc1To1 (nameof (CoreAdmittance), value);
  }
  /// <summary>
  /// Transformer star impedance calculated from this transformer end datasheet.
  /// </summary>
  public TransformerStarImpedance ? TransformerStarImpedance
  {
    get => GetAssoc1To1<TransformerStarImpedance> (
        nameof (TransformerStarImpedance));
    set => SetAssoc1To1 (nameof (TransformerStarImpedance), value);
  }
  /// <summary>
  /// Transformer tank data that this end description is part of.
  /// </summary>
  public TransformerTankInfo ? TransformerTankInfo
  {
    get => GetAssoc1To1<TransformerTankInfo> (nameof (TransformerTankInfo));
    set => SetAssoc1To1 (nameof (TransformerTankInfo), value);
  }

  /// <summary>
  /// All no-load test measurements in which this transformer end was energised.
  /// </summary>
  public NoLoadTest[] EnergisedEndNoLoadTests => GetAssoc1ToM<NoLoadTest> (
      nameof (EnergisedEndNoLoadTests));
  public void AddToEnergisedEndNoLoadTests (
      NoLoadTest assocObject) => AddAssoc1ToM (nameof (EnergisedEndNoLoadTests),
                                               assocObject);
  public void RemoveFromEnergisedEndNoLoadTests (
      NoLoadTest
          assocObject) => RemoveAssoc1ToM (nameof (EnergisedEndNoLoadTests),
                                           assocObject);
  public void RemoveAllFromEnergisedEndNoLoadTests () => RemoveAllAssocs1ToM (
      nameof (EnergisedEndNoLoadTests));
  /// <summary>
  /// All short-circuit test measurements in which this transformer end was
  /// energised.
  /// </summary>
  public ShortCircuitTest[] EnergisedEndShortCircuitTests => GetAssoc1ToM<
      ShortCircuitTest> (nameof (EnergisedEndShortCircuitTests));
  public void AddToEnergisedEndShortCircuitTests (
      ShortCircuitTest
          assocObject) => AddAssoc1ToM (nameof (EnergisedEndShortCircuitTests),
                                        assocObject);
  public void RemoveFromEnergisedEndShortCircuitTests (
      ShortCircuitTest
          assocObject) => RemoveAssoc1ToM (nameof (EnergisedEndShortCircuitTests),
                                           assocObject);
  public void
  RemoveAllFromEnergisedEndShortCircuitTests () => RemoveAllAssocs1ToM (
      nameof (EnergisedEndShortCircuitTests));
  /// <summary>
  /// All short-circuit test measurements in which this transformer end was
  /// short-circuited.
  /// </summary>
  public ShortCircuitTest[] GroundedEndShortCircuitTests => GetAssoc1ToM<
      ShortCircuitTest> (nameof (GroundedEndShortCircuitTests));
  public void AddToGroundedEndShortCircuitTests (
      ShortCircuitTest
          assocObject) => AddAssoc1ToM (nameof (GroundedEndShortCircuitTests),
                                        assocObject);
  public void RemoveFromGroundedEndShortCircuitTests (
      ShortCircuitTest
          assocObject) => RemoveAssoc1ToM (nameof (GroundedEndShortCircuitTests),
                                           assocObject);
  public void
  RemoveAllFromGroundedEndShortCircuitTests () => RemoveAllAssocs1ToM (
      nameof (GroundedEndShortCircuitTests));
  /// <summary>
  ///
  /// </summary>
  public PowerTransformerEnd[] PowerTransformerEnd => GetAssoc1ToM<
      PowerTransformerEnd> (nameof (PowerTransformerEnd));
  public void
  AddToPowerTransformerEnd (PowerTransformerEnd assocObject) => AddAssoc1ToM (
      nameof (PowerTransformerEnd), assocObject);
  public void RemoveFromPowerTransformerEnd (
      PowerTransformerEnd
          assocObject) => RemoveAssoc1ToM (nameof (PowerTransformerEnd),
                                           assocObject);
  public void RemoveAllFromPowerTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (PowerTransformerEnd));
  /// <summary>
  ///
  /// </summary>
  public StabilizingWinding[] StabilizingWindings => GetAssoc1ToM<
      StabilizingWinding> (nameof (StabilizingWindings));
  public void
  AddToStabilizingWindings (StabilizingWinding assocObject) => AddAssoc1ToM (
      nameof (StabilizingWindings), assocObject);
  public void RemoveFromStabilizingWindings (
      StabilizingWinding
          assocObject) => RemoveAssoc1ToM (nameof (StabilizingWindings),
                                           assocObject);
  public void RemoveAllFromStabilizingWindings () => RemoveAllAssocs1ToM (
      nameof (StabilizingWindings));
}
/// <summary>
/// Transformer mesh impedance (Delta-model) between transformer ends.The
/// typical case is that this class describes the impedance between two
/// transformer ends pair-wise, i.e. the cardinalities at both transformer end
/// associations are 1. However, in cases where two or more transformer ends are
/// modelled the cardinalities are larger than 1.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerMeshImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerMeshImpedance";

  /// <summary>
  /// Resistance between the 'from' and the 'to' end, seen from the 'from' end.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero-sequence resistance between the 'from' and the 'to' end, seen from
  /// the 'from' end.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Reactance between the 'from' and the 'to' end, seen from the 'from' end.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero-sequence reactance between the 'from' and the 'to' end, seen from the
  /// 'from' end.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  /// From end this mesh impedance is connected to. It determines the voltage
  /// reference.
  /// </summary>
  public TransformerEnd ? FromTransformerEnd
  {
    get => GetAssoc1To1<TransformerEnd> (nameof (FromTransformerEnd));
    set => SetAssoc1To1 (nameof (FromTransformerEnd), value);
  }

  /// <summary>
  /// All transformer ends this mesh impedance is connected to.
  /// </summary>
  public TransformerEnd[] ToTransformerEnd => GetAssoc1ToM<TransformerEnd> (
      nameof (ToTransformerEnd));
  public void AddToToTransformerEnd (
      TransformerEnd assocObject) => AddAssoc1ToM (nameof (ToTransformerEnd),
                                                   assocObject);
  public void RemoveFromToTransformerEnd (
      TransformerEnd assocObject) => RemoveAssoc1ToM (nameof (ToTransformerEnd),
                                                      assocObject);
  public void RemoveAllFromToTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (ToTransformerEnd));
}
/// <summary>
/// Transformer star impedance (Pi-model) that accurately reflects impedance for
/// transformers with 2 or 3 windings. For transformers with 4 or more windings,
/// TransformerMeshImpedance class shall be used.For transmission networks use
/// PowerTransformerEnd impedances (r, r0, x, x0, b, b0, g and g0).
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerStarImpedance
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerStarImpedance";

  /// <summary>
  /// Resistance of the transformer end.
  /// </summary>
  public float ? r
  {
    get => GetAttribute < float ? > (nameof (r));
    set => SetAttribute (nameof (r), value);
  }
  /// <summary>
  /// Zero sequence series resistance of the transformer end.
  /// </summary>
  public float ? r0
  {
    get => GetAttribute < float ? > (nameof (r0));
    set => SetAttribute (nameof (r0), value);
  }
  /// <summary>
  /// Positive sequence series reactance of the transformer end.
  /// </summary>
  public float ? x
  {
    get => GetAttribute < float ? > (nameof (x));
    set => SetAttribute (nameof (x), value);
  }
  /// <summary>
  /// Zero sequence series reactance of the transformer end.
  /// </summary>
  public float ? x0
  {
    get => GetAttribute < float ? > (nameof (x0));
    set => SetAttribute (nameof (x0), value);
  }

  /// <summary>
  /// Transformer end datasheet used to calculate this transformer star
  /// impedance.
  /// </summary>
  public TransformerEndInfo ? TransformerEndInfo
  {
    get => GetAssoc1To1<TransformerEndInfo> (nameof (TransformerEndInfo));
    set => SetAssoc1To1 (nameof (TransformerEndInfo), value);
  }

  /// <summary>
  /// All transformer ends having this star impedance.
  /// </summary>
  public TransformerEnd[] TransformerEnd => GetAssoc1ToM<TransformerEnd> (
      nameof (TransformerEnd));
  public void AddToTransformerEnd (TransformerEnd assocObject) => AddAssoc1ToM (
      nameof (TransformerEnd), assocObject);
  public void RemoveFromTransformerEnd (
      TransformerEnd assocObject) => RemoveAssoc1ToM (nameof (TransformerEnd),
                                                      assocObject);
  public void RemoveAllFromTransformerEnd () => RemoveAllAssocs1ToM (
      nameof (TransformerEnd));
}
/// <summary>
/// An assembly of two or more coupled windings that transform electrical power
/// between voltage levels. These windings are bound on a common core and placed
/// in the same tank. Transformer tank can be used to model both single-phase
/// and 3-phase transformers.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerTank
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Equipment (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerTank";

  /// <summary>
  /// Bank this transformer belongs to.
  /// </summary>
  public PowerTransformer ? PowerTransformer
  {
    get => GetAssoc1To1<PowerTransformer> (nameof (PowerTransformer));
    set => SetAssoc1To1 (nameof (PowerTransformer), value);
  }
}
/// <summary>
/// Set of transformer tank data, from an equipment library.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerTankInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerTankInfo";

  /// <summary>
  ///
  /// </summary>
  public CoolingKind ? coolingKind
  {
    get => GetAttribute < CoolingKind ? > (nameof (coolingKind));
    set => SetAttribute (nameof (coolingKind), value);
  }

  /// <summary>
  /// Data for all the ends described by this transformer tank data.
  /// </summary>
  public TransformerEndInfo[] TransformerEndInfos => GetAssoc1ToM<
      TransformerEndInfo> (nameof (TransformerEndInfos));
  public void
  AddToTransformerEndInfos (TransformerEndInfo assocObject) => AddAssoc1ToM (
      nameof (TransformerEndInfos), assocObject);
  public void RemoveFromTransformerEndInfos (
      TransformerEndInfo
          assocObject) => RemoveAssoc1ToM (nameof (TransformerEndInfos),
                                           assocObject);
  public void RemoveAllFromTransformerEndInfos () => RemoveAllAssocs1ToM (
      nameof (TransformerEndInfos));
}
/// <summary>
/// Test result for transformer ends, such as short-circuit, open-circuit
/// (excitation) or no-load test.
/// </summary>
[CimClass (ClassUri)]
public partial class TransformerTest
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#TransformerTest";

  /// <summary>
  /// Base power at which the tests are conducted, usually equal to the rateds
  /// of one of the involved transformer ends.
  /// </summary>
  public float ? basePower
  {
    get => GetAttribute < float ? > (nameof (basePower));
    set => SetAttribute (nameof (basePower), value);
  }
  /// <summary>
  /// Temperature at which the test is conducted.
  /// </summary>
  public float ? temperature
  {
    get => GetAttribute < float ? > (nameof (temperature));
    set => SetAttribute (nameof (temperature), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class TurbineRegulatinglnfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#TurbineRegulatinglnfo";

  /// <summary>
  ///
  /// </summary>
  public bool ? fastValvingControl
  {
    get => GetAttribute < bool ? > (nameof (fastValvingControl));
    set => SetAttribute (nameof (fastValvingControl), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fastValvingControlBlockTime
  {
    get => GetAttribute < float ? > (nameof (fastValvingControlBlockTime));
    set => SetAttribute (nameof (fastValvingControlBlockTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fastValvingControlDelay
  {
    get => GetAttribute < float ? > (nameof (fastValvingControlDelay));
    set => SetAttribute (nameof (fastValvingControlDelay), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fastValvingControlRampRate
  {
    get => GetAttribute < float ? > (nameof (fastValvingControlRampRate));
    set => SetAttribute (nameof (fastValvingControlRampRate), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fastValvingControlRate
  {
    get => GetAttribute < float ? > (nameof (fastValvingControlRate));
    set => SetAttribute (nameof (fastValvingControlRate), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? fastValvingControlRestoreTime
  {
    get => GetAttribute < float ? > (nameof (fastValvingControlRestoreTime));
    set => SetAttribute (nameof (fastValvingControlRestoreTime), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? freqControlDeadband
  {
    get => GetAttribute < float ? > (nameof (freqControlDeadband));
    set => SetAttribute (nameof (freqControlDeadband), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyCorrectorDeadband
  {
    get => GetAttribute < float ? > (nameof (frequencyCorrectorDeadband));
    set => SetAttribute (nameof (frequencyCorrectorDeadband), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? frequencyCorrectorSCD
  {
    get => GetAttribute < float ? > (nameof (frequencyCorrectorSCD));
    set => SetAttribute (nameof (frequencyCorrectorSCD), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? sustainedFastValvingControlRampRate
  {
    get => GetAttribute < float
        ? > (nameof (sustainedFastValvingControlRampRate));
    set => SetAttribute (nameof (sustainedFastValvingControlRampRate), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? sustainedFastValvingControlRate
  {
    get => GetAttribute < float ? > (nameof (sustainedFastValvingControlRate));
    set => SetAttribute (nameof (sustainedFastValvingControlRate), value);
  }
}
/// <summary>
/// Underground structure.
/// </summary>
[CimClass (ClassUri)]
public partial class UndergroundStructure
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Structure (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#UndergroundStructure";

  /// <summary>
  /// True if vault is ventilating.
  /// </summary>
  public UndergroundStructureKind ? kind
  {
    get => GetAttribute < UndergroundStructureKind ? > (nameof (kind));
    set => SetAttribute (nameof (kind), value);
  }
  /// <summary>
  /// Primary material of underground structure.
  /// </summary>
  public string ? material
  {
    get => GetAttribute < string ? > (nameof (material));
    set => SetAttribute (nameof (material), value);
  }
}
/// <summary>
/// Logical or physical point in the network to which readings or events may be
/// attributed. Used at the place where a physical or virtual meter may be
/// located; however, it is not required that a meter be present.
/// </summary>
[CimClass (ClassUri)]
public partial class UsagePoint
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#UsagePoint";

  /// <summary>
  /// Tracks the lifecycle of the metering installation at a usage point with
  /// respect to readiness for billing via advanced metering infrastructure
  /// reads.
  /// </summary>
  public AmiBillingReadyKind ? amiBillingReady
  {
    get => GetAttribute < AmiBillingReadyKind ? > (nameof (amiBillingReady));
    set => SetAttribute (nameof (amiBillingReady), value);
  }
  /// <summary>
  /// True if as a result of an inspection or otherwise, there is a reason to
  /// suspect that a previous billing may have been performed with erroneous
  /// data. Value should be reset once this potential discrepancy has been
  /// resolved.
  /// </summary>
  public bool ? checkBilling
  {
    get => GetAttribute < bool ? > (nameof (checkBilling));
    set => SetAttribute (nameof (checkBilling), value);
  }
  /// <summary>
  /// State of the usage point with respect to connection to the network.
  /// </summary>
  public UsagePointConnectedKind ? connectionState
  {
    get => GetAttribute < UsagePointConnectedKind
        ? > (nameof (connectionState));
    set => SetAttribute (nameof (connectionState), value);
  }
  /// <summary>
  /// Estimated load.
  /// </summary>
  public float ? estimatedLoad
  {
    get => GetAttribute < float ? > (nameof (estimatedLoad));
    set => SetAttribute (nameof (estimatedLoad), value);
  }
  /// <summary>
  /// True if grounded.
  /// </summary>
  public bool ? grounded
  {
    get => GetAttribute < bool ? > (nameof (grounded));
    set => SetAttribute (nameof (grounded), value);
  }
  /// <summary>
  /// If true, this usage point is a service delivery point, i.e., a usage point
  /// where the ownership of the service changes hands.
  /// </summary>
  public bool ? isSdp
  {
    get => GetAttribute < bool ? > (nameof (isSdp));
    set => SetAttribute (nameof (isSdp), value);
  }
  /// <summary>
  /// If true, this usage point is virtual, i.e., no physical location exists in
  /// the network where a meter could be located to collect the meter readings.
  /// For example, one may define a virtual usage point to serve as an
  /// aggregation of usage for all of a company's premises distributed widely
  /// across the distribution territory. Otherwise, the usage point is physical,
  /// i.e., there is a logical point in the network where a meter could be
  /// located to collect meter readings.
  /// </summary>
  public bool ? isVirtual
  {
    get => GetAttribute < bool ? > (nameof (isVirtual));
    set => SetAttribute (nameof (isVirtual), value);
  }
  /// <summary>
  /// If true, minimal or zero usage is expected at this usage point for
  /// situations such as premises vacancy, logical or physical disconnect. It is
  /// used for readings validation and estimation.
  /// </summary>
  public bool ? minimalUsageExpected
  {
    get => GetAttribute < bool ? > (nameof (minimalUsageExpected));
    set => SetAttribute (nameof (minimalUsageExpected), value);
  }
  /// <summary>
  /// Nominal service voltage.
  /// </summary>
  public float ? nominalServiceVoltage
  {
    get => GetAttribute < float ? > (nameof (nominalServiceVoltage));
    set => SetAttribute (nameof (nominalServiceVoltage), value);
  }
  /// <summary>
  /// Outage region in which this usage point is located.
  /// </summary>
  public string ? outageRegion
  {
    get => GetAttribute < string ? > (nameof (outageRegion));
    set => SetAttribute (nameof (outageRegion), value);
  }
  /// <summary>
  /// Phase code. Number of wires and specific nominal phases can be deduced
  /// from enumeration literal values. For example, ABCN is three-phase,
  /// four-wire, s12n (splitSecondary12N) is single-phase, three-wire, and s1n
  /// and s2n are single-phase, two-wire.
  /// </summary>
  public PhaseCode ? phaseCode
  {
    get => GetAttribute < PhaseCode ? > (nameof (phaseCode));
    set => SetAttribute (nameof (phaseCode), value);
  }
  /// <summary>
  /// Current flow that this usage point is configured to deliver.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Active power that this usage point is configured to deliver.
  /// </summary>
  public float ? ratedPower
  {
    get => GetAttribute < float ? > (nameof (ratedPower));
    set => SetAttribute (nameof (ratedPower), value);
  }
  /// <summary>
  /// Cycle day on which the meter for this usage point will normally be read.
  /// Usually correlated with the billing cycle.
  /// </summary>
  public string ? readCycle
  {
    get => GetAttribute < string ? > (nameof (readCycle));
    set => SetAttribute (nameof (readCycle), value);
  }
  /// <summary>
  /// Identifier of the route to which this usage point is assigned for purposes
  /// of meter reading. Typically used to configure hand held meter reading
  /// systems prior to collection of reads.
  /// </summary>
  public string ? readRoute
  {
    get => GetAttribute < string ? > (nameof (readRoute));
    set => SetAttribute (nameof (readRoute), value);
  }
  /// <summary>
  /// Remarks about this usage point, for example the reason for it being rated
  /// with a non-nominal priority.
  /// </summary>
  public string ? serviceDeliveryRemark
  {
    get => GetAttribute < string ? > (nameof (serviceDeliveryRemark));
    set => SetAttribute (nameof (serviceDeliveryRemark), value);
  }
  /// <summary>
  /// Priority of service for this usage point. Note that usage points at the
  /// same service location can have different priorities.
  /// </summary>
  public string ? servicePriority
  {
    get => GetAttribute < string ? > (nameof (servicePriority));
    set => SetAttribute (nameof (servicePriority), value);
  }

  /// <summary>
  /// Customer agreement regulating this service delivery point.
  /// </summary>
  public CustomerAgreement ? CustomerAgreement
  {
    get => GetAssoc1To1<CustomerAgreement> (nameof (CustomerAgreement));
    set => SetAssoc1To1 (nameof (CustomerAgreement), value);
  }
  /// <summary>
  /// Service category delivered by this usage point.
  /// </summary>
  public ServiceCategory ? ServiceCategory
  {
    get => GetAssoc1To1<ServiceCategory> (nameof (ServiceCategory));
    set => SetAssoc1To1 (nameof (ServiceCategory), value);
  }
  /// <summary>
  /// Service location where the service delivered by this usage point is
  /// consumed.
  /// </summary>
  public ServiceLocation ? ServiceLocation
  {
    get => GetAssoc1To1<ServiceLocation> (nameof (ServiceLocation));
    set => SetAssoc1To1 (nameof (ServiceLocation), value);
  }
  /// <summary>
  /// ServiceSupplier (utility) utilising this usage point to deliver a service.
  /// </summary>
  public ServiceSupplier ? ServiceSupplier
  {
    get => GetAssoc1To1<ServiceSupplier> (nameof (ServiceSupplier));
    set => SetAssoc1To1 (nameof (ServiceSupplier), value);
  }
  /// <summary>
  /// Location of this usage point.
  /// </summary>
  public UsagePointLocation ? UsagePointLocation
  {
    get => GetAssoc1To1<UsagePointLocation> (nameof (UsagePointLocation));
    set => SetAssoc1To1 (nameof (UsagePointLocation), value);
  }

  /// <summary>
  /// All configuration events created for this usage point.
  /// </summary>
  public ConfigurationEvent[] ConfigurationEvents => GetAssoc1ToM<
      ConfigurationEvent> (nameof (ConfigurationEvents));
  public void
  AddToConfigurationEvents (ConfigurationEvent assocObject) => AddAssoc1ToM (
      nameof (ConfigurationEvents), assocObject);
  public void RemoveFromConfigurationEvents (
      ConfigurationEvent
          assocObject) => RemoveAssoc1ToM (nameof (ConfigurationEvents),
                                           assocObject);
  public void RemoveAllFromConfigurationEvents () => RemoveAllAssocs1ToM (
      nameof (ConfigurationEvents));
  /// <summary>
  /// All end devices at this usage point.
  /// </summary>
  public EndDevice[] EndDevices => GetAssoc1ToM<EndDevice> (
      nameof (EndDevices));
  public void AddToEndDevices (EndDevice assocObject) => AddAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveFromEndDevices (EndDevice assocObject) => RemoveAssoc1ToM (
      nameof (EndDevices), assocObject);
  public void RemoveAllFromEndDevices () => RemoveAllAssocs1ToM (
      nameof (EndDevices));
  /// <summary>
  /// All equipment connecting this usage point to the electrical grid.
  /// </summary>
  public Equipment[] Equipments => GetAssoc1ToM<Equipment> (
      nameof (Equipments));
  public void AddToEquipments (Equipment assocObject) => AddAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveFromEquipments (Equipment assocObject) => RemoveAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveAllFromEquipments () => RemoveAllAssocs1ToM (
      nameof (Equipments));
  /// <summary>
  /// All metrology requirements for this usage point.
  /// </summary>
  public MetrologyRequirement[] MetrologyRequirements => GetAssoc1ToM<
      MetrologyRequirement> (nameof (MetrologyRequirements));
  public void AddToMetrologyRequirements (
      MetrologyRequirement
          assocObject) => AddAssoc1ToM (nameof (MetrologyRequirements),
                                        assocObject);
  public void RemoveFromMetrologyRequirements (
      MetrologyRequirement
          assocObject) => RemoveAssoc1ToM (nameof (MetrologyRequirements),
                                           assocObject);
  public void RemoveAllFromMetrologyRequirements () => RemoveAllAssocs1ToM (
      nameof (MetrologyRequirements));
  /// <summary>
  /// All pricing structures applicable to this service delivery point (with
  /// prepayment meter running as a stand-alone device, with no
  /// CustomerAgreement or Customer).
  /// </summary>
  public PricingStructure[] PricingStructures => GetAssoc1ToM<
      PricingStructure> (nameof (PricingStructures));
  public void AddToPricingStructures (
      PricingStructure assocObject) => AddAssoc1ToM (nameof (PricingStructures),
                                                     assocObject);
  public void RemoveFromPricingStructures (
      PricingStructure
          assocObject) => RemoveAssoc1ToM (nameof (PricingStructures),
                                           assocObject);
  public void RemoveAllFromPricingStructures () => RemoveAllAssocs1ToM (
      nameof (PricingStructures));
  /// <summary>
  /// All multipliers applied at this usage point.
  /// </summary>
  public ServiceMultiplier[] ServiceMultipliers => GetAssoc1ToM<
      ServiceMultiplier> (nameof (ServiceMultipliers));
  public void
  AddToServiceMultipliers (ServiceMultiplier assocObject) => AddAssoc1ToM (
      nameof (ServiceMultipliers), assocObject);
  public void RemoveFromServiceMultipliers (
      ServiceMultiplier
          assocObject) => RemoveAssoc1ToM (nameof (ServiceMultipliers),
                                           assocObject);
  public void RemoveAllFromServiceMultipliers () => RemoveAllAssocs1ToM (
      nameof (ServiceMultipliers));
}
/// <summary>
/// Location of an individual usage point.
/// </summary>
[CimClass (ClassUri)]
public partial class UsagePointLocation
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Location (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#UsagePointLocation";

  /// <summary>
  /// Method for the service person to access this usage point location. For
  /// example, a description of where to obtain a key if the facility is
  /// unmanned and secured.
  /// </summary>
  public string ? accessMethod
  {
    get => GetAttribute < string ? > (nameof (accessMethod));
    set => SetAttribute (nameof (accessMethod), value);
  }
  /// <summary>
  /// Remarks about this location.
  /// </summary>
  public string ? remark
  {
    get => GetAttribute < string ? > (nameof (remark));
    set => SetAttribute (nameof (remark), value);
  }
  /// <summary>
  /// Problems previously encountered when visiting or performing work at this
  /// location. Examples include: bad dog, violent customer, verbally abusive
  /// occupant, obstructions, safety hazards, etc.
  /// </summary>
  public string ? siteAccessProblem
  {
    get => GetAttribute < string ? > (nameof (siteAccessProblem));
    set => SetAttribute (nameof (siteAccessProblem), value);
  }

  /// <summary>
  /// All usage points at this location.
  /// </summary>
  public UsagePoint[] UsagePoints => GetAssoc1ToM<UsagePoint> (
      nameof (UsagePoints));
  public void AddToUsagePoints (UsagePoint assocObject) => AddAssoc1ToM (
      nameof (UsagePoints), assocObject);
  public void RemoveFromUsagePoints (
      UsagePoint assocObject) => RemoveAssoc1ToM (nameof (UsagePoints),
                                                  assocObject);
  public void RemoveAllFromUsagePoints () => RemoveAllAssocs1ToM (
      nameof (UsagePoints));
}
/// <summary>
/// Generic name-value pair class, with optional sequence number and units for
/// value; can be used to model parts of information exchange when concrete
/// types are not known in advance.
/// </summary>
[CimClass (ClassUri)]
public partial class UserAttribute
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#UserAttribute";

  /// <summary>
  /// Name of an attribute.
  /// </summary>
  public string ? name
  {
    get => GetAttribute < string ? > (nameof (name));
    set => SetAttribute (nameof (name), value);
  }
  /// <summary>
  /// Sequence number for this attribute in a list of attributes.
  /// </summary>
  public int ? sequenceNumber
  {
    get => GetAttribute < int ? > (nameof (sequenceNumber));
    set => SetAttribute (nameof (sequenceNumber), value);
  }
  /// <summary>
  /// Value of an attribute, including unit information.
  /// </summary>
  public StringQuantity ? value
  {
    get => GetAttribute < StringQuantity ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
/// A collection of equipment at one common system voltage forming a switchgear.
/// The equipment typically consists of breakers, busbars, instrumentation,
/// control, regulation and protection devices as well as assemblies of all
/// these.
/// </summary>
[CimClass (ClassUri)]
public partial class VoltageLevel
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : EquipmentContainer (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#VoltageLevel";

  /// <summary>
  /// The base voltage used for all equipment within the voltage level.
  /// </summary>
  public BaseVoltage ? BaseVoltage
  {
    get => GetAssoc1To1<BaseVoltage> (nameof (BaseVoltage));
    set => SetAssoc1To1 (nameof (BaseVoltage), value);
  }
  /// <summary>
  /// The substation of the voltage level.
  /// </summary>
  public Substation ? Substation
  {
    get => GetAssoc1To1<Substation> (nameof (Substation));
    set => SetAssoc1To1 (nameof (Substation), value);
  }

  /// <summary>
  /// The bays within this voltage level.
  /// </summary>
  public Bay[] Bays => GetAssoc1ToM<Bay> (nameof (Bays));
  public void AddToBays (Bay assocObject) => AddAssoc1ToM (nameof (Bays),
                                                           assocObject);
  public void RemoveFromBays (Bay assocObject) => RemoveAssoc1ToM (
      nameof (Bays), assocObject);
  public void RemoveAllFromBays () => RemoveAllAssocs1ToM (nameof (Bays));
}
/// <summary>
/// Operational limit applied to voltage.The use of operational VoltageLimit is
/// preferred instead of limits defined at VoltageLevel. The operational
/// VoltageLimits are used, if present.
/// </summary>
[CimClass (ClassUri)]
public partial class VoltageLimit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : OperationalLimit (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#VoltageLimit";

  /// <summary>
  /// The normal limit on voltage. High or low limit nature of the limit depends
  /// upon the properties of the operational limit type. The attribute shall be
  /// a positive value or zero.
  /// </summary>
  public float ? normalValue
  {
    get => GetAttribute < float ? > (nameof (normalValue));
    set => SetAttribute (nameof (normalValue), value);
  }
  /// <summary>
  /// Limit on voltage. High or low limit nature of the limit depends upon the
  /// properties of the operational limit type. The attribute shall be a
  /// positive value or zero.
  /// </summary>
  public float ? value
  {
    get => GetAttribute < float ? > (nameof (value));
    set => SetAttribute (nameof (value), value);
  }
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class VoltageLimitDurationCurve
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Curve (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#VoltageLimitDurationCurve";

  /// <summary>
  ///
  /// </summary>
  public Equipment[] Equipments => GetAssoc1ToM<Equipment> (
      nameof (Equipments));
  public void AddToEquipments (Equipment assocObject) => AddAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveFromEquipments (Equipment assocObject) => RemoveAssoc1ToM (
      nameof (Equipments), assocObject);
  public void RemoveAllFromEquipments () => RemoveAllAssocs1ToM (
      nameof (Equipments));
}
/// <summary>
/// Line traps are devices that impede high frequency power line carrier signals
/// yet present a negligible impedance at the main power frequency.
/// </summary>
[CimClass (ClassUri)]
public partial class WaveTrap
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AuxiliaryEquipment (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#WaveTrap";

  /// <summary>
  ///
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
}
/// <summary>
/// A wind driven generating unit, connected to the grid by means of a rotating
/// machine.  May be used to represent a single turbine or an aggregation.
/// </summary>
[CimClass (ClassUri)]
public partial class WindGeneratingUnit
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : GeneratingUnit (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#WindGeneratingUnit";
}
/// <summary>
///
/// </summary>
[CimClass (ClassUri)]
public partial class WindTurbine
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : PrimeMover (oid, metaClass)
{
  public new const string ClassUri
      = "http://gost.ru/2019/schema-cim01#WindTurbine";
}
/// <summary>
/// Describes the construction of a multi-conductor wire.
/// </summary>
[CimClass (ClassUri)]
public partial class WireAssemblyInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#WireAssemblyInfo";

  /// <summary>
  /// Per length line parameter associated with this wire assembly.
  /// </summary>
  public PerLengthLineParameter[] PerLengthLineParameter => GetAssoc1ToM<
      PerLengthLineParameter> (nameof (PerLengthLineParameter));
  public void AddToPerLengthLineParameter (
      PerLengthLineParameter
          assocObject) => AddAssoc1ToM (nameof (PerLengthLineParameter),
                                        assocObject);
  public void RemoveFromPerLengthLineParameter (
      PerLengthLineParameter
          assocObject) => RemoveAssoc1ToM (nameof (PerLengthLineParameter),
                                           assocObject);
  public void RemoveAllFromPerLengthLineParameter () => RemoveAllAssocs1ToM (
      nameof (PerLengthLineParameter));
  /// <summary>
  /// Wire phase information associated with this wire assembly.
  /// </summary>
  public WirePhaseInfo[] WirePhaseInfo => GetAssoc1ToM<WirePhaseInfo> (
      nameof (WirePhaseInfo));
  public void AddToWirePhaseInfo (WirePhaseInfo assocObject) => AddAssoc1ToM (
      nameof (WirePhaseInfo), assocObject);
  public void RemoveFromWirePhaseInfo (
      WirePhaseInfo assocObject) => RemoveAssoc1ToM (nameof (WirePhaseInfo),
                                                     assocObject);
  public void RemoveAllFromWirePhaseInfo () => RemoveAllAssocs1ToM (
      nameof (WirePhaseInfo));
}
/// <summary>
/// Wire data that can be specified per line segment phase, or for the line
/// segment as a whole in case its phases all have the same wire
/// characteristics.
/// </summary>
[CimClass (ClassUri)]
public partial class WireInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#WireInfo";

  /// <summary>
  /// (if there is a different core material) Radius of the central core.
  /// </summary>
  public float ? coreRadius
  {
    get => GetAttribute < float ? > (nameof (coreRadius));
    set => SetAttribute (nameof (coreRadius), value);
  }
  /// <summary>
  /// True if conductor is insulated.
  /// </summary>
  public bool ? insulated
  {
    get => GetAttribute < bool ? > (nameof (insulated));
    set => SetAttribute (nameof (insulated), value);
  }
  /// <summary>
  /// (if insulated conductor) Material used for insulation.
  /// </summary>
  public WireInsulationKind ? insulationMaterial
  {
    get => GetAttribute < WireInsulationKind ? > (nameof (insulationMaterial));
    set => SetAttribute (nameof (insulationMaterial), value);
  }
  /// <summary>
  /// (if insulated conductor) Thickness of the insulation.
  /// </summary>
  public float ? insulationThickness
  {
    get => GetAttribute < float ? > (nameof (insulationThickness));
    set => SetAttribute (nameof (insulationThickness), value);
  }
  /// <summary>
  /// Conductor material.
  /// </summary>
  public WireMaterialKind ? material
  {
    get => GetAttribute < WireMaterialKind ? > (nameof (material));
    set => SetAttribute (nameof (material), value);
  }
  /// <summary>
  /// DC resistance per unit length of the conductor at 20 °C.
  /// </summary>
  public float ? rDC20
  {
    get => GetAttribute < float ? > (nameof (rDC20));
    set => SetAttribute (nameof (rDC20), value);
  }
  /// <summary>
  /// Outside radius of the wire.
  /// </summary>
  public float ? radius
  {
    get => GetAttribute < float ? > (nameof (radius));
    set => SetAttribute (nameof (radius), value);
  }
  /// <summary>
  /// Current carrying capacity of the wire under stated thermal conditions.
  /// </summary>
  public float ? ratedCurrent
  {
    get => GetAttribute < float ? > (nameof (ratedCurrent));
    set => SetAttribute (nameof (ratedCurrent), value);
  }
  /// <summary>
  /// Describes the wire gauge or cross section (e.g., 4/0, #2, 336.5).
  /// </summary>
  public string ? sizeDescription
  {
    get => GetAttribute < string ? > (nameof (sizeDescription));
    set => SetAttribute (nameof (sizeDescription), value);
  }
  /// <summary>
  ///
  /// </summary>
  public float ? crossSection
  {
    get => GetAttribute < float ? > (nameof (crossSection));
    set => SetAttribute (nameof (crossSection), value);
  }

  /// <summary>
  /// Wire phase information associated with this wire information.
  /// </summary>
  public WirePhaseInfo[] WirePhaseInfo => GetAssoc1ToM<WirePhaseInfo> (
      nameof (WirePhaseInfo));
  public void AddToWirePhaseInfo (WirePhaseInfo assocObject) => AddAssoc1ToM (
      nameof (WirePhaseInfo), assocObject);
  public void RemoveFromWirePhaseInfo (
      WirePhaseInfo assocObject) => RemoveAssoc1ToM (nameof (WirePhaseInfo),
                                                     assocObject);
  public void RemoveAllFromWirePhaseInfo () => RemoveAllAssocs1ToM (
      nameof (WirePhaseInfo));
}
/// <summary>
/// Information on a wire carrying a single phase.
/// </summary>
[CimClass (ClassUri)]
public partial class WirePhaseInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#WirePhaseInfo";

  /// <summary>
  /// Phase information.
  /// </summary>
  public SinglePhaseKind ? phaseInfo
  {
    get => GetAttribute < SinglePhaseKind ? > (nameof (phaseInfo));
    set => SetAttribute (nameof (phaseInfo), value);
  }
  /// <summary>
  ///
  /// </summary>
  public object ? sequenceNumber
  {
    get => GetAttribute < object ? > (nameof (sequenceNumber));
    set => SetAttribute (nameof (sequenceNumber), value);
  }

  /// <summary>
  /// Wire assembly information using this wire phase information.
  /// </summary>
  public WireAssemblyInfo ? WireAssemblyInfo
  {
    get => GetAssoc1To1<WireAssemblyInfo> (nameof (WireAssemblyInfo));
    set => SetAssoc1To1 (nameof (WireAssemblyInfo), value);
  }
  /// <summary>
  /// Wire information contributing to this wire phase information.
  /// </summary>
  public WireInfo ? WireInfo
  {
    get => GetAssoc1To1<WireInfo> (nameof (WireInfo));
    set => SetAssoc1To1 (nameof (WireInfo), value);
  }
  /// <summary>
  /// Wire position with this wire phase information.
  /// </summary>
  public WirePosition ? WirePosition
  {
    get => GetAssoc1To1<WirePosition> (nameof (WirePosition));
    set => SetAssoc1To1 (nameof (WirePosition), value);
  }
}
/// <summary>
/// Identification, spacing and configuration of the wires of a conductor with
/// respect to a structure.
/// </summary>
[CimClass (ClassUri)]
public partial class WirePosition
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : IdentifiedObject (oid, metaClass)
{
  public new const string ClassUri = "http://iec.ch/TC57/CIM100#WirePosition";

  /// <summary>
  /// Signed horizontal distance from the wire at this position to a common
  /// reference point.
  /// </summary>
  public float ? xCoord
  {
    get => GetAttribute < float ? > (nameof (xCoord));
    set => SetAttribute (nameof (xCoord), value);
  }
  /// <summary>
  /// Signed vertical distance from the wire at this position: above ground
  /// (positive value) or burial depth below ground (negative value).
  /// </summary>
  public float ? yCoord
  {
    get => GetAttribute < float ? > (nameof (yCoord));
    set => SetAttribute (nameof (yCoord), value);
  }

  /// <summary>
  /// Wire spacing data this wire position belongs to.
  /// </summary>
  public WireSpacingInfo ? WireSpacingInfo
  {
    get => GetAssoc1To1<WireSpacingInfo> (nameof (WireSpacingInfo));
    set => SetAssoc1To1 (nameof (WireSpacingInfo), value);
  }

  /// <summary>
  /// Wire phase information for this wire position.
  /// </summary>
  public WirePhaseInfo[] WirePhaseInfo => GetAssoc1ToM<WirePhaseInfo> (
      nameof (WirePhaseInfo));
  public void AddToWirePhaseInfo (WirePhaseInfo assocObject) => AddAssoc1ToM (
      nameof (WirePhaseInfo), assocObject);
  public void RemoveFromWirePhaseInfo (
      WirePhaseInfo assocObject) => RemoveAssoc1ToM (nameof (WirePhaseInfo),
                                                     assocObject);
  public void RemoveAllFromWirePhaseInfo () => RemoveAllAssocs1ToM (
      nameof (WirePhaseInfo));
}
/// <summary>
/// Wire spacing data that associates multiple wire positions with the line
/// segment, and allows to calculate line segment impedances. Number of phases
/// can be derived from the number of associated wire positions whose phase is
/// not neutral.
/// </summary>
[CimClass (ClassUri)]
public partial class WireSpacingInfo
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : AssetInfo (oid, metaClass)
{
  public new const string ClassUri
      = "http://iec.ch/TC57/CIM100#WireSpacingInfo";

  /// <summary>
  /// If true, this spacing data describes a cable.
  /// </summary>
  public bool ? isCable
  {
    get => GetAttribute < bool ? > (nameof (isCable));
    set => SetAttribute (nameof (isCable), value);
  }
  /// <summary>
  /// Number of wire sub-conductors in the symmetrical bundle (typically between
  /// 1 and 4).
  /// </summary>
  public int ? phaseWireCount
  {
    get => GetAttribute < int ? > (nameof (phaseWireCount));
    set => SetAttribute (nameof (phaseWireCount), value);
  }
  /// <summary>
  /// Distance between wire sub-conductors in a symmetrical bundle.
  /// </summary>
  public float ? phaseWireSpacing
  {
    get => GetAttribute < float ? > (nameof (phaseWireSpacing));
    set => SetAttribute (nameof (phaseWireSpacing), value);
  }

  /// <summary>
  ///
  /// </summary>
  public Structure[] Structures => GetAssoc1ToM<Structure> (
      nameof (Structures));
  public void AddToStructures (Structure assocObject) => AddAssoc1ToM (
      nameof (Structures), assocObject);
  public void RemoveFromStructures (Structure assocObject) => RemoveAssoc1ToM (
      nameof (Structures), assocObject);
  public void RemoveAllFromStructures () => RemoveAllAssocs1ToM (
      nameof (Structures));
  /// <summary>
  /// All positions of single wires (phase or neutral) making the conductor.
  /// </summary>
  public WirePosition[] WirePositions => GetAssoc1ToM<WirePosition> (
      nameof (WirePositions));
  public void AddToWirePositions (WirePosition assocObject) => AddAssoc1ToM (
      nameof (WirePositions), assocObject);
  public void RemoveFromWirePositions (
      WirePosition assocObject) => RemoveAssoc1ToM (nameof (WirePositions),
                                                    assocObject);
  public void RemoveAllFromWirePositions () => RemoveAllAssocs1ToM (
      nameof (WirePositions));
}
/// <summary>
/// Root rdfs:Resource meta instance.
/// </summary>
[CimClass (ClassUri)]
public partial class Resource
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : ModelObject (oid, metaClass)
{
  public const string ClassUri
      = "http://www.w3.org/2000/01/rdf-schema#Resource";
}
/// <summary>
/// rdf:Description meta instance.
/// </summary>
[CimClass (ClassUri)]
public partial class Description
(IOIDDescriptor oid, ICimMetaClass metaClass)
    : Resource (oid, metaClass)
{
  public new const string ClassUri
      = "http://www.w3.org/1999/02/22-rdf-syntax-ns#Description";
}

/// <summary>
/// Kind of accumulation behaviour for read / measured values from individual
/// end points.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#AccumulationKind")]
public enum AccumulationKind
{
  /// <summary>
  /// A time-independent cumulative quantity much like a 'bulkQuantity' or a
  /// 'latchingQuantity', except that the accumulation stops at the maximum or
  /// minimum values. When the maximum is reached, any additional positive
  /// accumulation is discarded, but negative accumulation may be accepted (thus
  /// lowering the counter.) Likewise, when the negative bound is reached, any
  /// additional negative accumulation is discarded, but positive accumulation
  /// is accepted (thus increasing the counter.)
  /// </summary>
  boundedQuantity, /// <summary>
  /// A value from a register which represents the bulk quantity of a commodity.
  /// This quantity is computed as the integral of the commodity usage rate.
  /// This value is typically used as the basis for the dial reading at the
  /// meter, and as a result, will roll over upon reaching a maximum dial value.
  /// Note 1: With the metering system, the roll-over behaviour typically
  /// implies a roll-under behavior so that the value presented is always a
  /// positive value (e.g. unsigned integer or positive decimal.) However, when
  /// communicating data between enterprise applications a negative value might
  /// occur in a case such as net metering.Note 2: A 'bulkQuantity' refers
  /// primarily to the dial reading and not the consumption over a specific
  /// period of time.
  /// </summary>
  bulkQuantity, /// <summary>
  /// The sum of the previous billing period values and the present period
  /// value.Note: 'continuousCumulative' is commonly used in conjunction with
  /// 'demand', and it  would represent the cumulative sum of the previous
  /// billing period maximum demand values (as occurring with each demand reset)
  /// summed with the present period maximum demand value (which has yet to be
  /// reset.)
  /// </summary>
  continuousCumulative, /// <summary>
  /// The sum of the previous billing period values.Note: 'cumulative' is
  /// commonly used in conjunction with “demand.” Each demand reset causes the
  /// maximum demand value for the present billing period (since the last demand
  /// reset) to accumulate as an accumulative total of all maximum demands. So
  /// instead of 'zeroing' the demand register, a demand reset has the effect of
  /// adding the present maximum demand to this accumulating total.
  /// </summary>
  cumulative, /// <summary>
  /// The difference between the value at the end of the prescribed interval and
  /// the beginning of the interval. This is used for incremental interval data.
  /// Note: One common application would be for load profile data, another use
  /// might be to report the number of events within an interval (such as the
  /// number of equipment energisations within the specified period of time.)
  /// </summary>
  deltaData, /// <summary>
  /// As if a needle is swung out on the meter face to a value to indicate the
  /// current value.Note: An 'indicating' value is typically measured over
  /// hundreds of milliseconds or greater, or may imply a “pusher” mechanism to
  /// capture a value. Compare this to 'instantaneous' which is measured over a
  /// shorter period of time.
  /// </summary>
  indicating, /// <summary>
  /// Typically measured over the fastest period of time allowed by the
  /// definition of the metric (usually milliseconds or tens of
  /// milliseconds.)Note: 'instantaneous' was moved to attribute #3 in Ed.2 of
  /// IEC 61968-9, from attribute #1 in Ed.1 of IEC 61968-9.
  /// </summary>
  instantaneous, /// <summary>
  /// When this description is applied to a metered value, it implies that the
  /// value is a time-independent cumulative quantity much like a
  /// 'bulkQuantity', except that it latches upon the maximum value upon
  /// reaching that value. Any additional accumulation (positive or negative) is
  /// discarded until a reset occurs. Note: A 'latchingQuantity' may also occur
  /// in the downward direction – upon reaching a minimum value. The terms
  /// 'maximum' or 'minimum' (for 'aggregate') will usually be included when
  /// this type of accumulation behaviour is present. When this description is
  /// applied to an encoded value (UOM= 'Code'), it implies that the value has
  /// one or more bits which are latching. The condition that caused the bit to
  /// be set may have long since evaporated.In either case, the timestamp that
  /// accompanies the value may not coincide with the moment the value was
  /// initially set.In both cases a system will need to perform an operation to
  /// clear the latched value.
  /// </summary>
  latchingQuantity, /// <summary>
  /// Not applicable, or implied by the unit of measure.
  /// </summary>
  none, /// <summary>
  /// A form of accumulation which is selective with respect to time. Note :
  /// 'summation' could be considered a specialisation of 'bulkQuantity' as it
  /// selectively accumulates pulses over a timing pattern (while 'bulkQuantity'
  /// accumulates pulses all of the time).
  /// </summary>
  summation, /// <summary>
  /// A form of computation which introduces a time delay characteristic to the
  /// data value.
  /// </summary>
  timeDelay,
}
/// <summary>
/// Kind of aggregation for read / measured values from multiple end points.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#AggregateKind")]
public enum AggregateKind
{
  /// <summary>
  /// The value represents average.
  /// </summary>
  average, /// <summary>
  /// The value represents an amount over which a threshold was exceeded.
  /// </summary>
  excess, /// <summary>
  /// The fifth highest value observed.
  /// </summary>
  fifthMaximum, /// <summary>
  /// The fourth highest value observed.
  /// </summary>
  fourthMaximum, /// <summary>
  /// The value represents a programmed high threshold.
  /// </summary>
  highThreshold, /// <summary>
  /// The value represents a programmed low threshold.
  /// </summary>
  lowThreshold, /// <summary>
  /// The highest value observed.
  /// </summary>
  maximum, /// <summary>
  /// The smallest value observed.
  /// </summary>
  minimum, /// <summary>
  /// The nominal value.
  /// </summary>
  nominal, /// <summary>
  /// Not applicable.
  /// </summary>
  none, /// <summary>
  /// The normal value.
  /// </summary>
  normal, /// <summary>
  /// The second highest value observed.
  /// </summary>
  secondMaximum, /// <summary>
  /// The second smallest value observed.
  /// </summary>
  secondMinimum, /// <summary>
  /// The accumulated sum.
  /// </summary>
  sum, /// <summary>
  /// The third highest value observed.
  /// </summary>
  thirdMaximum,
}
/// <summary>
/// Lifecycle states of the metering installation at a usage point with respect
/// to readiness for billing via advanced metering infrastructure reads.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#AmiBillingReadyKind")]
public enum AmiBillingReadyKind
{
  /// <summary>
  /// Usage point is equipped with an AMI capable meter that is not yet
  /// currently equipped with a communications module.
  /// </summary>
  amiCapable, /// <summary>
  /// Usage point is equipped with an AMI capable meter; however, the AMI
  /// functionality has been disabled or is not being used.
  /// </summary>
  amiDisabled, /// <summary>
  /// Usage point is equipped with an operating AMI capable meter and accuracy
  /// has been certified for billing purposes.
  /// </summary>
  billingApproved, /// <summary>
  /// Usage point is equipped with an AMI capable meter having communications
  /// capability.
  /// </summary>
  enabled, /// <summary>
  /// Usage point is equipped with a non AMI capable meter.
  /// </summary>
  nonAmi, /// <summary>
  /// Usage point is not currently equipped with a meter.
  /// </summary>
  nonMetered, /// <summary>
  /// Usage point is equipped with an AMI capable meter that is functioning and
  /// communicating with the AMI network.
  /// </summary>
  operable,
}
/// <summary>
/// Usage for an asset model.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#AssetModelUsageKind")]
public enum AssetModelUsageKind
{
  /// <summary>
  /// Asset model is intended for use in customer substation.
  /// </summary>
  customerSubstation, /// <summary>
  /// Asset model is intended for use in distribution overhead network.
  /// </summary>
  distributionOverhead, /// <summary>
  /// Asset model is intended for use in underground distribution network.
  /// </summary>
  distributionUnderground, /// <summary>
  /// Other kind of asset model usage.
  /// </summary>
  other, /// <summary>
  /// Asset model is intended for use as streetlight.
  /// </summary>
  streetlight, /// <summary>
  /// Asset model is intended for use in substation.
  /// </summary>
  substation, /// <summary>
  /// Asset model is intended for use in transmission network.
  /// </summary>
  transmission, /// <summary>
  /// Usage of the asset model is unknown.
  /// </summary>
  unknown,
}
/// <summary>
/// Kind of Asynchronous Machine.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#AsynchronousMachineKind")]
public enum AsynchronousMachineKind
{
  /// <summary>
  /// The Asynchronous Machine is a generator.
  /// </summary>
  generator, /// <summary>
  /// The Asynchronous Machine is a motor.
  /// </summary>
  motor, /// <summary>
  ///
  /// </summary>
  generatorOrMotor,
}
/// <summary>
/// Switching arrangement for bay.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#BreakerConfiguration")]
public enum BreakerConfiguration
{
  /// <summary>
  /// Breaker and a half.
  /// </summary>
  breakerAndAHalf, /// <summary>
  /// Double breaker.
  /// </summary>
  doubleBreaker, /// <summary>
  /// No breaker.
  /// </summary>
  noBreaker, /// <summary>
  /// Single breaker.
  /// </summary>
  singleBreaker, /// <summary>
  ///
  /// </summary>
  groundSwitchWithDisconnector,
}
/// <summary>
/// Busbar layout for bay.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#BusbarConfiguration")]
public enum BusbarConfiguration
{
  /// <summary>
  /// Double bus.
  /// </summary>
  doubleBus, /// <summary>
  /// Main bus with transfer bus.
  /// </summary>
  mainWithTransfer, /// <summary>
  /// Ring bus.
  /// </summary>
  ringBus, /// <summary>
  /// Single bus.
  /// </summary>
  singleBus, /// <summary>
  ///
  /// </summary>
  doubleMainWithTransfer, /// <summary>
  ///
  /// </summary>
  noBus,
}
/// <summary>
/// Kind of cable construction.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CableConstructionKind")]
public enum CableConstructionKind
{
  /// <summary>
  /// Compacted cable.
  /// </summary>
  compacted, /// <summary>
  /// Compressed cable.
  /// </summary>
  compressed, /// <summary>
  /// Other kind of cable construction.
  /// </summary>
  other, /// <summary>
  /// Sector cable.
  /// </summary>
  sector, /// <summary>
  /// Segmental cable.
  /// </summary>
  segmental, /// <summary>
  /// Solid cable.
  /// </summary>
  solid, /// <summary>
  /// Stranded cable.
  /// </summary>
  stranded,
}
/// <summary>
/// Kind of cable outer jacket.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CableOuterJacketKind")]
public enum CableOuterJacketKind
{
  /// <summary>
  /// Insulating cable outer jacket.
  /// </summary>
  insulating, /// <summary>
  /// Linear low density polyethylene cable outer jacket.
  /// </summary>
  linearLowDensityPolyethylene, /// <summary>
  /// Cable has no outer jacket.
  /// </summary>
  none, /// <summary>
  /// Pther kind of cable outer jacket.
  /// </summary>
  other, /// <summary>
  /// Polyethylene cable outer jacket.
  /// </summary>
  polyethylene, /// <summary>
  /// PVC cable outer jacket.
  /// </summary>
  pvc, /// <summary>
  /// Semiconducting cable outer jacket.
  /// </summary>
  semiconducting,
}
/// <summary>
/// Kind of cable shield material.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CableShieldMaterialKind")]
public enum CableShieldMaterialKind
{
  /// <summary>
  /// Aluminum cable shield.
  /// </summary>
  aluminum, /// <summary>
  /// Copper cable shield.
  /// </summary>
  copper, /// <summary>
  /// Lead cable shield.
  /// </summary>
  lead, /// <summary>
  /// Other kind of cable shield material.
  /// </summary>
  other, /// <summary>
  /// Steel cable shield.
  /// </summary>
  steel,
}
/// <summary>
/// Kind of communication direction.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#ComDirectionKind")]
public enum ComDirectionKind
{
  /// <summary>
  /// Communication with the device is bi-directional.
  /// </summary>
  biDirectional, /// <summary>
  /// Communication is from device.
  /// </summary>
  fromDevice, /// <summary>
  /// Communication is to device.
  /// </summary>
  toDevice,
}
/// <summary>
/// Kind of communication technology.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#ComTechnologyKind")]
public enum ComTechnologyKind
{
  /// <summary>
  /// Communicates using a public cellular radio network. A specific variant of
  /// 'rf'.
  /// </summary>
  cellular, /// <summary>
  /// Communicates using one or more of a family of frame-based computer
  /// networking technologies conforming to the IEEE 802.3 standard.
  /// </summary>
  ethernet, /// <summary>
  /// Communicates using power line communication technologies conforming to the
  /// standards established by the HomePlug Powerline Alliance. A specific
  /// variant of 'plc'.
  /// </summary>
  homePlug, /// <summary>
  /// Communicates using a public one-way or two-way radio-based paging network.
  /// A specific variant of 'rf'.
  /// </summary>
  pager, /// <summary>
  /// Communicates using a basic, wireline telephone system.
  /// </summary>
  phone, /// <summary>
  /// Communicates using power line communication technologies.
  /// </summary>
  plc, /// <summary>
  /// Communicates using private or public radio-based technology.
  /// </summary>
  rf, /// <summary>
  /// Communicates using a mesh radio technology. A specific variant of 'rf'.
  /// </summary>
  rfMesh, /// <summary>
  /// Communicates using radio communication technologies conforming to the
  /// standards established by the ZigBee. A specific variant of 'rf'.
  /// </summary>
  zigbee,
}
/// <summary>
/// Kind of commodity being measured.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CommodityKind")]
public enum CommodityKind
{
  /// <summary>
  /// Atmospheric air
  /// </summary>
  air, /// <summary>
  /// The element has an atomic number of 6.
  /// </summary>
  carbon, /// <summary>
  /// Methane CH4
  /// </summary>
  ch4, /// <summary>
  /// Carbon Dioxide CO2
  /// </summary>
  co2, /// <summary>
  /// A measurement of the communication infrastructure itself.
  /// </summary>
  communication, /// <summary>
  /// The cool fluid returns warmer than when it was sent. The heat conveyed may
  /// be metered.
  /// </summary>
  coolingFluid, /// <summary>
  /// It is possible for a meter to be outfitted with an external VT and/or CT.
  /// The meter might not be aware of these devices, and the display not
  /// compensate for their presence. Ultimately, when these scalars are applied,
  /// the value that represents the service value is called the “primary
  /// metered” value. The “index” in sub-category 3 mirrors those of
  /// sub-category 0.
  /// </summary>
  electricityPrimaryMetered, /// <summary>
  /// All types of metered quantities. This type of reading comes from the meter
  /// and represents a “secondary” metered value.
  /// </summary>
  electricitySecondaryMetered, /// <summary>
  /// Hexachlorocyclohexane HCH
  /// </summary>
  hch, /// <summary>
  /// This fluid is likely in liquid form. It is not necessarily water or water
  /// based. The warm fluid returns cooler than when it was sent. The heat
  /// conveyed may be metered.
  /// </summary>
  heatingFluid, /// <summary>
  /// (SF6 is found separately below.)
  /// </summary>
  insulativeGas, /// <summary>
  /// Oil that is used in transformers to provide insulation and heat
  /// conduction.
  /// </summary>
  insulativeOil, /// <summary>
  /// Internet service
  /// </summary>
  internet, /// <summary>
  /// A naturally occurring hydrocarbon  gas mixture.
  /// </summary>
  naturalGas, /// <summary>
  /// Not Applicable
  /// </summary>
  none, /// <summary>
  /// Reclaimed water – possibly used for irrigation but not sufficiently
  /// treated to be considered safe for drinking.
  /// </summary>
  nonpotableWater, /// <summary>
  /// Nitrous Oxides NOX
  /// </summary>
  nox, /// <summary>
  /// Perfluorocarbons PFC
  /// </summary>
  pfc, /// <summary>
  /// Drinkable water
  /// </summary>
  potableWater, /// <summary>
  /// The formula is C3H8
  /// </summary>
  propane, /// <summary>
  /// trash
  /// </summary>
  refuse, /// <summary>
  /// Sulfurhexafluoride SF6
  /// </summary>
  sf6, /// <summary>
  /// Sulfur Dioxide SO2
  /// </summary>
  so2, /// <summary>
  /// Water in steam form, usually used for heating.
  /// </summary>
  steam, /// <summary>
  /// Television
  /// </summary>
  tvLicence, /// <summary>
  /// (Sewerage)
  /// </summary>
  wasteWater,
}
/// <summary>
/// Method of cooling a machine.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CoolantType")]
public enum CoolantType
{
  /// <summary>
  /// Air.
  /// </summary>
  air, /// <summary>
  /// Hydrogen gas.
  /// </summary>
  hydrogenGas, /// <summary>
  /// Water.
  /// </summary>
  water,
}
/// <summary>
/// Kind of cooling.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CoolingKind")]
public enum CoolingKind
{
  /// <summary>
  ///
  /// </summary>
  forcedAir, /// <summary>
  ///
  /// </summary>
  forcedOilAndAir, /// <summary>
  ///
  /// </summary>
  other, /// <summary>
  ///
  /// </summary>
  selfCooling, /// <summary>
  ///
  /// </summary>
  forcedOil, /// <summary>
  ///
  /// </summary>
  forcedOilAndWater,
}
/// <summary>
/// Kind of corporate standard.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CorporateStandardKind")]
public enum CorporateStandardKind
{
  /// <summary>
  /// Asset model is used experimentally.
  /// </summary>
  experimental, /// <summary>
  /// Other kind of corporate standard for the asset model.
  /// </summary>
  other, /// <summary>
  /// Asset model is used as corporate standard.
  /// </summary>
  standard, /// <summary>
  /// Asset model usage is under evaluation.
  /// </summary>
  underEvaluation,
}
/// <summary>
/// Monetary currencies.  ISO 4217 standard including 3-character currency code.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#Currency")]
public enum Currency
{
  /// <summary>
  /// United Arab Emirates dirham.
  /// </summary>
  AED, /// <summary>
  /// Afghan afghani.
  /// </summary>
  AFN, /// <summary>
  /// Albanian lek.
  /// </summary>
  ALL, /// <summary>
  /// Armenian dram.
  /// </summary>
  AMD, /// <summary>
  /// Netherlands Antillean guilder.
  /// </summary>
  ANG, /// <summary>
  /// Angolan kwanza.
  /// </summary>
  AOA, /// <summary>
  /// Argentine peso.
  /// </summary>
  ARS, /// <summary>
  /// Australian dollar.
  /// </summary>
  AUD, /// <summary>
  /// Aruban florin.
  /// </summary>
  AWG, /// <summary>
  /// Azerbaijani manat.
  /// </summary>
  AZN, /// <summary>
  /// Bosnia and Herzegovina convertible mark.
  /// </summary>
  BAM, /// <summary>
  /// Barbados dollar.
  /// </summary>
  BBD, /// <summary>
  /// Bangladeshi taka.
  /// </summary>
  BDT, /// <summary>
  /// Bulgarian lev.
  /// </summary>
  BGN, /// <summary>
  /// Bahraini dinar.
  /// </summary>
  BHD, /// <summary>
  /// Burundian franc.
  /// </summary>
  BIF, /// <summary>
  /// Bermudian dollar (customarily known as Bermuda dollar).
  /// </summary>
  BMD, /// <summary>
  /// Brunei dollar.
  /// </summary>
  BND, /// <summary>
  /// Boliviano.
  /// </summary>
  BOB, /// <summary>
  /// Bolivian Mvdol (funds code).
  /// </summary>
  BOV, /// <summary>
  /// Brazilian real.
  /// </summary>
  BRL, /// <summary>
  /// Bahamian dollar.
  /// </summary>
  BSD, /// <summary>
  /// Bhutanese ngultrum.
  /// </summary>
  BTN, /// <summary>
  /// Botswana pula.
  /// </summary>
  BWP, /// <summary>
  /// Belarusian ruble.
  /// </summary>
  BYR, /// <summary>
  /// Belize dollar.
  /// </summary>
  BZD, /// <summary>
  /// Canadian dollar.
  /// </summary>
  CAD, /// <summary>
  /// Congolese franc.
  /// </summary>
  CDF, /// <summary>
  /// Swiss franc.
  /// </summary>
  CHF, /// <summary>
  /// Unidad de Fomento (funds code), Chile.
  /// </summary>
  CLF, /// <summary>
  /// Chilean peso.
  /// </summary>
  CLP, /// <summary>
  /// Chinese yuan.
  /// </summary>
  CNY, /// <summary>
  /// Colombian peso.
  /// </summary>
  COP, /// <summary>
  /// Unidad de Valor Real.
  /// </summary>
  COU, /// <summary>
  /// Costa Rican colon.
  /// </summary>
  CRC, /// <summary>
  /// Cuban convertible peso.
  /// </summary>
  CUC, /// <summary>
  /// Cuban peso.
  /// </summary>
  CUP, /// <summary>
  /// Cape Verde escudo.
  /// </summary>
  CVE, /// <summary>
  /// Czech koruna.
  /// </summary>
  CZK, /// <summary>
  /// Djiboutian franc.
  /// </summary>
  DJF, /// <summary>
  /// Danish krone.
  /// </summary>
  DKK, /// <summary>
  /// Dominican peso.
  /// </summary>
  DOP, /// <summary>
  /// Algerian dinar.
  /// </summary>
  DZD, /// <summary>
  /// Estonian kroon.
  /// </summary>
  EEK, /// <summary>
  /// Egyptian pound.
  /// </summary>
  EGP, /// <summary>
  /// Eritrean nakfa.
  /// </summary>
  ERN, /// <summary>
  /// Ethiopian birr.
  /// </summary>
  ETB, /// <summary>
  /// Euro.
  /// </summary>
  EUR, /// <summary>
  /// Fiji dollar.
  /// </summary>
  FJD, /// <summary>
  /// Falkland Islands pound.
  /// </summary>
  FKP, /// <summary>
  /// Pound sterling.
  /// </summary>
  GBP, /// <summary>
  /// Georgian lari.
  /// </summary>
  GEL, /// <summary>
  /// Ghanaian cedi.
  /// </summary>
  GHS, /// <summary>
  /// Gibraltar pound.
  /// </summary>
  GIP, /// <summary>
  /// Gambian dalasi.
  /// </summary>
  GMD, /// <summary>
  /// Guinean franc.
  /// </summary>
  GNF, /// <summary>
  /// Guatemalan quetzal.
  /// </summary>
  GTQ, /// <summary>
  /// Guyanese dollar.
  /// </summary>
  GYD, /// <summary>
  /// Hong Kong dollar.
  /// </summary>
  HKD, /// <summary>
  /// Honduran lempira.
  /// </summary>
  HNL, /// <summary>
  /// Croatian kuna.
  /// </summary>
  HRK, /// <summary>
  /// Haitian gourde.
  /// </summary>
  HTG, /// <summary>
  /// Hungarian forint.
  /// </summary>
  HUF, /// <summary>
  /// Indonesian rupiah.
  /// </summary>
  IDR, /// <summary>
  /// Israeli new sheqel.
  /// </summary>
  ILS, /// <summary>
  /// Indian rupee.
  /// </summary>
  INR, /// <summary>
  /// Iraqi dinar.
  /// </summary>
  IQD, /// <summary>
  /// Iranian rial.
  /// </summary>
  IRR, /// <summary>
  /// Icelandic krуna.
  /// </summary>
  ISK, /// <summary>
  /// Jamaican dollar.
  /// </summary>
  JMD, /// <summary>
  /// Jordanian dinar.
  /// </summary>
  JOD, /// <summary>
  /// Japanese yen.
  /// </summary>
  JPY, /// <summary>
  /// Kenyan shilling.
  /// </summary>
  KES, /// <summary>
  /// Kyrgyzstani som.
  /// </summary>
  KGS, /// <summary>
  /// Cambodian riel.
  /// </summary>
  KHR, /// <summary>
  /// Comoro franc.
  /// </summary>
  KMF, /// <summary>
  /// North Korean won.
  /// </summary>
  KPW, /// <summary>
  /// South Korean won.
  /// </summary>
  KRW, /// <summary>
  /// Kuwaiti dinar.
  /// </summary>
  KWD, /// <summary>
  /// Cayman Islands dollar.
  /// </summary>
  KYD, /// <summary>
  /// Kazakhstani tenge.
  /// </summary>
  KZT, /// <summary>
  /// Lao kip.
  /// </summary>
  LAK, /// <summary>
  /// Lebanese pound.
  /// </summary>
  LBP, /// <summary>
  /// Sri Lanka rupee.
  /// </summary>
  LKR, /// <summary>
  /// Liberian dollar.
  /// </summary>
  LRD, /// <summary>
  /// Lesotho loti.
  /// </summary>
  LSL, /// <summary>
  /// Lithuanian litas.
  /// </summary>
  LTL, /// <summary>
  /// Latvian lats.
  /// </summary>
  LVL, /// <summary>
  /// Libyan dinar.
  /// </summary>
  LYD, /// <summary>
  /// Moroccan dirham.
  /// </summary>
  MAD, /// <summary>
  /// Moldovan leu.
  /// </summary>
  MDL, /// <summary>
  /// Malagasy ariary.
  /// </summary>
  MGA, /// <summary>
  /// Macedonian denar.
  /// </summary>
  MKD, /// <summary>
  /// Myanma kyat.
  /// </summary>
  MMK, /// <summary>
  /// Mongolian tugrik.
  /// </summary>
  MNT, /// <summary>
  /// Macanese pataca.
  /// </summary>
  MOP, /// <summary>
  /// Mauritanian ouguiya.
  /// </summary>
  MRO, /// <summary>
  /// Mauritian rupee.
  /// </summary>
  MUR, /// <summary>
  /// Maldivian rufiyaa.
  /// </summary>
  MVR, /// <summary>
  /// Malawian kwacha.
  /// </summary>
  MWK, /// <summary>
  /// Mexican peso.
  /// </summary>
  MXN, /// <summary>
  /// Malaysian ringgit.
  /// </summary>
  MYR, /// <summary>
  /// Mozambican metical.
  /// </summary>
  MZN, /// <summary>
  /// Namibian dollar.
  /// </summary>
  NAD, /// <summary>
  /// Nigerian naira.
  /// </summary>
  NGN, /// <summary>
  /// Cordoba oro.
  /// </summary>
  NIO, /// <summary>
  /// Norwegian krone.
  /// </summary>
  NOK, /// <summary>
  /// Nepalese rupee.
  /// </summary>
  NPR, /// <summary>
  /// New Zealand dollar.
  /// </summary>
  NZD, /// <summary>
  /// Omani rial.
  /// </summary>
  OMR, /// <summary>
  /// Panamanian balboa.
  /// </summary>
  PAB, /// <summary>
  /// Peruvian nuevo sol.
  /// </summary>
  PEN, /// <summary>
  /// Papua New Guinean kina.
  /// </summary>
  PGK, /// <summary>
  /// Philippine peso.
  /// </summary>
  PHP, /// <summary>
  /// Pakistani rupee.
  /// </summary>
  PKR, /// <summary>
  /// Polish zloty.
  /// </summary>
  PLN, /// <summary>
  /// Paraguayan guaranн.
  /// </summary>
  PYG, /// <summary>
  /// Qatari rial.
  /// </summary>
  QAR, /// <summary>
  /// Romanian new leu.
  /// </summary>
  RON, /// <summary>
  /// Serbian dinar.
  /// </summary>
  RSD, /// <summary>
  /// Russian rouble.
  /// </summary>
  RUB, /// <summary>
  /// Rwandan franc.
  /// </summary>
  RWF, /// <summary>
  /// Saudi riyal.
  /// </summary>
  SAR, /// <summary>
  /// Solomon Islands dollar.
  /// </summary>
  SBD, /// <summary>
  /// Seychelles rupee.
  /// </summary>
  SCR, /// <summary>
  /// Sudanese pound.
  /// </summary>
  SDG, /// <summary>
  /// Swedish krona/kronor.
  /// </summary>
  SEK, /// <summary>
  /// Singapore dollar.
  /// </summary>
  SGD, /// <summary>
  /// Saint Helena pound.
  /// </summary>
  SHP, /// <summary>
  /// Sierra Leonean leone.
  /// </summary>
  SLL, /// <summary>
  /// Somali shilling.
  /// </summary>
  SOS, /// <summary>
  /// Surinamese dollar.
  /// </summary>
  SRD, /// <summary>
  /// Sгo Tomй and Prнncipe dobra.
  /// </summary>
  STD, /// <summary>
  /// Syrian pound.
  /// </summary>
  SYP, /// <summary>
  /// Lilangeni.
  /// </summary>
  SZL, /// <summary>
  /// Thai baht.
  /// </summary>
  THB, /// <summary>
  /// Tajikistani somoni.
  /// </summary>
  TJS, /// <summary>
  /// Turkmenistani manat.
  /// </summary>
  TMT, /// <summary>
  /// Tunisian dinar.
  /// </summary>
  TND, /// <summary>
  /// Tongan pa'anga.
  /// </summary>
  TOP, /// <summary>
  /// Turkish lira.
  /// </summary>
  TRY, /// <summary>
  /// Trinidad and Tobago dollar.
  /// </summary>
  TTD, /// <summary>
  /// New Taiwan dollar.
  /// </summary>
  TWD, /// <summary>
  /// Tanzanian shilling.
  /// </summary>
  TZS, /// <summary>
  /// Ukrainian hryvnia.
  /// </summary>
  UAH, /// <summary>
  /// Ugandan shilling.
  /// </summary>
  UGX, /// <summary>
  /// United States dollar.
  /// </summary>
  USD, /// <summary>
  /// Uruguayan peso.
  /// </summary>
  UYU, /// <summary>
  /// Uzbekistan som.
  /// </summary>
  UZS, /// <summary>
  /// Venezuelan bolнvar fuerte.
  /// </summary>
  VEF, /// <summary>
  /// Vietnamese Dong.
  /// </summary>
  VND, /// <summary>
  /// Vanuatu vatu.
  /// </summary>
  VUV, /// <summary>
  /// Samoan tala.
  /// </summary>
  WST, /// <summary>
  /// CFA franc BEAC.
  /// </summary>
  XAF, /// <summary>
  /// East Caribbean dollar.
  /// </summary>
  XCD, /// <summary>
  /// CFA Franc BCEAO.
  /// </summary>
  XOF, /// <summary>
  /// CFP franc.
  /// </summary>
  XPF, /// <summary>
  /// Yemeni rial.
  /// </summary>
  YER, /// <summary>
  /// South African rand.
  /// </summary>
  ZAR, /// <summary>
  /// Zambian kwacha.
  /// </summary>
  ZMK, /// <summary>
  /// Zimbabwe dollar.
  /// </summary>
  ZWL,
}
/// <summary>
/// Style or shape of curve.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CurveStyle")]
public enum CurveStyle
{
  /// <summary>
  /// The Y-axis values are assumed constant until the next curve point and
  /// prior to the first curve point.
  /// </summary>
  constantYValue, /// <summary>
  /// The Y-axis values are assumed to be a straight line between values.  Also
  /// known as linear interpolation.
  /// </summary>
  straightLineYValues,
}
/// <summary>
/// Kind of customer.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#CustomerKind")]
public enum CustomerKind
{
  /// <summary>
  /// Commercial industrial customer.
  /// </summary>
  commercialIndustrial, /// <summary>
  /// Customer as energy service scheduler.
  /// </summary>
  energyServiceScheduler, /// <summary>
  /// Customer as energy service supplier.
  /// </summary>
  energyServiceSupplier, /// <summary>
  /// Internal use customer.
  /// </summary>
  internalUse, /// <summary>
  /// Other kind of customer.
  /// </summary>
  other, /// <summary>
  /// Pumping load customer.
  /// </summary>
  pumpingLoad, /// <summary>
  /// Residential customer.
  /// </summary>
  residential, /// <summary>
  /// Residential and commercial customer.
  /// </summary>
  residentialAndCommercial, /// <summary>
  /// Residential and streetlight customer.
  /// </summary>
  residentialAndStreetlight, /// <summary>
  /// Residential farm service customer.
  /// </summary>
  residentialFarmService, /// <summary>
  /// Residential streetlight or other related customer.
  /// </summary>
  residentialStreetlightOthers, /// <summary>
  /// Wind machine customer.
  /// </summary>
  windMachine,
}
/// <summary>
/// Possible states of asset deployment.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#DeploymentStateKind")]
public enum DeploymentStateKind
{
  /// <summary>
  /// Asset in service in deployment location.
  /// </summary>
  inService, /// <summary>
  /// Asset installed in deployment location.
  /// </summary>
  installed, /// <summary>
  /// Asset not yet installed in deployment location.
  /// </summary>
  notYetInstalled, /// <summary>
  /// Asset out of service, but in deployment location.
  /// </summary>
  outOfService, /// <summary>
  /// Asset removed from deployment location.
  /// </summary>
  removed,
}
/// <summary>
/// Kind of end device function.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#EndDeviceFunctionKind")]
public enum EndDeviceFunctionKind
{
  /// <summary>
  /// Autonomous application of daylight saving time (DST).
  /// </summary>
  autonomousDst, /// <summary>
  /// Demand response functions.
  /// </summary>
  demandResponse, /// <summary>
  /// Electricity metering.
  /// </summary>
  electricMetering, /// <summary>
  /// Gas metering.
  /// </summary>
  gasMetering, /// <summary>
  /// Presentation of metered values to a user or another system (always a
  /// function of a meter, but might not be supported by a load control unit).
  /// </summary>
  metrology, /// <summary>
  /// On-request reads.
  /// </summary>
  onRequestRead, /// <summary>
  /// Reporting historical power interruption data.
  /// </summary>
  outageHistory, /// <summary>
  /// Support for one or more relays that may be programmable in the meter (and
  /// tied to TOU, time pulse, load control or other functions).
  /// </summary>
  relaysProgramming, /// <summary>
  /// Detection and monitoring of reverse flow.
  /// </summary>
  reverseFlow, /// <summary>
  /// Water metering.
  /// </summary>
  waterMetering,
}
/// <summary>
/// Types of facilities at which an asset can be deployed.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#FacilityKind")]
public enum FacilityKind
{
  /// <summary>
  /// Distribution pole top.
  /// </summary>
  distributionPoleTop, /// <summary>
  /// Distribution substation.
  /// </summary>
  substationDistribution, /// <summary>
  /// Fossil plant substation.
  /// </summary>
  substationFossilPlant, /// <summary>
  /// Hydro plant substation.
  /// </summary>
  substationHydroPlant, /// <summary>
  /// Nuclear plant substation.
  /// </summary>
  substationNuclearPlant, /// <summary>
  /// Subtransmission substation.
  /// </summary>
  substationSubTransmission, /// <summary>
  /// Transmission substation.
  /// </summary>
  substationTransmission, /// <summary>
  ///
  /// </summary>
  substationSolarPlant, /// <summary>
  ///
  /// </summary>
  substationWindPlant,
}
/// <summary>
/// Kind of flow direction for reading/measured  values proper to some
/// commodities such as, for example, energy, power, demand.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#FlowDirectionKind")]
public enum FlowDirectionKind
{
  /// <summary>
  /// "Delivered," or "Imported" as defined 61968-2.Forward Active Energy is a
  /// positive kWh value as one would naturally expect to find as energy is
  /// supplied by the utility and consumed at the service.Forward Reactive
  /// Energy is a positive VArh value as one would naturally expect to find in
  /// the presence of inductive loading.In polyphase metering, the forward
  /// energy register is incremented when the sum of the phase energies is
  /// greater than zero:<img src="HTS_1.PNG" width="209" height="16" border="0"
  /// alt="graphic"/>
  /// </summary>
  forward, /// <summary>
  /// Typically used to describe that a power factor is lagging the reference
  /// value. Note 1: When used to describe VA, “lagging” describes a form of
  /// measurement where reactive power is considered in all four quadrants, but
  /// real power is considered only in quadrants I and IV.Note 2: When used to
  /// describe power factor, the term “Lagging” implies that the PF is negative.
  /// The term “lagging” in this case takes the place of the negative sign. If a
  /// signed PF value is to be passed by the data producer, then the direction
  /// of flow enumeration zero (none) should be used in order to avoid the
  /// possibility of creating an expression that employs a double negative. The
  /// data consumer should be able to tell from the sign of the data if the PF
  /// is leading or lagging. This principle is analogous to the concept that
  /// “Reverse” energy is an implied negative value, and to publish a negative
  /// reverse value would be ambiguous.Note 3: Lagging power factors typically
  /// indicate inductive loading.
  /// </summary>
  lagging, /// <summary>
  /// Typically used to describe that a power factor is leading the reference
  /// value.Note: Leading power factors typically indicate capacitive loading.
  /// </summary>
  leading, /// <summary>
  /// |Forward| - |Reverse|, See 61968-2.Note: In some systems, the value passed
  /// as a “net” value could become negative. In other systems the value passed
  /// as a “net” value is always a positive number, and rolls-over and
  /// rolls-under as needed.
  /// </summary>
  net, /// <summary>
  /// Not Applicable (N/A)
  /// </summary>
  none, /// <summary>
  /// Q1 minus Q4
  /// </summary>
  q1minusQ4, /// <summary>
  /// Reactive positive quadrants. (The term “lagging” is preferred.)
  /// </summary>
  q1plusQ2, /// <summary>
  /// Quadrants 1 and 3
  /// </summary>
  q1plusQ3, /// <summary>
  /// Quadrants 1 and 4 usually represent forward active energy
  /// </summary>
  q1plusQ4, /// <summary>
  /// Q2 minus Q3
  /// </summary>
  q2minusQ3, /// <summary>
  /// Quadrants 2 and 3 usually represent reverse active energy
  /// </summary>
  q2plusQ3, /// <summary>
  /// Quadrants 2 and 4
  /// </summary>
  q2plusQ4, /// <summary>
  /// Q3 minus Q2
  /// </summary>
  q3minusQ2, /// <summary>
  /// Reactive negative quadrants. (The term “leading” is preferred.)
  /// </summary>
  q3plusQ4, /// <summary>
  /// Q1 only
  /// </summary>
  quadrant1, /// <summary>
  /// Q2 only
  /// </summary>
  quadrant2, /// <summary>
  /// Q3 only
  /// </summary>
  quadrant3, /// <summary>
  /// Q4 only
  /// </summary>
  quadrant4, /// <summary>
  /// Reverse Active Energy is equivalent to "Received," or "Exported" as
  /// defined in 61968-2.Reverse Active Energy is a positive kWh value as one
  /// would expect to find when energy is backfed by the service onto the
  /// utility network.Reverse Reactive Energy is a positive VArh value as one
  /// would expect to find in the presence of capacitive loading and a leading
  /// Power Factor.In polyphase metering, the reverse energy register is
  /// incremented when the sum of the phase energies is less than zero:<img
  /// src="HTS_1.PNG" width="209" height="16" border="0" alt="graphic"/>Note:
  /// The value passed as a reverse value is always a positive value. It is
  /// understood by the label “reverse” that it represents negative flow.
  /// </summary>
  reverse, /// <summary>
  /// |Forward| + |Reverse|, See 61968-2.The sum of the commodity in all
  /// quadrants Q1+Q2+Q3+Q4.In polyphase metering, the total energy register is
  /// incremented when the absolute value of the sum of the phase energies is
  /// greater than zero:<img src="HTS_1.PNG" width="217" height="16" border="0"
  /// alt="graphic"/>
  /// </summary>
  total, /// <summary>
  /// In polyphase metering, the total by phase energy register is incremented
  /// when the sum of the absolute values of the phase energies is greater than
  /// zero:<img src="HTS_1.PNG" width="234" height="16" border="0"
  /// alt="graphic"/>In single phase metering, the formulas for “Total” and
  /// “Total by phase” collapse to the same expression. For communication
  /// purposes however, the “Total” enumeration should be used with single phase
  /// meter data.
  /// </summary>
  totalByPhase,
}
/// <summary>
/// Type of fuel.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#FuelType")]
public enum FuelType
{
  /// <summary>
  /// Generic coal, not including lignite type.
  /// </summary>
  coal, /// <summary>
  /// Natural gas.
  /// </summary>
  gas, /// <summary>
  /// Hard coal.
  /// </summary>
  hardCoal, /// <summary>
  /// The fuel is lignite coal.  Note that this is a special type of coal, so
  /// the other enum of coal is reserved for hard coal types or if the exact
  /// type of coal is not known.
  /// </summary>
  lignite, /// <summary>
  /// Oil.
  /// </summary>
  oil, /// <summary>
  /// Oil Shale.
  /// </summary>
  oilShale, /// <summary>
  /// Any fuel type not included in the rest of the enumerated value.
  /// </summary>
  other, /// <summary>
  /// Peat.
  /// </summary>
  peat,
}
/// <summary>
/// Specifies the capability of the hydro generating unit to convert energy as a
/// generator or pump.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#HydroEnergyConversionKind")]
public enum HydroEnergyConversionKind
{
  /// <summary>
  /// Able to generate power, but not able to pump water for energy storage.
  /// </summary>
  generator, /// <summary>
  /// Able to both generate power and pump water for energy storage.
  /// </summary>
  pumpAndGenerator,
}
/// <summary>
/// The type of hydro power plant.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#HydroPlantStorageKind")]
public enum HydroPlantStorageKind
{
  /// <summary>
  /// Pumped storage.
  /// </summary>
  pumpedStorage, /// <summary>
  /// Run of river.
  /// </summary>
  runOfRiver, /// <summary>
  /// Storage.
  /// </summary>
  storage,
}
/// <summary>
/// Type of turbine.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#HydroTurbineKind")]
public enum HydroTurbineKind
{
  /// <summary>
  /// Francis.
  /// </summary>
  francis, /// <summary>
  /// Kaplan.
  /// </summary>
  kaplan, /// <summary>
  /// Pelton.
  /// </summary>
  pelton, /// <summary>
  ///
  /// </summary>
  francisReversible, /// <summary>
  ///
  /// </summary>
  horizontalRB, /// <summary>
  ///
  /// </summary>
  kaplanRB, /// <summary>
  ///
  /// </summary>
  kaplanRBdiagonal, /// <summary>
  ///
  /// </summary>
  orthogonal,
}
/// <summary>
/// Possible 'in use' states that an asset can be in.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#InUseStateKind")]
public enum InUseStateKind
{
  /// <summary>
  /// Asset is deployed (in use) or is being put into use.
  /// </summary>
  inUse, /// <summary>
  /// Asset is not ready to be put into use.
  /// </summary>
  notReadyForUse, /// <summary>
  /// Asset is ready to be put into use.
  /// </summary>
  readyForUse,
}
/// <summary>
/// Kind of macro period for calculations on read / measured values.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#MacroPeriodKind")]
public enum MacroPeriodKind
{
  /// <summary>
  /// Captured during the billing period starting at midnight of the first day
  /// of the billing period (as defined by the billing cycle day). If during the
  /// current billing period, it specifies a period from the start of the
  /// current billing period until "now".
  /// </summary>
  billingPeriod, /// <summary>
  /// Daily period starting at midnight. If for the current day, this specifies
  /// the time from midnight to "now".
  /// </summary>
  daily, /// <summary>
  /// Monthly period starting at midnight on the first day of the month. If
  /// within the current month, this specifies the period from the start of the
  /// month until "now."
  /// </summary>
  monthly, /// <summary>
  /// Not applicable.
  /// </summary>
  none, /// <summary>
  /// A season of time spanning multiple months. E.g. "Summer," "Spring,"
  /// "Fall," and "Winter" based cycle. If within the current season, it
  /// specifies the period from the start of the current season until "now."
  /// </summary>
  seasonal, /// <summary>
  /// For the period defined by the start and end of the TimePeriod element in
  /// the message.
  /// </summary>
  specifiedPeriod, /// <summary>
  /// Weekly period starting at midnight on the first day of the week and ending
  /// the instant before midnight the last day of the week. If within the
  /// current week, it specifies the period from the start of the week until
  /// "now."
  /// </summary>
  weekly,
}
/// <summary>
/// Kind of read / measured value.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#MeasurementKind")]
public enum MeasurementKind
{
  /// <summary>
  /// A measurement related to an alarm
  /// </summary>
  alarm, /// <summary>
  /// An application name which is making or has made a request
  /// </summary>
  apTitle, /// <summary>
  /// The ratio of real energy (usually net Wh) to apparent energy (kVAh)
  /// </summary>
  apparentPowerFactor, /// <summary>
  /// Information that describes the logical context in which a request,
  /// measurement, or command is made.
  /// </summary>
  applicationContext, /// <summary>
  /// An asset identifier
  /// </summary>
  assetNumber, /// <summary>
  /// Sound
  /// </summary>
  audibleVolume, /// <summary>
  /// A measurement of dataflow
  /// </summary>
  bandwidth, /// <summary>
  /// An estimate of the battery ride through capacity
  /// </summary>
  batteryCarryover, /// <summary>
  /// Battery voltage
  /// </summary>
  batteryVoltage, /// <summary>
  /// Customer’s bill for the (Currency)
  /// </summary>
  billCarryover, /// <summary>
  /// Customer’s bill for the previous billing period (Currency)
  /// </summary>
  billLastPeriod, /// <summary>
  /// Customer’s bill, as known thus far within the present billing period
  /// (Currency)
  /// </summary>
  billToDate, /// <summary>
  /// A message target address implying all endpoint units within range of a
  /// particular sender
  /// </summary>
  broadcastAddress, /// <summary>
  /// Monthly fee for connection to commodity.
  /// </summary>
  connectionFee, /// <summary>
  /// funds
  /// </summary>
  currency, /// <summary>
  /// The flow of electrons
  /// </summary>
  current, /// <summary>
  /// A phase current zerocross timing measurement releative to a reference
  /// voltage zerocross
  /// </summary>
  currentAngle, /// <summary>
  /// A measurement of the departure of a phase current relative to the average
  /// current of all phases
  /// </summary>
  currentImbalance, /// <summary>
  /// An indication of or measurement of a loss of data
  /// </summary>
  dataOverflowAlarm, /// <summary>
  /// A measurement of the date and/or time in a clock, or a time stamp
  /// indicating when data was captured, when a maximum or minimum occurred, or
  /// to commemorate some other important aspect of a measurement
  /// </summary>
  date, /// <summary>
  /// The measurement of maximum power flow which is computed as energy usage
  /// over time, the dimensions of which are defined by a tariff
  /// </summary>
  demand, /// <summary>
  /// A threshold setting that determines the trip point that if exceeded would
  /// trigger a demand limiting action or alarm
  /// </summary>
  demandLimit, /// <summary>
  /// A count of the number of times demand has been reset (remotely, locally,
  /// and/or automatically.)
  /// </summary>
  demandReset, /// <summary>
  /// Endpoint target address Type1
  /// </summary>
  deviceAddressType1, /// <summary>
  /// Endpoint target address Type2
  /// </summary>
  deviceAddressType2, /// <summary>
  /// Endpoint target address Type3
  /// </summary>
  deviceAddressType3, /// <summary>
  /// Endpoint target address Type4
  /// </summary>
  deviceAddressType4, /// <summary>
  /// A unique identifier for the Endpoint’s configuration
  /// </summary>
  deviceClass, /// <summary>
  /// A measurement related to equipment diagnostics
  /// </summary>
  diagnostic, /// <summary>
  /// A linear distance or range radius
  /// </summary>
  distance, /// <summary>
  /// The ratio of the distortion VAh to the apparent VAh
  /// </summary>
  distortionPowerFactor, /// <summary>
  /// A measurement in which a V<sup>2</sup> I<sup>2</sup> term has both real
  /// and reactive components removed leaving only distortion. For example,
  /// distortion VAh = Sqrt( (V<sup>2</sup>h)(I<sup>2</sup>h) – (Wh)<sup>2</sup>
  /// – (VArh)<sup>2</sup>)
  /// </summary>
  distortionVoltAmp, /// <summary>
  /// A device serial number
  /// </summary>
  electronicSerialNumber, /// <summary>
  /// A setting that indicates an emergency limit
  /// </summary>
  emergencyLimit, /// <summary>
  /// An indication of tampering with a meter encoder
  /// </summary>
  encoderTamper, /// <summary>
  /// A unique identifier of the endDevice – the device providing measurements
  /// or under control of the network
  /// </summary>
  endDeviceID, /// <summary>
  /// Pertaining to the presence of voltage
  /// </summary>
  energization, /// <summary>
  /// Measuring the presence or absence of voltage on the load side of an
  /// electricity meter
  /// </summary>
  energizationLoadSide, /// <summary>
  /// Scalar quantity which may be increased or decreased in a system when it
  /// receives or produces work, respectively
  /// </summary>
  energy, /// <summary>
  /// A forced air moving device
  /// </summary>
  fan, /// <summary>
  /// Reciprocal of the period
  /// </summary>
  frequency, /// <summary>
  /// A measurement of the departure of the frequency from the nominal frequency
  /// </summary>
  frequencyExcursion, /// <summary>
  /// Duplicate with “currency”
  /// </summary>
  fund, /// <summary>
  /// Group target address Type1
  /// </summary>
  groupAddressType1, /// <summary>
  /// Group target address Type2
  /// </summary>
  groupAddressType2, /// <summary>
  /// Group target address Type3
  /// </summary>
  groupAddressType3, /// <summary>
  /// Group target address Type4
  /// </summary>
  groupAddressType4, /// <summary>
  /// A measurement of IEEE-1366 Average Service Availability Index
  /// </summary>
  ieee1366ASAI, /// <summary>
  /// A measurement of the IEEE-1366 Average Service Interruption Duration Index
  /// </summary>
  ieee1366ASIDI, /// <summary>
  /// A measurement of the IEEE-1366 Average Service Interruption Frequency
  /// Index
  /// </summary>
  ieee1366ASIFI, /// <summary>
  /// A measurement of the IEEE-1366 Customer average interruption duration
  /// index
  /// </summary>
  ieee1366CAIDI, /// <summary>
  /// A measurement of the IEEE-1366 Customer average interruption frequency
  /// index
  /// </summary>
  ieee1366CAIFI, /// <summary>
  /// A measurement of the IEEE-1366 Customers Experiencing Multiple
  /// Interruptions
  /// </summary>
  ieee1366CEMIn, /// <summary>
  /// A measurement of the IEEE-1366 Customers Experiencing Multiple Sustained
  /// and Momentary Interruptions
  /// </summary>
  ieee1366CEMSMIn, /// <summary>
  /// A measurement of the IEEE-1366 Customer Total Average Interruption
  /// Duration Index
  /// </summary>
  ieee1366CTAIDI, /// <summary>
  /// A measurement of the IEEE-1366 Momentary Average Interruption Frequency
  /// Index
  /// </summary>
  ieee1366MAIFI, /// <summary>
  /// A measurement of the IEEE-1366 Momentary Average event Interruption
  /// Frequency Index
  /// </summary>
  ieee1366MAIFIe, /// <summary>
  /// IEEE-1366 Momentary Interruption count
  /// </summary>
  ieee1366MomentaryInterruption, /// <summary>
  /// IEEE-1366 Momentary Interruption event count
  /// </summary>
  ieee1366MomentaryInterruptionEvent, /// <summary>
  /// IEEE-1366 System Average Interruption Duration Index
  /// </summary>
  ieee1366SAIDI, /// <summary>
  /// IEEE-1366 System Average Interruption Frequency Index
  /// </summary>
  ieee1366SAIFI, /// <summary>
  /// IEEE-1366 Sustained Interruption duration
  /// </summary>
  ieee1366SustainedInterruption, /// <summary>
  /// A measurement related to power interruptions (Note: often an interruption
  /// count or duration.)
  /// </summary>
  interruptionBehaviour, /// <summary>
  /// A measurement related to inversion tamper (Note: typically a count of
  /// inversions)
  /// </summary>
  inversionTamper, /// <summary>
  /// An IP address for the endpoint
  /// </summary>
  ipAddress, /// <summary>
  /// An energy, power, voltage, or current loss attributed to transmission or
  /// distribution line impedance
  /// </summary>
  lineLoss, /// <summary>
  /// A measurement related to load interruption (Note: typically a load
  /// interruption count or measurement of duration)
  /// </summary>
  loadInterrupt, /// <summary>
  /// A measurement related to load shed (Note: typically a load shed count or
  /// load shed duration)
  /// </summary>
  loadShed, /// <summary>
  /// A quantity lost due to “technical” reasons (such as line loss) or
  /// “non-technical” reasons (such as theft.)
  /// </summary>
  loss, /// <summary>
  /// A MAC address for the endpoint
  /// </summary>
  macAddress, /// <summary>
  /// A measurement related to the pending maintenance of equipment
  /// </summary>
  maintenance, /// <summary>
  /// The configuration given to a device at time of manufacture
  /// </summary>
  mfgAssignedConfigurationID, /// <summary>
  /// The serial number assigned to a device at time of manufacture
  /// </summary>
  mfgAssignedPhysicalSerialNumber, /// <summary>
  /// The product number assigned to a device at time of manufacture
  /// </summary>
  mfgAssignedProductNumber, /// <summary>
  /// A communication address assigned to a device at time of manufacture
  /// </summary>
  mfgAssignedUniqueCommunicationAddress, /// <summary>
  /// A message target address implying a large group of endpoint units within
  /// range of a particular sender
  /// </summary>
  multiCastAddress, /// <summary>
  /// A quantity that has a rotation sequence which is opposite to that of the
  /// power system
  /// </summary>
  negativeSequence, /// <summary>
  /// Not Applicable
  /// </summary>
  none, /// <summary>
  /// A communication address of a network endpoint used in one-way
  /// communication
  /// </summary>
  oneWayAddress, /// <summary>
  /// The ratio of real energy (usually net Wh) to phasor apparent energy (kVAh)
  /// </summary>
  phasorPowerFactor, /// <summary>
  /// The ratio of real energy (usually net Wh) to phasor reactive energy (kVAh)
  /// </summary>
  phasorReactivePower, /// <summary>
  /// A measurement related to physical tampering (Note: typically a tamper
  /// count)
  /// </summary>
  physicalTamper, /// <summary>
  /// A quantity that has a rotation sequence in agreement with that of the
  /// power system
  /// </summary>
  positiveSequence, /// <summary>
  /// The derivative of energy with respect to time, where the energy is being
  /// transferred or transformed.
  /// </summary>
  power, /// <summary>
  /// The ratio of real energy (usually net Wh) to apparent energy (kVAh)
  /// </summary>
  powerFactor, /// <summary>
  /// Tamper indicated while power was out
  /// </summary>
  powerLossTamper, /// <summary>
  /// A measurement related to power outages (Note: typically a status)
  /// </summary>
  powerOutage, /// <summary>
  /// A measurement related to power quality
  /// </summary>
  powerQuality, /// <summary>
  /// A measurement related to power restoration (Note: typically a status)
  /// </summary>
  powerRestoration, /// <summary>
  /// A measurement related to device programming (Note: typically a status
  /// measurement)
  /// </summary>
  programmed, /// <summary>
  /// A measurement related to pushbutton (Note: typically a status or count)
  /// </summary>
  pushbutton, /// <summary>
  /// A power measurement of Qh, where Qh is defined to be half of the sum of
  /// the Wh measurements on each phase plus the squareroot of 3 over two times
  /// the sum of the VArh measurements on each phase.
  /// </summary>
  quantityPower, /// <summary>
  /// A measurement related to relay activations
  /// </summary>
  relayActivation, /// <summary>
  /// A measurement related to relay cycling (Note1: one open and one closure
  /// together is one cycle, Note2: Usually expressed as a count)
  /// </summary>
  relayCycle, /// <summary>
  /// An indication of equipment tampering that shows equipment was moved or
  /// opened
  /// </summary>
  removalTamper, /// <summary>
  /// An indication of equipment tampering that shows equipment has been
  /// reprogrammed
  /// </summary>
  reprogrammingTamper, /// <summary>
  /// An indication of tampering as evidenced by reverse power flow
  /// </summary>
  reverseRotationTamper, /// <summary>
  /// A temporary dip in the supply voltage below the nominal value
  /// </summary>
  sag, /// <summary>
  /// A measurement of RF signal strength
  /// </summary>
  signalStrength, /// <summary>
  /// A measurement of received (RF) signal strength divided by the (RF) noise
  /// floor
  /// </summary>
  signaltoNoiseRatio, /// <summary>
  /// A temporary rise of the supply voltage over the nominal value
  /// </summary>
  swell, /// <summary>
  /// A measurement of the switch arm condition
  /// </summary>
  switchArmed, /// <summary>
  /// A measurement of the switch enablement status
  /// </summary>
  switchDisabled, /// <summary>
  /// A physical or logical switch position status which includes “opened” and
  /// “closed”, but for some products may also include “armed,” or other states
  /// that indicate a temporary state due to some condition.
  /// </summary>
  switchPosition, /// <summary>
  /// An indication of equipment tampering
  /// </summary>
  tamper, /// <summary>
  /// Tap changer position
  /// </summary>
  tapPosition, /// <summary>
  /// An energy price defined in a contract. The rate might be a price for
  /// energy, for power (usually expressed as a demand value), or some other
  /// measurement. The rate might be currency based, or as a code, or as a
  /// component of a larger tariff description.
  /// </summary>
  tariffRate, /// <summary>
  /// A quantity proportional to the energy of a system
  /// </summary>
  temperature, /// <summary>
  /// The ratio of the sum of the harmonics to the fundamental. (THD may measure
  /// either voltage or current, and may isolated to a given phase)
  /// </summary>
  totalHarmonicDistortion, /// <summary>
  /// A measurement of the energy or power loss in a transformer due to
  /// inefficiency
  /// </summary>
  transformerLoss, /// <summary>
  /// A communication address used for bidirectional communication
  /// </summary>
  twoWayAddress, /// <summary>
  /// A voltage dip classification per EN50160 or a similar national standard
  /// measuring the number of dips in the 10-15% range
  /// </summary>
  unipedeVoltageDip10to15, /// <summary>
  /// A voltage dip classification per EN50160 or a similar national standard
  /// measuring the number of dips in the 15-30% range
  /// </summary>
  unipedeVoltageDip15to30, /// <summary>
  /// A voltage dip classification per EN50160 or a similar national standard
  /// measuring the number of dips in the 30-60% range
  /// </summary>
  unipedeVoltageDip30to60, /// <summary>
  /// A voltage dip classification per EN50160 or a similar national standard
  /// measuring the number of dips in the 60-90% rangeA voltage dip
  /// classification per EN50160 or a similar national standard measuring the
  /// number of dips in the 60-90% range
  /// </summary>
  unipedeVoltageDip60to90, /// <summary>
  /// A voltage dip classification per EN50160 or a similar national standard
  /// measuring the number of dips in the 90-100% range
  /// </summary>
  unipedeVoltageDip90to100, /// <summary>
  /// The difference in electric potential between two points
  /// </summary>
  voltage, /// <summary>
  /// A phase voltage zerocross timing measurement relative to a reference
  /// voltage zerocross
  /// </summary>
  voltageAngle, /// <summary>
  /// A measurement of the departure of the voltage from the nominal voltage
  /// </summary>
  voltageExcursion, /// <summary>
  /// A measurement of the departure of a phase voltage relative to the average
  /// voltage of all phases.
  /// </summary>
  voltageImbalance, /// <summary>
  /// fluid volume
  /// </summary>
  volume, /// <summary>
  /// A fluid flow rate
  /// </summary>
  volumetricFlow, /// <summary>
  /// A reset triggered by a hardware “watchdog” circuit
  /// </summary>
  watchdogTimeout, /// <summary>
  /// The amount of time that current flow drops to a zero level or level below
  /// the ability of the sensor to sense
  /// </summary>
  zeroFlowDuration, /// <summary>
  /// The zero sequence current is the vector sum of the phase currents
  /// </summary>
  zeroSequence,
}
/// <summary>
/// Kind of period for reading / measuring values.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#MeasuringPeriodKind")]
public enum MeasuringPeriodKind
{
  /// <summary>
  /// 15-minute
  /// </summary>
  fifteenMinute, /// <summary>
  /// 5-minute
  /// </summary>
  fiveMinute, /// <summary>
  /// 10-minute Fixed Block
  /// </summary>
  fixedBlock10Min, /// <summary>
  /// 15-minute Fixed Block
  /// </summary>
  fixedBlock15Min, /// <summary>
  /// 1-minute Fixed Block
  /// </summary>
  fixedBlock1Min, /// <summary>
  /// 20-minute Fixed Block
  /// </summary>
  fixedBlock20Min, /// <summary>
  /// 30-minute Fixed Block
  /// </summary>
  fixedBlock30Min, /// <summary>
  /// 5-minute Fixed Block
  /// </summary>
  fixedBlock5Min, /// <summary>
  /// 60-minute Fixed Block
  /// </summary>
  fixedBlock60Min, /// <summary>
  /// Not applicable.
  /// </summary>
  none, /// <summary>
  /// 1-minute
  /// </summary>
  oneMinute, /// <summary>
  /// Within the present period of time
  /// </summary>
  present, /// <summary>
  /// Shifted within the previous monthly cycle and data set
  /// </summary>
  previous, /// <summary>
  /// 10-minute Rolling Block with 1-minute sub-intervals
  /// </summary>
  rollingBlock10MinIntvl1MinSubIntvl, /// <summary>
  /// 10-minute Rolling Block with 2-minute sub-intervals
  /// </summary>
  rollingBlock10MinIntvl2MinSubIntvl, /// <summary>
  /// 10-minute Rolling Block with 5-minute sub-intervals
  /// </summary>
  rollingBlock10MinIntvl5MinSubIntvl, /// <summary>
  /// 15-minute Rolling Block with 1-minute sub-intervals
  /// </summary>
  rollingBlock15MinIntvl1MinSubIntvl, /// <summary>
  /// 15-minute Rolling Block with 3-minute sub-intervals
  /// </summary>
  rollingBlock15MinIntvl3MinSubIntvl, /// <summary>
  /// 15-minute Rolling Block with 5-minute sub-intervals
  /// </summary>
  rollingBlock15MinIntvl5MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 10-minute sub-intervals
  /// </summary>
  rollingBlock30MinIntvl10MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 15-minute sub-intervals
  /// </summary>
  rollingBlock30MinIntvl15MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 2-minute sub-intervals
  /// </summary>
  rollingBlock30MinIntvl2MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 3-minute sub-intervals
  /// </summary>
  rollingBlock30MinIntvl3MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 5-minute sub-intervals.
  /// </summary>
  rollingBlock30MinIntvl5MinSubIntvl, /// <summary>
  /// 30-minute Rolling Block with 6-minute sub-intervals
  /// </summary>
  rollingBlock30MinIntvl6MinSubIntvl, /// <summary>
  /// 5-minute Rolling Block with 1-minute sub-intervals
  /// </summary>
  rollingBlock5MinIntvl1MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 10-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl10MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 12-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl12MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 15-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl15MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 20-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl20MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 30-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl30MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 4-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl4MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 5-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl5MinSubIntvl, /// <summary>
  /// 60-minute Rolling Block with 6-minute sub-intervals
  /// </summary>
  rollingBlock60MinIntvl6MinSubIntvl, /// <summary>
  /// 60-minute
  /// </summary>
  sixtyMinute, /// <summary>
  /// 10-minute
  /// </summary>
  tenMinute, /// <summary>
  /// 30-minute
  /// </summary>
  thirtyMinute, /// <summary>
  /// 3-minute
  /// </summary>
  threeMinute, /// <summary>
  /// 20-minute interval
  /// </summary>
  twentyMinute, /// <summary>
  /// 24-hour
  /// </summary>
  twentyfourHour, /// <summary>
  /// 2-minute
  /// </summary>
  twoMinute,
}
/// <summary>
/// Kind of meter multiplier.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#MeterMultiplierKind")]
public enum MeterMultiplierKind
{
  /// <summary>
  /// Current transformer ratio used to convert associated quantities to real
  /// measurements.
  /// </summary>
  ctRatio, /// <summary>
  /// Test constant.
  /// </summary>
  kE, /// <summary>
  /// Meter kh (watthour) constant. The number of watthours that must be applied
  /// to the meter to cause one disk revolution for an electromechanical meter
  /// or the number of watthours represented by one increment pulse for an
  /// electronic meter.
  /// </summary>
  kH, /// <summary>
  /// Register multiplier. The number to multiply the register reading by in
  /// order to get kWh.
  /// </summary>
  kR, /// <summary>
  /// Potential transformer ratio used to convert associated quantities to real
  /// measurements.
  /// </summary>
  ptRatio, /// <summary>
  /// Product of the CT ratio and PT ratio.
  /// </summary>
  transformerRatio,
}
/// <summary>
/// The direction attribute describes the side of  a limit that is a violation.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#OperationalLimitDirectionKind")]
public enum OperationalLimitDirectionKind
{
  /// <summary>
  /// An absoluteValue limit means that a monitored absolute value above the
  /// limit value is a violation.
  /// </summary>
  absoluteValue, /// <summary>
  /// High means that a monitored value above the limit value is a violation. If
  /// applied to a terminal flow, the positive direction is into the terminal.
  /// </summary>
  high, /// <summary>
  /// Low means a monitored value below the limit is a violation.  If applied to
  /// a terminal flow, the positive direction is into the terminal.
  /// </summary>
  low,
}
/// <summary>
/// The mode of operation for a Petersen coil.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#PetersenCoilModeKind")]
public enum PetersenCoilModeKind
{
  /// <summary>
  /// Automatic positioning.
  /// </summary>
  automaticPositioning, /// <summary>
  /// Fixed position.
  /// </summary>
  @fixed, /// <summary>
  /// Manual positioning.
  /// </summary>
  manual,
}
/// <summary>
/// An unordered enumeration of phase identifiers.  Allows designation of phases
/// for both transmission and distribution equipment, circuits and loads.   The
/// enumeration, by itself, does not describe how the phases are connected
/// together or connected to ground.  Ground is not explicitly denoted as a
/// phase.Residential and small commercial loads are often served from
/// single-phase, or split-phase, secondary circuits. For the example of s12N,
/// phases 1 and 2 refer to hot wires that are 180 degrees out of phase, while N
/// refers to the neutral wire. Through single-phase transformer connections,
/// these secondary circuits may be served from one or two of the primary phases
/// A, B, and C. For three-phase loads, use the A, B, C phase codes instead of
/// s12N.The integer values are from IEC 61968-9 to support revenue metering
/// applications.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#PhaseCode")]
public enum PhaseCode
{
  /// <summary>
  /// Phase A.
  /// </summary>
  A, /// <summary>
  /// Phases A and B.
  /// </summary>
  AB, /// <summary>
  /// Phases A, B, and C.
  /// </summary>
  ABC, /// <summary>
  /// Phases A, B, C, and N.
  /// </summary>
  ABCN, /// <summary>
  /// Phases A, B, and neutral.
  /// </summary>
  ABN, /// <summary>
  /// Phases A and C.
  /// </summary>
  AC, /// <summary>
  /// Phases A, C and neutral.
  /// </summary>
  ACN, /// <summary>
  /// Phases A and neutral.
  /// </summary>
  AN, /// <summary>
  /// Phase B.
  /// </summary>
  B, /// <summary>
  /// Phases B and C.
  /// </summary>
  BC, /// <summary>
  /// Phases B, C, and neutral.
  /// </summary>
  BCN, /// <summary>
  /// Phases B and neutral.
  /// </summary>
  BN, /// <summary>
  /// Phase C.
  /// </summary>
  C, /// <summary>
  /// Phases C and neutral.
  /// </summary>
  CN, /// <summary>
  /// Neutral phase.
  /// </summary>
  N, /// <summary>
  /// Unknown non-neutral phase.
  /// </summary>
  X, /// <summary>
  /// Unknown non-neutral phase plus neutral.
  /// </summary>
  XN, /// <summary>
  /// Two unknown non-neutral phases.
  /// </summary>
  XY, /// <summary>
  /// Two unknown non-neutral phases plus neutral.
  /// </summary>
  XYN, /// <summary>
  /// No phases specified.
  /// </summary>
  none,
}
/// <summary>
/// The configuration of phase connections for a single terminal device such as
/// a load or capacitor.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#PhaseShuntConnectionKind")]
public enum PhaseShuntConnectionKind
{
  /// <summary>
  /// Delta connection.
  /// </summary>
  D, /// <summary>
  /// Ground connection; use when explicit connection to ground needs to be
  /// expressed in combination with the phase code, such as for electrical
  /// wire/cable or for meters.
  /// </summary>
  G, /// <summary>
  /// Independent winding, for single-phase connections.
  /// </summary>
  I, /// <summary>
  /// Wye connection.
  /// </summary>
  Y, /// <summary>
  /// Wye, with neutral brought out for grounding.
  /// </summary>
  Yn,
}
/// <summary>
/// The construction kind of the potential transformer.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#PotentialTransformerKind")]
public enum PotentialTransformerKind
{
  /// <summary>
  /// The potential transformer is using capacitive coupling to create secondary
  /// voltage.
  /// </summary>
  capacitiveCoupling, /// <summary>
  /// The potential transformer is using induction coils to create secondary
  /// voltage.
  /// </summary>
  inductive,
}
/// <summary>
/// Reason for the reading being taken.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#ReadingReasonKind")]
public enum ReadingReasonKind
{
  /// <summary>
  /// Reading(s) taken or to be taken in response to a billing-related inquiry
  /// by a customer or other party. A variant of 'inquiry'.
  /// </summary>
  billing, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with the resetting of one
  /// or more demand registers in a meter.
  /// </summary>
  demandReset, /// <summary>
  /// Reading(s) taken or to be taken in response to an inquiry by a customer or
  /// other party.
  /// </summary>
  inquiry, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with installation of a
  /// meter.
  /// </summary>
  installation, /// <summary>
  /// Reading(s) taken or to be taken to support management of loads on
  /// distribution networks or devices.
  /// </summary>
  loadManagement, /// <summary>
  /// Reading(s) taken or to be taken to support research and analysis of loads
  /// on distribution networks or devices.
  /// </summary>
  loadResearch, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with a customer move-in
  /// event.
  /// </summary>
  moveIn, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with a customer move-out
  /// event.
  /// </summary>
  moveOut, /// <summary>
  /// Reading(s) taken or to be taken for some other reason or purpose.
  /// </summary>
  other, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with removal of a meter.
  /// </summary>
  removal, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with a connection or
  /// re-connection of service.
  /// </summary>
  serviceConnect, /// <summary>
  /// Reading(s) taken or to be taken in conjunction with a disconnection of
  /// service.
  /// </summary>
  serviceDisconnect,
}
/// <summary>
/// The kind of regulation model.   For example regulating voltage, reactive
/// power, active power, etc.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#RegulatingControlModeKind")]
public enum RegulatingControlModeKind
{
  /// <summary>
  /// Active power is specified.
  /// </summary>
  activePower, /// <summary>
  /// Admittance is specified.
  /// </summary>
  admittance, /// <summary>
  /// Current flow is specified.
  /// </summary>
  currentFlow, /// <summary>
  /// Power factor is specified.
  /// </summary>
  powerFactor, /// <summary>
  /// Reactive power is specified.
  /// </summary>
  reactivePower, /// <summary>
  /// Control switches on/off based on the local temperature (i.e., a
  /// thermostat).
  /// </summary>
  temperature, /// <summary>
  /// Control switches on/off by time of day. The times may change on the
  /// weekend, or in different seasons.
  /// </summary>
  timeScheduled, /// <summary>
  /// Voltage is specified.
  /// </summary>
  voltage,
}
/// <summary>
/// Type of rotor on physical machine.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#RotorKind")]
public enum RotorKind
{
  /// <summary>
  /// Round rotor type of synchronous machine.
  /// </summary>
  roundRotor, /// <summary>
  /// Salient pole type of synchronous machine.
  /// </summary>
  salientPole,
}
/// <summary>
/// Kind of seal condition.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SealConditionKind")]
public enum SealConditionKind
{
  /// <summary>
  /// Seal is broken.
  /// </summary>
  broken, /// <summary>
  /// Seal is locked.
  /// </summary>
  locked, /// <summary>
  /// Seal is missing.
  /// </summary>
  missing, /// <summary>
  /// Seal is open.
  /// </summary>
  open, /// <summary>
  /// Other kind of seal condition.
  /// </summary>
  other,
}
/// <summary>
/// Kind of seal.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SealKind")]
public enum SealKind
{
  /// <summary>
  /// Lead seal.
  /// </summary>
  lead, /// <summary>
  /// Lock seal.
  /// </summary>
  @lock, /// <summary>
  /// Other kind of seal.
  /// </summary>
  other, /// <summary>
  /// Steel seal.
  /// </summary>
  steel,
}
/// <summary>
/// Kind of service.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#ServiceKind")]
public enum ServiceKind
{
  /// <summary>
  /// Electricity service.
  /// </summary>
  electricity, /// <summary>
  /// Gas service.
  /// </summary>
  gas, /// <summary>
  /// Heat service.
  /// </summary>
  heat, /// <summary>
  /// Internet service.
  /// </summary>
  internet, /// <summary>
  /// Other kind of service.
  /// </summary>
  other, /// <summary>
  /// Rates (e.g. tax, charge, toll, duty, tariff, etc.) service.
  /// </summary>
  rates, /// <summary>
  /// Refuse (waster) service.
  /// </summary>
  refuse, /// <summary>
  /// Sewerage service.
  /// </summary>
  sewerage, /// <summary>
  /// Time service.
  /// </summary>
  time, /// <summary>
  /// TV license service.
  /// </summary>
  tvLicence, /// <summary>
  /// Water service.
  /// </summary>
  water,
}
/// <summary>
/// Kind of service multiplier.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#ServiceMultiplierKind")]
public enum ServiceMultiplierKind
{
  /// <summary>
  /// Current transformer ratio used to convert associated quantities to real
  /// measurements.
  /// </summary>
  ctRatio, /// <summary>
  /// Voltage transformer ratio used to convert associated quantities to real
  /// measurements.
  /// </summary>
  ptRatio, /// <summary>
  /// Product of the CT ratio and PT ratio.
  /// </summary>
  transformerRatio,
}
/// <summary>
///
/// </summary>
[CimClass ("http://gost.ru/2019/schema-cim01#ShieldGroundingKind")]
public enum ShieldGroundingKind
{
  /// <summary>
  ///
  /// </summary>
  none, /// <summary>
  ///
  /// </summary>
  oneSide, /// <summary>
  ///
  /// </summary>
  twoSide,
}
/// <summary>
/// Enumeration of single phase identifiers. Allows designation of single phases
/// for both transmission and distribution equipment, circuits and loads.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SinglePhaseKind")]
public enum SinglePhaseKind
{
  /// <summary>
  /// Phase A.
  /// </summary>
  A, /// <summary>
  /// Phase B.
  /// </summary>
  B, /// <summary>
  /// Phase C.
  /// </summary>
  C, /// <summary>
  /// Neutral.
  /// </summary>
  N,
}
/// <summary>
/// Kind of supplier.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SupplierKind")]
public enum SupplierKind
{
  /// <summary>
  /// Load Serving Entity
  /// </summary>
  lse, /// <summary>
  /// Meter Data Management Agent (MDMA) reads meters, validates meter data, and
  /// estimates missing data to be used in various applications
  /// </summary>
  mdma, /// <summary>
  /// Managed service provider (MSP) delivers services, such as network,
  /// application, infrastructure and security, via ongoing and regular support
  /// and active administration
  /// </summary>
  msp, /// <summary>
  /// Other kind of supplier.
  /// </summary>
  other, /// <summary>
  /// Entity that sells the service, but does not deliver to the customer;
  /// applies to the deregulated markets.
  /// </summary>
  retailer, /// <summary>
  /// Entity that delivers the service to the customer.
  /// </summary>
  utility,
}
/// <summary>
/// Synchronous machine type.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SynchronousMachineKind")]
public enum SynchronousMachineKind
{
  /// <summary>
  /// Indicates the synchronous machine can operate as a condenser.
  /// </summary>
  condenser, /// <summary>
  /// Indicates the synchronous machine can operate as a generator.
  /// </summary>
  generator, /// <summary>
  /// Indicates the synchronous machine can operate as a generator or as a
  /// condenser.
  /// </summary>
  generatorOrCondenser, /// <summary>
  /// Indicates the synchronous machine can operate as a generator or as a
  /// condenser or as a motor.
  /// </summary>
  generatorOrCondenserOrMotor, /// <summary>
  /// Indicates the synchronous machine can operate as a generator or as a
  /// motor.
  /// </summary>
  generatorOrMotor, /// <summary>
  /// Indicates the synchronous machine can operate as a motor.
  /// </summary>
  motor, /// <summary>
  /// Indicates the synchronous machine can operate as a motor or as a
  /// condenser.
  /// </summary>
  motorOrCondenser,
}
/// <summary>
/// Synchronous machine operating mode.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#SynchronousMachineOperatingMode")]
public enum SynchronousMachineOperatingMode
{
  /// <summary>
  /// Operating as condenser.
  /// </summary>
  condenser, /// <summary>
  /// Operating as generator.
  /// </summary>
  generator, /// <summary>
  /// Operating as motor.
  /// </summary>
  motor,
}
/// <summary>
/// Kind of tower construction.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#TowerConstructionKind")]
public enum TowerConstructionKind
{
  /// <summary>
  ///
  /// </summary>
  suspension, /// <summary>
  ///
  /// </summary>
  tension,
}
/// <summary>
/// Kind of underground structure.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#UndergroundStructureKind")]
public enum UndergroundStructureKind
{
  /// <summary>
  ///
  /// </summary>
  burd, /// <summary>
  ///
  /// </summary>
  enclosure, /// <summary>
  ///
  /// </summary>
  manhole, /// <summary>
  ///
  /// </summary>
  pad, /// <summary>
  ///
  /// </summary>
  pullbox, /// <summary>
  ///
  /// </summary>
  subsurfaceEnclosure, /// <summary>
  ///
  /// </summary>
  trench, /// <summary>
  ///
  /// </summary>
  tunnel, /// <summary>
  ///
  /// </summary>
  vault,
}
/// <summary>
/// The unit multipliers defined for the CIM.  When applied to unit symbols, the
/// unit symbol is treated as a derived unit. Regardless of the contents of the
/// unit symbol text, the unit symbol shall be treated as if it were a
/// single-character unit symbol. Unit symbols should not contain multipliers,
/// and it should be left to the multiplier to define the multiple for an entire
/// data type. For example, if a unit symbol is "m2Pers" and the multiplier is
/// "k", then the value is k(m**2/s), and the multiplier applies to the entire
/// final value, not to any individual part of the value. This can be
/// conceptualized by substituting a derived unit symbol for the unit type. If
/// one imagines that the symbol "Ю" represents the derived unit "m2Pers", then
/// applying the multiplier "k" can be conceptualized simply as "kЮ".For
/// example, the SI unit for mass is "kg" and not "g".  If the unit symbol is
/// defined as "kg", then the multiplier is applied to "kg" as a whole and does
/// not replace the "k" in front of the "g". In this case, the multiplier of "m"
/// would be used with the unit symbol of "kg" to represent one gram.  As a text
/// string, this violates the instructions in IEC 80000-1. However, because the
/// unit symbol in CIM is treated as a derived unit instead of as an SI unit, it
/// makes more sense to conceptualize the "kg" as if it were replaced by one of
/// the proposed replacements for the SI mass symbol. If one imagines that the
/// "kg" were replaced by a symbol "Ю", then it is easier to conceptualize the
/// multiplier "m" as creating the proper unit "mЮ", and not the forbidden unit
/// "mkg".
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#UnitMultiplier")]
public enum UnitMultiplier
{
  /// <summary>
  /// Exa 10**18.
  /// </summary>
  E, /// <summary>
  /// Giga 10**9.
  /// </summary>
  G, /// <summary>
  /// Mega 10**6.
  /// </summary>
  M, /// <summary>
  /// Peta 10**15.
  /// </summary>
  P, /// <summary>
  /// Tera 10**12.
  /// </summary>
  T, /// <summary>
  /// Yotta 10**24.
  /// </summary>
  Y, /// <summary>
  /// Zetta 10**21.
  /// </summary>
  Z, /// <summary>
  /// Atto 10**-18.
  /// </summary>
  a, /// <summary>
  /// Centi 10**-2.
  /// </summary>
  c, /// <summary>
  /// Deci 10**-1.
  /// </summary>
  d, /// <summary>
  /// Deca 10**1.
  /// </summary>
  da, /// <summary>
  /// Femto 10**-15.
  /// </summary>
  f, /// <summary>
  /// Hecto 10**2.
  /// </summary>
  h, /// <summary>
  /// Kilo 10**3.
  /// </summary>
  k, /// <summary>
  /// Milli 10**-3.
  /// </summary>
  m, /// <summary>
  /// Micro 10**-6.
  /// </summary>
  micro, /// <summary>
  /// Nano 10**-9.
  /// </summary>
  n, /// <summary>
  /// No multiplier or equivalently multiply by 1.
  /// </summary>
  none, /// <summary>
  /// Pico 10**-12.
  /// </summary>
  p, /// <summary>
  /// Yocto 10**-24.
  /// </summary>
  y, /// <summary>
  /// Zepto 10**-21.
  /// </summary>
  z,
}
/// <summary>
/// The derived units defined for usage in the CIM. In some cases, the derived
/// unit is equal to an SI unit. Whenever possible, the standard derived symbol
/// is used instead of the formula for the derived unit. For example, the unit
/// symbol Farad is defined as "F" instead of "CPerV". In cases where a standard
/// symbol does not exist for a derived unit, the formula for the unit is used
/// as the unit symbol. For example, density does not have a standard symbol and
/// so it is represented as "kgPerm3". With the exception of the "kg", which is
/// an SI unit, the unit symbols do not contain multipliers and therefore
/// represent the base derived unit to which a multiplier can be applied as a
/// whole. Every unit symbol is treated as an unparseable text as if it were a
/// single-letter symbol. The meaning of each unit symbol is defined by the
/// accompanying descriptive text and not by the text contents of the unit
/// symbol.To allow the widest possible range of serializations without
/// requiring special character handling, several substitutions are made which
/// deviate from the format described in IEC 80000-1. The division symbol "/" is
/// replaced by the letters "Per". Exponents are written in plain text after the
/// unit as "m3" instead of being formatted as "m" with a superscript of 3  or
/// introducing a symbol as in "m^3". The degree symbol "°" is replaced with the
/// letters "deg". Any clarification of the meaning for a substitution is
/// included in the description for the unit symbol.Non-SI units are included in
/// list of unit symbols to allow sources of data to be correctly labelled with
/// their non-SI units (for example, a GPS sensor that is reporting numbers that
/// represent feet instead of meters). This allows software to use the unit
/// symbol information correctly convert and scale the raw data of those sources
/// into SI-based units. The integer values are used for harmonization with IEC
/// 61850.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#UnitSymbol")]
public enum UnitSymbol
{
  /// <summary>
  /// Current in amperes.
  /// </summary>
  A, /// <summary>
  /// Frequency in hertz (1/s).
  /// </summary>
  Hz, /// <summary>
  /// Energy in joules (N·m = C·V = W·s).
  /// </summary>
  J, /// <summary>
  /// Specific energy, Joules / kg.
  /// </summary>
  JPerkg, /// <summary>
  /// Electric potential in volts (W/A).
  /// </summary>
  V, /// <summary>
  /// Apparent power in volt amperes. See also real power and reactive power.
  /// </summary>
  VA, /// <summary>
  /// Apparent energy in volt ampere hours.
  /// </summary>
  VAh, /// <summary>
  /// Reactive power in volt amperes reactive. The “reactive” or “imaginary”
  /// component of electrical power (VIsin(phi)). (See also real power and
  /// apparent power).Note: Different meter designs use different methods to
  /// arrive at their results. Some meters may compute reactive power as an
  /// arithmetic value, while others compute the value vectorially. The data
  /// consumer should determine the method in use and the suitability of the
  /// measurement for the intended purpose.
  /// </summary>
  VAr, /// <summary>
  /// Reactive energy in volt ampere reactive hours.
  /// </summary>
  VArh, /// <summary>
  /// Volt-hour, Volt hours.
  /// </summary>
  Vh, /// <summary>
  /// Real power in watts (J/s). Electrical power may have real and reactive
  /// components. The real portion of electrical power (I&#178;R or VIcos(phi)),
  /// is expressed in Watts. See also apparent power and reactive power.
  /// </summary>
  W, /// <summary>
  /// Real energy in watt hours.
  /// </summary>
  Wh, /// <summary>
  /// Plane angle in degrees.
  /// </summary>
  deg, /// <summary>
  /// Relative temperature in degrees Celsius.In the SI unit system the symbol
  /// is °C. Electric charge is measured in coulomb that has the unit symbol C.
  /// To distinguish degree Celsius from coulomb the symbol used in the UML is
  /// degC. The reason for not using °C is that the special character ° is
  /// difficult to manage in software.
  /// </summary>
  degC, /// <summary>
  /// Time in hours, hour = 60 min = 3600 s.
  /// </summary>
  h, /// <summary>
  /// Dimension less quantity, e.g. count, per unit, etc.
  /// </summary>
  none, /// <summary>
  /// Time in seconds.
  /// </summary>
  s,
}
/// <summary>
/// State of the usage point with respect to connection to the network.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#UsagePointConnectedKind")]
public enum UsagePointConnectedKind
{
  /// <summary>
  /// The usage point is connected to the network and able to receive or send
  /// the applicable commodity (electricity, gas, water, etc.).
  /// </summary>
  connected, /// <summary>
  /// The usage point has been disconnected through operation of a disconnect
  /// function within the meter present at the usage point.  The usage point is
  /// unable to receive or send the applicable commodity (electricity, gas,
  /// water, etc.)  A logical disconnect can often be achieved without utilising
  /// a field crew.
  /// </summary>
  logicallyDisconnected, /// <summary>
  /// The usage point has been disconnected from the network at a point upstream
  /// of the meter. The usage point is unable to receive or send the applicable
  /// commodity (electricity, gas, water, etc.). A physical disconnect is often
  /// achieved by utilising a field crew.
  /// </summary>
  physicallyDisconnected,
}
/// <summary>
/// Winding connection type.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#WindingConnection")]
public enum WindingConnection
{
  /// <summary>
  /// Autotransformer common winding.
  /// </summary>
  A, /// <summary>
  /// Delta.
  /// </summary>
  D, /// <summary>
  /// Independent winding, for single-phase connections.
  /// </summary>
  I, /// <summary>
  /// Wye.
  /// </summary>
  Y, /// <summary>
  /// Wye, with neutral brought out for grounding.
  /// </summary>
  Yn, /// <summary>
  /// ZigZag.
  /// </summary>
  Z, /// <summary>
  /// ZigZag, with neutral brought out for grounding.
  /// </summary>
  Zn,
}
/// <summary>
/// Insulation kind for windings.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#WindingInsulationKind")]
public enum WindingInsulationKind
{
  /// <summary>
  ///
  /// </summary>
  nomex, /// <summary>
  ///
  /// </summary>
  other, /// <summary>
  ///
  /// </summary>
  paper,
}
/// <summary>
/// Kind of wire insulation.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#WireInsulationKind")]
public enum WireInsulationKind
{
  /// <summary>
  /// Asbestos and varnished cambric wire insulation.
  /// </summary>
  asbestosAndVarnishedCambric, /// <summary>
  /// Belted pilc wire insulation.
  /// </summary>
  beltedPilc, /// <summary>
  /// Butyl wire insulation.
  /// </summary>
  butyl, /// <summary>
  /// Crosslinked polyethylene wire insulation.
  /// </summary>
  crosslinkedPolyethylene, /// <summary>
  /// Ethylene propylene rubber wire insulation.
  /// </summary>
  ethylenePropyleneRubber, /// <summary>
  /// High nolecular weight polyethylene wire insulation.
  /// </summary>
  highMolecularWeightPolyethylene, /// <summary>
  /// High pressure fluid filled wire insulation.
  /// </summary>
  highPressureFluidFilled, /// <summary>
  /// Oil paper wire insulation.
  /// </summary>
  oilPaper, /// <summary>
  /// Other kind of wire insulation.
  /// </summary>
  other, /// <summary>
  /// Ozone resistant rubber wire insulation.
  /// </summary>
  ozoneResistantRubber, /// <summary>
  /// Rubber wire insulation.
  /// </summary>
  rubber, /// <summary>
  /// Silicon rubber wire insulation.
  /// </summary>
  siliconRubber, /// <summary>
  /// Tree resistant high molecular weight polyethylene wire insulation.
  /// </summary>
  treeResistantHighMolecularWeightPolyethylene, /// <summary>
  /// Tree retardant crosslinked polyethylene wire insulation.
  /// </summary>
  treeRetardantCrosslinkedPolyethylene, /// <summary>
  /// Varnished cambric cloth wire insulation.
  /// </summary>
  varnishedCambricCloth, /// <summary>
  /// Varnished dacron glass wire insulation.
  /// </summary>
  varnishedDacronGlass,
}
/// <summary>
/// Kind of wire material.
/// </summary>
[CimClass ("http://iec.ch/TC57/CIM100#WireMaterialKind")]
public enum WireMaterialKind
{
  /// <summary>
  /// Aluminum-alloy conductor steel reinforced.
  /// </summary>
  aaac, /// <summary>
  /// Aluminum conductor steel reinforced.
  /// </summary>
  acsr, /// <summary>
  /// Aluminum wire.
  /// </summary>
  aluminum, /// <summary>
  /// Aluminum-alloy wire.
  /// </summary>
  aluminumAlloy, /// <summary>
  /// Aluminum-alloy-steel wire.
  /// </summary>
  aluminumAlloySteel, /// <summary>
  /// Aluminum-steel wire.
  /// </summary>
  aluminumSteel, /// <summary>
  /// Copper wire.
  /// </summary>
  copper, /// <summary>
  /// Other wire material.
  /// </summary>
  other, /// <summary>
  /// Steel wire.
  /// </summary>
  steel,
}
